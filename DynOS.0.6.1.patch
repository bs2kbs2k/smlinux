diff --git a/Makefile b/Makefile
index 772f31a..23e0d9d 100644
--- a/Makefile
+++ b/Makefile
@@ -428,6 +428,7 @@ SEG_FILES := $(SEGMENT_ELF_FILES) $(ACTOR_ELF_FILES) $(LEVEL_ELF_FILES)
 ##################### Compiler Options #######################
 INCLUDE_CFLAGS := -I include -I $(BUILD_DIR) -I $(BUILD_DIR)/include -I src -I .
 ENDIAN_BITWIDTH := $(BUILD_DIR)/endian-and-bitwidth
+include Makefile_dynos

 # Huge deleted N64 section was here

diff --git a/Makefile_dynos b/Makefile_dynos
new file mode 100644
index 0000000..749a48c
--- /dev/null
+++ b/Makefile_dynos
@@ -0,0 +1,28 @@
+# ----------------------
+# Dynamic Options System
+# ----------------------
+
+DYNOS_INPUT_DIR := ./dynos
+DYNOS_OUTPUT_DIR := $(BUILD_DIR)/dynos
+DYNOS_PACKS_DIR := $(BUILD_DIR)/dynos/packs
+DYNOS_INIT := \
+    mkdir -p $(DYNOS_INPUT_DIR); \
+    mkdir -p $(DYNOS_OUTPUT_DIR); \
+    mkdir -p $(DYNOS_PACKS_DIR); \
+    for f in $(DYNOS_INPUT_DIR)/*.txt; do \
+        [ -f "$$f" ] || continue; \
+        cp -f $$f $(DYNOS_OUTPUT_DIR)/$$(basename -- $$f); \
+    done;
+
+DYNOS_DO := $(shell $(call DYNOS_INIT))
+INCLUDE_CFLAGS += -DDYNOS
+
+# -------------
+# Render96 v2.0
+# -------------
+
+ifeq ($(findstring src/text/libs,$(SRC_DIRS)),src/text/libs)
+INCLUDE_CFLAGS += -DRENDER96_2_0
+else
+$(BUILD_DIR)/data/dynos_opt_vanilla_c.o: $(BUILD_DIR)/include/text_strings.h
+endif
diff --git a/data/dynos.c.h b/data/dynos.c.h
new file mode 100644
index 0000000..259bad3
--- /dev/null
+++ b/data/dynos.c.h
@@ -0,0 +1,154 @@
+#ifndef DYNOS_C_H
+#define DYNOS_C_H
+#ifndef __cplusplus
+
+#include "dynos.h"
+
+inline static void *make_copy(const void *p, size_t s) {
+    void *q = calloc(1, s);
+    memcpy(q, p, s);
+    return q;
+}
+
+#define expand(...)                     __VA_ARGS__
+#define va_string(str, size, fmt, ...)  char str[size]; snprintf(str, size, fmt, __VA_ARGS__);
+#define str_eq(str1, str2)              (strcmp(str1, str2) == 0)
+
+// The action signature is "bool (*) (const char *)"
+// The input is the button internal name (not label)
+// The output is the result of the action
+#define DYNOS_DEFINE_ACTION(func) \
+__attribute__((constructor)) \
+static void dynos_opt_add_action_##func() { \
+    dynos_opt_add_action(#func, func, false); \
+}
+
+//
+// Dynamic Array
+//
+
+void *__da_do(int, void **, int, void *, bool (*eq)(void *, void *));
+
+#define DynArray                                   void *
+#define da_new(type)                             ((void *) __da_do(0, NULL, (int) sizeof(type), NULL, NULL))
+#define da_delete(da)                            ((void) __da_do(1, &(da), 0, NULL, NULL))
+#define da_count(da)                             ((int) (size_t) __da_do(2, &(da), 0, NULL, NULL))
+#define da_add(da, item)                         ((void) __da_do(3, &(da), 0, (void *) &(item), NULL))
+#define da_rem(da, index)                        ((void) __da_do(4, &(da), (int) index, NULL, NULL))
+#define da_rem_all(da)                           ((void) __da_do(4, &(da), -1, NULL, NULL))
+#define da_get(da, type, index)                (*((type *) __da_do(5, &(da), (int) index, NULL, NULL)))
+#define da_getp(da, type, index)                 ((type *) __da_do(5, &(da), (int) index, NULL, NULL))
+#define da_set(da, item, index)                  ((void) __da_do(6, &(da), (int) index, (void *) &(item), NULL))
+#define da_find(da, item)                        ((int) (size_t) __da_do(7, &(da), 0, (void *) &(item), NULL))
+#define da_find_eq(da, item, eq)                 ((int) (size_t) __da_do(7, &(da), 0, (void *) &(item), (void *) eq))
+#define da_cast(type, item)                    (*((type *) (item)))
+#define da_add_inplace(da, type, item)           { type __inplace = item; da_add(da, __inplace); }
+#define da_set_inplace(da, type, item, index)    { type __inplace = item; da_set(da, __inplace, index); }
+
+//
+// Main
+//
+
+bool dynos_warp_to_level(int level, int act);
+bool dynos_restart_level();
+bool dynos_exit_level(int delay);
+bool dynos_warp_to_castle(int level);
+bool dynos_return_to_main_menu();
+void dynos_add_routine(ubyte type, DynosRoutine routine, void *data);
+int  dynos_is_level_exit();
+void dynos_update_gfx();
+
+//
+// Opt
+//
+
+int dynos_opt_get_value(const char *name);
+void dynos_opt_set_value(const char *name, int value);
+void dynos_opt_add_action(const char *funcname, bool (*funcptr)(const char *), bool overwrite);
+
+//
+// Conversion
+//
+
+ubyte *rgba16_to_rgba32(const ubyte *data, size_t length);
+ubyte *rgba32_to_rgba32(const ubyte *data, size_t length);
+ubyte *ia4_to_rgba32(const ubyte *data, size_t length);
+ubyte *ia8_to_rgba32(const ubyte *data, size_t length);
+ubyte *ia16_to_rgba32(const ubyte *data, size_t length);
+ubyte *ci4_to_rgba32(const ubyte *data, size_t length, const ubyte *palette);
+ubyte *ci8_to_rgba32(const ubyte *data, size_t length, const ubyte *palette);
+ubyte *i4_to_rgba32(const ubyte *data, size_t length);
+ubyte *i8_to_rgba32(const ubyte *data, size_t length);
+ubyte *convert_to_rgba32(const ubyte *data, size_t length, int format, int size, const ubyte *palette);
+
+//
+// Gfx
+//
+
+bool dynos_gfx_is_loaded_texture_pointer(void *ptr);
+bool dynos_gfx_is_texture_pointer(void *ptr);
+ubyte *dynos_gfx_get_texture_data(void *ptr, int *width, int *height);
+void *dynos_gfx_get_texture(const char *texname);
+void *dynos_gfx_load_texture_raw(const ubyte *rgba32buffer, int width, int height, const char *texname);
+void *dynos_gfx_load_texture_png(const ubyte *pngdata, uint pnglength, const char *texname);
+void *dynos_gfx_load_texture_file(const char *filename, const char *texname);
+void dynos_gfx_bind_texture(void *node, void *bind);
+void dynos_gfx_unload_texture(void *node);
+int  dynos_gfx_import_texture(void **output, void *ptr, int tile, void *grapi, void **hashmap, void *pool, int *poolpos, int poolsize);
+void dynos_gfx_update_animation(void *ptr);
+
+//
+// Audio
+//
+
+void dynos_audio_mix(ubyte *output, const ubyte *input, int length, float volume, float distance);
+bool dynos_music_load_raw(const char *name, const ubyte *data, int length, int loop, float volume);
+bool dynos_music_load_wav(const char *name, const char *filename, int loop, float volume);
+void dynos_music_play(const char *name);
+void dynos_music_stop();
+void dynos_music_pause();
+void dynos_music_resume();
+bool dynos_music_is_playing(const char *name);
+bool dynos_sound_load_raw(const char *name, const ubyte *data, int length, float volume, ubyte priority);
+bool dynos_sound_load_wav(const char *name, const char *filename, float volume, ubyte priority);
+void dynos_sound_play(const char *name, float *pos);
+void dynos_sound_stop();
+bool dynos_sound_is_playing(const char *name);
+
+//
+// String
+//
+
+ubyte *dynos_string_convert(const char *str, bool heap);
+ubyte *dynos_string_decapitalize(ubyte *str64);
+int dynos_string_length(const ubyte *str64);
+int dynos_string_cwidth(ubyte c64);
+int dynos_string_width(const ubyte *str64);
+
+//
+// Geo
+//
+
+int dynos_geo_get_actor_count();
+const char *dynos_geo_get_actor_name(int index);
+void *dynos_geo_get_actor_layout(int index);
+int dynos_geo_get_actor_index(const void *geolayout);
+void *dynos_geo_get_function_pointer_from_name(const char *name);
+void *dynos_geo_get_function_pointer_from_index(int index);
+int dynos_geo_get_function_index(const void *ptr);
+void *dynos_geo_get_graph_node(const void *geolayout, bool keepInMemory);
+void *dynos_geo_spawn_object(const void *geolayout, void *parent, const void *behavior);
+
+//
+// Levels
+//
+
+int dynos_level_get_count(bool noCastle);
+int *dynos_level_get_list(bool noCastle, bool ordered);
+int dynos_level_get_course(int level);
+void *dynos_level_get_script(int level);
+ubyte *dynos_level_get_name(int level, bool decaps, bool addCourseNum);
+ubyte *dynos_level_get_act_name(int level, int act, bool decaps, bool addStarNum);
+
+#endif
+#endif
diff --git a/data/dynos.cpp.h b/data/dynos.cpp.h
new file mode 100644
index 0000000..40c3d96
--- /dev/null
+++ b/data/dynos.cpp.h
@@ -0,0 +1,755 @@
+#ifndef DYNOS_CPP_H
+#define DYNOS_CPP_H
+#ifdef __cplusplus
+
+#include "dynos.h"
+
+#define FUNCTION_CODE       (uint) 0x434E5546
+#define POINTER_CODE        (uint) 0x52544E50
+#define METAL_BITS          (G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR)
+#define GFX_DYN_CMD_ID      "GFXDYNCMD_"
+
+// The action signature is "bool (*) (const char *)"
+// The input is the button internal name (not label)
+// The output is the result of the action
+#define DYNOS_DEFINE_ACTION(func) \
+__attribute__((constructor)) \
+static void DynOS_Opt_AddAction_##func() { \
+    DynOS_Opt_AddAction(#func, func, false); \
+}
+
+//
+// Enums
+//
+
+enum {
+    DATA_TYPE_NONE = 0,
+    DATA_TYPE_LIGHT,
+    DATA_TYPE_TEXTURE,
+    DATA_TYPE_VERTEX,
+    DATA_TYPE_DISPLAY_LIST,
+    DATA_TYPE_GEO_LAYOUT,
+    DATA_TYPE_ANIMATION_VALUE,
+    DATA_TYPE_ANIMATION_INDEX,
+    DATA_TYPE_ANIMATION,
+    DATA_TYPE_ANIMATION_TABLE,
+    DATA_TYPE_GFXDYNCMD,
+    DATA_TYPE_UNUSED,
+};
+
+enum {
+    GFXDYNCMD_NONE = 0,
+    GFXDYNCMD_CAPPY_EYES,
+};
+
+enum {
+    DOPT_NONE = 0,
+
+    DOPT_TOGGLE,
+    DOPT_CHOICE,
+    DOPT_SCROLL,
+    DOPT_BIND,
+    DOPT_BUTTON,
+    DOPT_SUBMENU,
+
+    // These ones are used by the Warp to Level built-in submenu
+    DOPT_CHOICELEVEL,
+    DOPT_CHOICESTAR,
+};
+
+
+//
+// DynOS Array
+// A Array-like array, implemented to be processed really fast, but cannot handle C++ complex classes like std::string
+//
+
+template <typename T>
+class Array {
+public:
+    inline Array() : mBuffer(NULL), mCount(0), mCapacity(0) {
+    }
+
+    inline Array(const std::initializer_list<T> &aList) : mBuffer(NULL), mCount(0), mCapacity(0) {
+        Resize(aList.size());
+        memcpy(mBuffer, aList.begin(), mCount * sizeof(T));
+    }
+
+    inline Array(const T *aBegin, const T *aEnd) : mBuffer(NULL), mCount(0), mCapacity(0) {
+        Resize(aEnd - aBegin);
+        memcpy(mBuffer, aBegin, mCount * sizeof(T));
+    }
+
+    inline Array(const Array &aOther) : mBuffer(NULL), mCount(0), mCapacity(0) {
+        Resize(aOther.mCount);
+        memcpy(mBuffer, aOther.mBuffer, mCount * sizeof(T));
+    }
+
+    inline void operator=(const Array &aOther) {
+        Resize(aOther.mCount);
+        memcpy(mBuffer, aOther.mBuffer, mCount * sizeof(T));
+    }
+
+    inline ~Array() {
+        Clear();
+    }
+
+public:
+    void Resize(int aCount) {
+        if (aCount > mCapacity) {
+            mCapacity = MAX(aCount, MAX(16, mCapacity * 2));
+            T *_Buffer = (T *) calloc(mCapacity, sizeof(T));
+            if (mBuffer) {
+                memcpy(_Buffer, mBuffer, mCount * sizeof(T));
+                free(mBuffer);
+            }
+            mBuffer = _Buffer;
+        }
+        mCount = aCount;
+    }
+
+    void Add(const T& aItem) {
+        Resize(mCount + 1);
+        mBuffer[mCount - 1] = aItem;
+    }
+
+    void Remove(int aIndex) {
+        memmove(mBuffer + aIndex, mBuffer + aIndex + 1, (mCount - aIndex - 1) * sizeof(T));
+        mCount--;
+    }
+
+    void Pop() {
+        mCount--;
+    }
+
+    void RemoveAll() {
+        mCount = 0;
+    }
+
+    void Clear() {
+        if (mBuffer) free(mBuffer);
+        mBuffer   = NULL;
+        mCount    = 0;
+        mCapacity = 0;
+    }
+
+    int Find(const T& aItem) const {
+        for (int i = 0; i != mCount; ++i) {
+            if (mBuffer[i] == aItem) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    template <typename Predicate>
+    int FindIf(Predicate aPredicate) const {
+        for (int i = 0; i != mCount; ++i) {
+            if (aPredicate(mBuffer[i])) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+public:
+    inline const T *begin() const { return mBuffer; }
+    inline const T *end() const { return mBuffer + mCount; }
+    inline T *begin() { return mBuffer; }
+    inline T *end() { return mBuffer + mCount; }
+
+    inline const T &operator[](int aIndex) const { return mBuffer[aIndex]; }
+    inline T &operator[](int aIndex) { return mBuffer[aIndex]; }
+
+    inline int Count() const { return mCount; }
+    inline bool Empty() const { return mCount == 0; }
+
+public:
+    void Read(FILE *aFile) {
+        int _Length = 0; fread(&_Length, sizeof(int), 1, aFile);
+        Resize(_Length);
+        fread(mBuffer, sizeof(T), _Length, aFile);
+    }
+
+    void Write(FILE *aFile) const {
+        fwrite(&mCount, sizeof(int), 1, aFile);
+        fwrite(mBuffer, sizeof(T), mCount, aFile);
+    }
+
+private:
+    T *mBuffer;
+    int mCount;
+    int mCapacity;
+};
+
+//
+// DynOS String
+// A fixed-size string that doesn't require heap memory allocation
+//
+
+#define STRING_SIZE 95
+class String {
+public:
+    inline String() : mCount(0) {
+        mBuffer[0] = 0;
+    }
+
+    inline String(const char *aString) : mCount(0) {
+        if (aString) {
+            size_t _Length = strlen(aString);
+            mCount = MIN(_Length, STRING_SIZE - 1);
+            memcpy(mBuffer, aString, _Length);
+        }
+        mBuffer[mCount] = 0;
+    }
+
+    template <typename... Args>
+    inline String(const char *aFmt, Args... aArgs) : mCount(0) {
+        snprintf(mBuffer, STRING_SIZE, aFmt, aArgs...);
+        mCount = (ubyte) strlen(mBuffer);
+        mBuffer[mCount] = 0;
+    }
+
+    inline String(const String &aOther) : mCount(0) {
+        mCount = aOther.mCount;
+        memcpy(mBuffer, aOther.mBuffer, mCount);
+        mBuffer[mCount] = 0;
+    }
+
+    inline void operator=(const String &aOther) {
+        mCount = aOther.mCount;
+        memcpy(mBuffer, aOther.mBuffer, mCount);
+        mBuffer[mCount] = 0;
+    }
+
+public:
+    void Add(char aChar) {
+        if (mCount == STRING_SIZE - 1) return;
+        mBuffer[mCount++] = aChar;
+        mBuffer[mCount] = 0;
+    }
+
+    void Remove(int aIndex) {
+        memmove(mBuffer + aIndex, mBuffer + aIndex + 1, (mCount-- - aIndex - 1));
+        mBuffer[mCount] = 0;
+    }
+
+    void RemoveAll() {
+        mCount = 0;
+        mBuffer[0] = 0;
+    }
+
+    void Clear() {
+        mCount = 0;
+        mBuffer[0] = 0;
+    }
+
+    int Find(char aChar, int aStart = 0) const {
+        for (ubyte i = (ubyte) aStart; i < mCount; ++i) {
+            if (mBuffer[i] == aChar) {
+                return (int) i;
+            }
+        }
+        return -1;
+    }
+
+    int Find(const char *aString, int aStart = 0) const {
+        const char *_Ptr = strstr(mBuffer + aStart, aString);
+        if (_Ptr) return (int) (_Ptr - mBuffer);
+        return -1;
+    }
+
+    int FindLast(char aChar) const {
+        for (ubyte i = mCount; i != 0; --i) {
+            if (mBuffer[i - 1] == aChar) {
+                return (int) (i - 1);
+            }
+        }
+        return -1;
+    }
+
+    String SubString(int aStart, int aCount = STRING_SIZE - 1) const {
+        if (aStart >= mCount) return String();
+        if (aCount < 0) aCount = STRING_SIZE - 1;
+        aCount = MIN(aCount, mCount - aStart);
+        String _String;
+        _String.mCount = aCount;
+        memcpy(_String.mBuffer, mBuffer + aStart, aCount);
+        _String.mBuffer[aCount] = 0;
+        return _String;
+    }
+
+public:
+    inline const char *begin() const { return mBuffer; }
+    inline const char *end() const { return mBuffer + mCount; }
+    inline char *begin() { return mBuffer; }
+    inline char *end() { return mBuffer + mCount; }
+
+    inline const char &operator[](int aIndex) const { return mBuffer[aIndex]; }
+    inline char &operator[](int aIndex) { return mBuffer[aIndex]; }
+
+    inline int Length() const { return (int) mCount; }
+    inline bool Empty() const { return mCount == 0; }
+
+public:
+    bool operator==(const char *aString) const {
+        if (strlen(aString) != mCount) return false;
+        for (ubyte i = 0; i != mCount; ++i) {
+            if (aString[i] != mBuffer[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    bool operator==(const String &aOther) const {
+        if (aOther.mCount != mCount) return false;
+        for (ubyte i = 0; i != mCount; ++i) {
+            if (aOther.mBuffer[i] != mBuffer[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    bool operator!=(const char *aString) const {
+        if (strlen(aString) != mCount) return true;
+        for (ubyte i = 0; i != mCount; ++i) {
+            if (aString[i] != mBuffer[i]) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    bool operator!=(const String &aOther) const {
+        if (aOther.mCount != mCount) return true;
+        for (ubyte i = 0; i != mCount; ++i) {
+            if (aOther.mBuffer[i] != mBuffer[i]) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+public:
+    void Read(FILE *aFile) {
+        fread(&mCount, sizeof(ubyte), 1, aFile);
+        fread(mBuffer, sizeof(char), mCount, aFile);
+        mBuffer[mCount] = 0;
+    }
+
+    void Write(FILE *aFile) const {
+        fwrite(&mCount, sizeof(ubyte), 1, aFile);
+        fwrite(mBuffer, sizeof(char), mCount, aFile);
+    }
+
+    int ParseInt() const {
+        int i = 0;
+        if (mBuffer[1] == 'x') {
+            sscanf(mBuffer + 2, "%x", &i);
+        } else {
+            sscanf(mBuffer, "%d", &i);
+        }
+        return i;
+    }
+
+    float ParseFloat() const {
+        float f = 0.f;
+        sscanf(mBuffer, "%f", &f);
+        return f;
+    }
+
+private:
+    char mBuffer[STRING_SIZE];
+    ubyte mCount;
+};
+static_assert(sizeof(String) == (STRING_SIZE + 1), "sizeof(String) must be (STRING_SIZE + 1)");
+
+//
+// Types
+//
+
+template <typename U, typename V>
+using Pair = std::pair<U, V>;
+
+typedef std::string SysPath;
+
+class NoCopy {
+  protected:
+    NoCopy() {}
+    ~NoCopy() {}
+  private:
+    NoCopy(const NoCopy &) = delete;
+    void operator=(const NoCopy &) = delete;
+};
+
+struct TexData : NoCopy {
+    Array<ubyte> mPngData;
+    Array<ubyte> mRawData;
+    int mRawWidth  = -1;
+    int mRawHeight = -1;
+    int mRawFormat = -1;
+    int mRawSize   = -1;
+    bool mUploaded = false;
+    void *mBind    = NULL;
+};
+
+struct AnimData : NoCopy {
+    short mFlags = 0;
+    short mUnk02 = 0;
+    short mUnk04 = 0;
+    short mUnk06 = 0;
+    short mUnk08 = 0;
+    Pair<String, short> mUnk0A;
+    Pair<String, Array<short>> mValues;
+    Pair<String, Array<ushort>> mIndex;
+    uint mLength = 0;
+};
+
+template <typename T>
+struct DataNode : NoCopy {
+    String mName;
+    T* mData = NULL;
+    uint mSize = 0;
+    Array<String> mTokens;
+    size_t mModelIdentifier = 0;
+    size_t mLoadIndex = 0;
+};
+template <typename T>
+using DataNodes = Array<DataNode<T>*>;
+
+struct GfxDynCmd {
+    Gfx* mData = NULL;
+    uint mOffset = 0;
+    ubyte mType = 0;
+};
+
+struct GfxContext {
+    DataNode<TexData>* mCurrentTexture = NULL;
+    DataNode<TexData>* mCurrentPalette = NULL;
+    Gfx mMetalBits    = { 0, 0 };
+    Gfx mCombineMode  = { 0, 0 };
+    Gfx mSpTexture    = { 0, 0 };
+    Gfx mTxLoadTile   = { 0, 0 };
+    Gfx mTxRenderTile = { 0, 0 };
+    Gfx mSetTileSize  = { 0, 0 };
+};
+
+template <typename T>
+using AnimBuffer = Pair<String, Array<T>>;
+struct GfxData : NoCopy {
+
+    // Model data
+    DataNodes<Lights1> mLights;
+    DataNodes<TexData> mTextures;
+    DataNodes<Vtx> mVertices;
+    DataNodes<Gfx> mDisplayLists;
+    DataNodes<GeoLayout> mGeoLayouts;
+    Array<GfxDynCmd> mGfxDynCmds;
+
+    // Animation data
+    Array<AnimBuffer<short> *> mAnimValues;
+    Array<AnimBuffer<ushort> *> mAnimIndices;
+    DataNodes<AnimData> mAnimations;
+    Array<Pair<String, void *>> mAnimationTable;
+
+    // Current
+    size_t mLoadIndex = 0;
+    int mErrorCount = 0;
+    uint mModelIdentifier = 0;
+    SysPath mPackFolder;
+    Array<void *> mPointerList;
+    GfxContext mGfxContext;
+    Array<GfxContext> mGeoNodeStack;
+};
+
+struct ActorGfx {
+    GfxData *mGfxData = NULL;
+    GraphNode *mGraphNode = NULL;
+    int mPackIndex = 0;
+};
+
+typedef Pair<String, const ubyte *> Label;
+struct DynosOption : NoCopy {
+    String mName;
+    String mConfigName; // Name used in sm64config.txt
+    Label mLabel;
+    Label mTitle; // Full caps label, displayed with colored font
+    DynosOption *mPrev;
+    DynosOption *mNext;
+    DynosOption *mParent;
+    bool mDynos; // true from create, false from convert
+    ubyte mType;
+
+    // TOGGLE
+    struct Toggle : NoCopy {
+        bool *mTog;
+    } mToggle;
+
+    // CHOICE
+    struct Choice : NoCopy {
+        Array<Label> mChoices;
+        int *mIndex;
+    } mChoice;
+
+    // SCROLL
+    struct Scroll : NoCopy {
+        int mMin;
+        int mMax;
+        int mStep;
+        int *mValue;
+    } mScroll;
+
+    // BIND
+    struct Bind : NoCopy {
+        uint mMask;
+        uint *mBinds;
+        int mIndex;
+    } mBind;
+
+    // BUTTON
+    struct Button : NoCopy {
+        String mFuncName;
+    } mButton;
+
+    // SUBMENU
+    struct Submenu : NoCopy {
+        DynosOption *mChild;
+        bool mEmpty;
+    } mSubMenu;
+};
+typedef bool (*DynosLoopFunc)(DynosOption *, void *);
+
+//
+// Utils
+//
+
+template <typename T>
+T* New(size_t aCount = 1llu) {
+    T *_Ptr = (T *) calloc(aCount, sizeof(T));
+    for (size_t i = 0; i != aCount; ++i) {
+        new (_Ptr + i) T(); // Calls the constructor or type T at address (_Ptr + i)
+    }
+    return _Ptr;
+}
+
+template <typename T>
+void Delete(T *& aPtr) {
+    if (aPtr) aPtr->~T();
+    free(aPtr);
+    aPtr = NULL;
+}
+
+template <typename T>
+T *CopyBytes(const T *aPtr, size_t aSize) {
+    T *_Ptr = (T *) calloc(1, aSize);
+    memcpy(_Ptr, aPtr, aSize);
+    return _Ptr;
+}
+
+template <typename T = void>
+Array<String> Split(const char *aBuffer, const String &aDelimiters, const String &aEndCharacters = {}, bool aHandleDoubleQuotedStrings = false) {
+    Array<String> _Tokens;
+    String _Token;
+    bool _TreatSpaceAsChar = false;
+    size_t _Length = strlen(aBuffer);
+    for (size_t i = 0; i <= _Length; ++i) {
+        if (i == _Length || aDelimiters.Find(aBuffer[i]) != -1) {
+            if (aBuffer[i] == ' ' && _TreatSpaceAsChar) {
+                _Token.Add(aBuffer[i]);
+            } else {
+                if (!_Token.Empty()) {
+                    _Tokens.Add(_Token);
+                    _Token.Clear();
+                }
+                if (aEndCharacters.Find(aBuffer[i]) != -1) {
+                    break;
+                }
+            }
+        } else {
+            if (aBuffer[i] == '\"' && aHandleDoubleQuotedStrings) {
+                _TreatSpaceAsChar = !_TreatSpaceAsChar;
+            } else {
+                _Token.Add(aBuffer[i]);
+            }
+        }
+    }
+    return _Tokens;
+}
+
+template <typename T>
+T ReadBytes(FILE* aFile) {
+    T _Item = { 0 };
+    fread(&_Item, sizeof(T), 1, aFile);
+    return _Item;
+}
+
+template <typename T>
+void WriteBytes(FILE* aFile, const T& aItem) {
+    fwrite(&aItem, sizeof(T), 1, aFile);
+}
+
+template <typename... Args>
+void PrintNoNewLine(const char *aFmt, Args... aArgs) {
+    printf(aFmt, aArgs...);
+    fflush(stdout);
+}
+
+template <typename... Args>
+void Print(const char *aFmt, Args... aArgs) {
+    printf(aFmt, aArgs...);
+    printf("\r\n");
+    fflush(stdout);
+}
+
+#define PrintError(...) { \
+    if (aGfxData->mErrorCount == 0) Print("  ERROR!"); \
+    Print(__VA_ARGS__); \
+    aGfxData->mErrorCount++; \
+}
+
+template <typename... Args>
+SysPath fstring(const char *aFmt, Args... aArgs) {
+    char buffer[1024];
+    snprintf(buffer, 1024, aFmt, aArgs...);
+    return SysPath(buffer);
+}
+
+//
+// Main
+//
+
+bool DynOS_WarpToLevel     (int aLevel, int aAct);
+bool DynOS_RestartLevel    ();
+bool DynOS_ExitLevel       (int aDelay);
+bool DynOS_WarpToCastle    (int aLevel);
+bool DynOS_ReturnToMainMenu();
+void DynOS_AddRoutine      (ubyte aType, DynosRoutine aRoutine, void *aData);
+bool DynOS_IsLevelExit     ();
+
+void DynOS_Init            ();
+void DynOS_UpdateOpt       (void *aPad);
+void DynOS_UpdateGfx       ();
+
+//
+// Opt
+//
+
+int  DynOS_Opt_GetValue                (const String &aName);
+void DynOS_Opt_SetValue                (const String &aName, int aValue);
+void DynOS_Opt_AddAction               (const String &aFuncName, bool (*aFuncPtr)(const char *), bool aOverwrite);
+
+void DynOS_Opt_Init                    ();
+void DynOS_Opt_InitVanilla             (DynosOption *&aOptionsMenu);
+void DynOS_Opt_Update                  (OSContPad *aPad);
+
+bool DynOS_Opt_ControllerUpdate        (DynosOption *aOpt, void *aData);
+int  DynOS_Opt_ControllerGetKeyPressed ();
+
+void DynOS_Opt_LoadConfig              (DynosOption *aMenu);
+void DynOS_Opt_SaveConfig              (DynosOption *aMenu);
+
+void DynOS_Opt_DrawMenu                (DynosOption *aCurrentOption, DynosOption *aCurrentMenu, DynosOption *aOptionsMenu, DynosOption *aDynosMenu);
+void DynOS_Opt_DrawPrompt              (DynosOption *aCurrentMenu, DynosOption *aOptionsMenu, DynosOption *aDynosMenu);
+
+//
+// Conversion
+//
+
+ubyte *RGBA16_RGBA32  (const ubyte *aData, size_t aLength);
+ubyte *RGBA32_RGBA32  (const ubyte *aData, size_t aLength);
+ubyte *IA4_RGBA32     (const ubyte *aData, size_t aLength);
+ubyte *IA8_RGBA32     (const ubyte *aData, size_t aLength);
+ubyte *IA16_RGBA32    (const ubyte *aData, size_t aLength);
+ubyte *CI4_RGBA32     (const ubyte *aData, size_t aLength, const ubyte *aPalette);
+ubyte *CI8_RGBA32     (const ubyte *aData, size_t aLength, const ubyte *aPalette);
+ubyte *I4_RGBA32      (const ubyte *aData, size_t aLength);
+ubyte *I8_RGBA32      (const ubyte *aData, size_t aLength);
+ubyte *ConvertToRGBA32(const ubyte *aData, size_t aLength, int aFormat, int aSize, const ubyte *aPalette);
+
+//
+// Gfx
+//
+
+bool               DynOS_Gfx_IsLoadedTexturePointer (void *aPtr);
+bool               DynOS_Gfx_IsTexturePointer       (void *aPtr);
+DataNode<TexData> *DynOS_Gfx_GetTexture             (const String &aTextureName);
+DataNode<TexData> *DynOS_Gfx_LoadTextureRAW         (const ubyte *aRGBA32Buffer, int aWidth, int aHeight, const String &aTextureName);
+DataNode<TexData> *DynOS_Gfx_LoadTexturePNG         (const ubyte *aPngData, uint aPngLength, const String &aTextureName);
+DataNode<TexData> *DynOS_Gfx_LoadTextureFile        (const SysPath &aFilename, const String &aTextureName);
+void               DynOS_Gfx_BindTexture            (DataNode<TexData> *aNode, void *aBind);
+void               DynOS_Gfx_UnloadTexture          (DataNode<TexData> *aNode);
+bool               DynOS_Gfx_ImportTexture          (void **aOutput, void *aPtr, int aTile, void *aGfxRApi, void **aHashMap, void *aPool, uint *aPoolPos, uint aPoolSize);
+
+Array<ActorGfx>   &DynOS_Gfx_GetActorList           ();
+Array<SysPath>    &DynOS_Gfx_GetPackList            ();
+Array<String>      DynOS_Gfx_Init                   ();
+void               DynOS_Gfx_Update                 ();
+void               DynOS_Gfx_UpdateAnimation        (void *aPtr);
+
+bool               DynOS_Gfx_IsCappyEyesDisplayList (GfxData *aGfxData, const String &aNodeName);
+void               DynOS_Gfx_PushDynCmd             (GfxData *aGfxData, DataNode<Gfx> *aNode, Gfx *&aHead, ubyte aCmd);
+bool               DynOS_Gfx_WriteBinary            (const SysPath &aOutputFilename, GfxData *aGfxData);
+GfxData           *DynOS_Gfx_LoadFromBinary         (const SysPath &aFilename);
+void               DynOS_Gfx_Free                   (GfxData *aGfxData);
+void               DynOS_Gfx_GeneratePack           (const SysPath &aPackFolder);
+
+//
+// Audio
+//
+
+void DynOS_Audio_Mix       (ubyte *aOutput, const ubyte *aInput, int aLength, float aVolume, float aDistance);
+
+bool DynOS_Music_LoadRAW   (const String &aName, const ubyte *aData, int aLength, int aLoop, float aVolume);
+bool DynOS_Music_LoadWAV   (const String &aName, const SysPath &aFilename, int aLoop, float aVolume);
+void DynOS_Music_Play      (const String &aName);
+void DynOS_Music_Stop      ();
+void DynOS_Music_Pause     ();
+void DynOS_Music_Resume    ();
+bool DynOS_Music_IsPlaying (const String &aName);
+
+bool DynOS_Sound_LoadRAW   (const String &aName, const ubyte *aData, int aLength, float aVolume, ubyte aPriority);
+bool DynOS_Sound_LoadWAV   (const String &aName, const SysPath &aFilename, float aVolume, ubyte aPriority);
+void DynOS_Sound_Play      (const String &aName, float *aPos);
+void DynOS_Sound_Stop      ();
+bool DynOS_Sound_IsPlaying (const String &aName);
+
+//
+// String
+//
+
+ubyte *DynOS_String_Convert      (const char *aString, bool aHeapAlloc);
+ubyte *DynOS_String_Decapitalize (ubyte *aStr64);
+int    DynOS_String_Length       (const ubyte *aStr64);
+int    DynOS_String_WidthChar64  (ubyte aChar64);
+int    DynOS_String_Width        (const ubyte *aStr64);
+
+//
+// Geo
+//
+
+int   DynOS_Geo_GetActorCount               ();
+const char *DynOS_Geo_GetActorName          (int aIndex);
+void *DynOS_Geo_GetActorLayout              (int aIndex);
+int   DynOS_Geo_GetActorIndex               (const void *aGeoLayout);
+
+void *DynOS_Geo_GetFunctionPointerFromName  (const String &aName);
+void *DynOS_Geo_GetFunctionPointerFromIndex (int aIndex);
+int   DynOS_Geo_GetFunctionIndex            (const void *aPtr);
+
+void *DynOS_Geo_GetGraphNode                (const void *aGeoLayout, bool aKeepInMemory);
+void *DynOS_Geo_SpawnObject                 (const void *aGeoLayout, void *aParent, const void *aBehavior);
+
+//
+// Levels
+//
+
+int    DynOS_Level_GetCount   (bool aNoCastle);
+int   *DynOS_Level_GetList    (bool aNoCastle, bool aOrdered);
+int    DynOS_Level_GetCourse  (int aLevel);
+void  *DynOS_Level_GetScript  (int aLevel);
+ubyte *DynOS_Level_GetName    (int aLevel, bool aDecaps, bool aAddCourseNumber);
+ubyte *DynOS_Level_GetActName (int aLevel, int aAct, bool aDecaps, bool aAddStarNumber);
+
+#endif
+#endif
diff --git a/data/dynos.h b/data/dynos.h
new file mode 100644
index 0000000..9da4886
--- /dev/null
+++ b/data/dynos.h
@@ -0,0 +1,66 @@
+#ifndef DYNOS_H
+#define DYNOS_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <math.h>
+#include <limits.h>
+#include <dirent.h>
+#include <SDL2/SDL.h>
+#ifdef __cplusplus
+#include <new>
+#include <utility>
+#include <string>
+extern "C" {
+#endif
+#include "types.h"
+#include "config.h"
+#include "model_ids.h"
+#include "engine/math_util.h"
+#include "pc/configfile.h"
+#include "pc/fs/fs.h"
+#undef STB_IMAGE_IMPLEMENTATION
+#include "stb/stb_image.h"
+#ifdef __cplusplus
+}
+#endif
+
+#define DYNOS_FOLDER            "dynos"
+#define DYNOS_PACKS_FOLDER      DYNOS_FOLDER "/packs"
+#define DYNOS_CONFIG_FILENAME   "DynOSconfig.cfg"
+
+//
+// Enums
+//
+
+enum {
+    DYNOS_ROUTINE_OPT_UPDATE,  // Executed once per frame, before running the level script
+    DYNOS_ROUTINE_GFX_UPDATE,  // Executed once per frame, before rendering the scene
+    DYNOS_ROUTINE_LEVEL_START, // Executed at the start of a level
+};
+
+//
+// Types
+//
+
+typedef   signed char      byte;
+typedef unsigned char      ubyte;
+typedef unsigned short     ushort;
+typedef unsigned int       uint;
+typedef   signed long long slong;
+// typedef unsigned long long ulong;
+typedef void (*DynosRoutine)(void *);
+
+//
+// Render96
+//
+
+#if defined(MODEL_PLAYER) && defined(MODEL_LUIGIS_CAP) && defined(MODEL_LUIGIS_METAL_CAP) && defined(MODEL_LUIGIS_WING_CAP) && defined(MODEL_LUIGIS_WINGED_METAL_CAP)
+#define RENDER_96
+#endif
+
+#endif
\ No newline at end of file
diff --git a/data/dynos_audio.cpp b/data/dynos_audio.cpp
new file mode 100644
index 0000000..28ec4a6
--- /dev/null
+++ b/data/dynos_audio.cpp
@@ -0,0 +1,306 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "game/area.h"
+}
+
+#define AUDIO_BUFFER_SIZE	0x200
+#define AUDIO_FREQUENCY		32000
+#define AUDIO_FORMAT		AUDIO_S16SYS
+#define MUSIC_CHANNELS		2
+#define SOUND_CHANNELS		1
+#define MUSIC_NO_LOOP		(-1)
+
+//
+// Audio
+//
+
+// Volume ranges from 0 to 1
+// As lower bytes are treated as signed, this gives a 1/256 margin error
+// on the mixed sample, but it's faster than treating endianess
+extern ushort D_80332028[];
+void DynOS_Audio_Mix(ubyte *aOutput, const ubyte *aInput, int aLength, float aVolume, float aDistance) {
+    float _MixVolume = aVolume * (aDistance == 0.f ? 1.f : sqr(1.f - MIN(1.f, absx(aDistance) / D_80332028[gCurrLevelNum])));
+    for (int i = 0; i != aLength; ++i) {
+        aOutput[i] = (ubyte)((byte)((float) ((byte)(aInput[i])) * _MixVolume));
+    }
+}
+
+//
+// Music
+//
+
+struct MusicData {
+    String mName;
+    ubyte *mData;
+    int    mLength;
+    int    mLoop;
+    int    mCurrent;
+    float  mVolume;
+};
+static Array<MusicData *> sLoadedMusics;
+static MusicData *sPlayingMusic = NULL;
+
+static void DynOS_Music_Callback(UNUSED void *, ubyte *aStream, int aLength) {
+    bzero(aStream, aLength);
+    if (sPlayingMusic == NULL) {
+        return;
+    }
+
+    float _Volume = sPlayingMusic->mVolume * (configMasterVolume / 127.f) * (configMusicVolume / 127.f);
+    int _LenTilEnd = sPlayingMusic->mLength - sPlayingMusic->mCurrent;
+    if (_LenTilEnd < aLength) {
+        DynOS_Audio_Mix(aStream, sPlayingMusic->mData + sPlayingMusic->mCurrent, _LenTilEnd, _Volume, 0);
+        if (sPlayingMusic->mLoop != MUSIC_NO_LOOP) {
+            DynOS_Audio_Mix(aStream + _LenTilEnd, sPlayingMusic->mData + sPlayingMusic->mLoop, aLength - _LenTilEnd, _Volume, 0);
+            sPlayingMusic->mCurrent = sPlayingMusic->mLoop + (aLength - _LenTilEnd);
+        } else {
+            sPlayingMusic = NULL;
+        }
+    } else {
+        DynOS_Audio_Mix(aStream, sPlayingMusic->mData + sPlayingMusic->mCurrent, aLength, _Volume, 0);
+        sPlayingMusic->mCurrent += aLength;
+    }
+}
+
+static SDL_AudioDeviceID DynOS_Music_GetDevice() {
+    static SDL_AudioDeviceID sMusicDeviceId = 0;
+    if (sMusicDeviceId) {
+        return sMusicDeviceId;
+    }
+
+    // Init SDL2 Audio
+    if (!SDL_WasInit(SDL_INIT_AUDIO)) {
+        if (SDL_InitSubSystem(SDL_INIT_AUDIO) != 0) {
+            sys_fatal("DynOS_Music_GetDevice: Could not init SDL Audio.");
+        }
+    }
+
+    // Open music device
+    SDL_AudioSpec _Want, _Have;
+    _Want.freq     = AUDIO_FREQUENCY;
+    _Want.format   = AUDIO_FORMAT;
+    _Want.channels = MUSIC_CHANNELS;
+    _Want.samples  = AUDIO_BUFFER_SIZE;
+    _Want.callback = DynOS_Music_Callback;
+    _Want.userdata = NULL;
+    sMusicDeviceId = SDL_OpenAudioDevice(NULL, 0, &_Want, &_Have, 0);
+    if (sMusicDeviceId == 0) {
+        sys_fatal("DynOS_Music_GetDevice: Could not open music device.");
+    }
+    SDL_PauseAudioDevice(sMusicDeviceId, 0);
+    return sMusicDeviceId;
+}
+
+bool DynOS_Music_LoadRAW(const String &aName, const ubyte *aData, int aLength, int aLoop, float aVolume) {
+    if (sLoadedMusics.FindIf([&aName](const MusicData *aMusicData) { return aMusicData->mName == aName; }) != -1) {
+        return false;
+    }
+
+    MusicData *_MusicData = New<MusicData>();
+    _MusicData->mName     = aName;
+    _MusicData->mData     = CopyBytes(aData, aLength * sizeof(ubyte));
+    _MusicData->mLength   = aLength;
+    _MusicData->mLoop     = aLoop * sizeof(short) * MUSIC_CHANNELS;
+    _MusicData->mCurrent  = 0;
+    _MusicData->mVolume   = aVolume;
+    sLoadedMusics.Add(_MusicData);
+    return true;
+}
+
+bool DynOS_Music_LoadWAV(const String &aName, const SysPath &aFilename, int aLoop, float aVolume) {
+    if (sLoadedMusics.FindIf([&aName](const MusicData *aMusicData) { return aMusicData->mName == aName; }) != -1) {
+        return false;
+    }
+
+    SDL_AudioSpec _Spec;
+    ubyte *_Data;
+    int _Length;
+    if (!SDL_LoadWAV(aFilename.c_str(), &_Spec, &_Data, (uint *) &_Length)) {
+        sys_fatal("DynOS_Music_LoadWAV: Unable to load file %s.", aFilename.c_str());
+        return false;
+    }
+    if (_Spec.freq != AUDIO_FREQUENCY) {
+        sys_fatal("DynOS_Music_LoadWAV: From file %s, audio frequency should be %d, is %d.", aFilename.c_str(), AUDIO_FREQUENCY, _Spec.freq);
+        return false;
+    }
+    if (_Spec.format != AUDIO_FORMAT) {
+        sys_fatal("DynOS_Music_LoadWAV: From file %s, audio format is not Signed 16-bit PCM.", aFilename.c_str());
+        return false;
+    }
+    if (_Spec.channels != MUSIC_CHANNELS) {
+        sys_fatal("DynOS_Music_LoadWAV: From file %s, audio channel count should be %d, is %d.", aFilename.c_str(), MUSIC_CHANNELS, _Spec.channels);
+        return false;
+    }
+
+    MusicData *_MusicData = New<MusicData>();
+    _MusicData->mName     = aName;
+    _MusicData->mData     = _Data;
+    _MusicData->mLength   = _Length;
+    _MusicData->mLoop     = aLoop * sizeof(short) * MUSIC_CHANNELS;
+    _MusicData->mCurrent  = 0;
+    _MusicData->mVolume   = aVolume;
+    sLoadedMusics.Add(_MusicData);
+    return true;
+}
+
+void DynOS_Music_Play(const String& aName) {
+    int _MusicDataIndex = sLoadedMusics.FindIf([&aName](const MusicData *aMusicData) { return aMusicData->mName == aName; });
+    if (_MusicDataIndex == -1) {
+        return;
+    }
+
+    SDL_LockAudioDevice(DynOS_Music_GetDevice());
+    sPlayingMusic = sLoadedMusics[_MusicDataIndex];
+    sPlayingMusic->mCurrent = 0;
+    SDL_UnlockAudioDevice(DynOS_Music_GetDevice());
+    SDL_PauseAudioDevice(DynOS_Music_GetDevice(), false);
+}
+
+void DynOS_Music_Stop() {
+    SDL_LockAudioDevice(DynOS_Music_GetDevice());
+    sPlayingMusic = NULL;
+    SDL_UnlockAudioDevice(DynOS_Music_GetDevice());
+    SDL_PauseAudioDevice(DynOS_Music_GetDevice(), true);
+}
+
+void DynOS_Music_Pause() {
+    SDL_PauseAudioDevice(DynOS_Music_GetDevice(), TRUE);
+}
+
+void DynOS_Music_Resume() {
+    SDL_PauseAudioDevice(DynOS_Music_GetDevice(), FALSE);
+}
+
+bool DynOS_Music_IsPlaying(const String& aName) {
+    return (sPlayingMusic != NULL) && (aName.Empty() || sPlayingMusic->mName == aName);
+}
+
+//
+// Sound
+//
+
+struct SoundData {
+    String mName;
+    ubyte *mData[2];
+    int    mLength;
+    float  mVolume;
+    ubyte  mPriority;
+};
+static Array<SoundData *> sLoadedSounds;
+static SoundData *sPlayingSound = NULL;
+
+static SDL_AudioDeviceID DynOS_Sound_GetDevice() {
+    static SDL_AudioDeviceID sSoundDeviceId = 0;
+    if (sSoundDeviceId) {
+        return sSoundDeviceId;
+    }
+
+    // Init SDL2 Audio
+    if (!SDL_WasInit(SDL_INIT_AUDIO)) {
+        if (SDL_InitSubSystem(SDL_INIT_AUDIO) != 0) {
+            sys_fatal("DynOS_Sound_GetDevice: Could not init SDL Audio.");
+        }
+    }
+
+    // Open sound device
+    SDL_AudioSpec _Want, _Have;
+    _Want.freq     = AUDIO_FREQUENCY;
+    _Want.format   = AUDIO_FORMAT;
+    _Want.channels = SOUND_CHANNELS;
+    _Want.samples  = AUDIO_BUFFER_SIZE;
+    _Want.callback = NULL;
+    _Want.userdata = NULL;
+    sSoundDeviceId = SDL_OpenAudioDevice(NULL, 0, &_Want, &_Have, 0);
+    if (sSoundDeviceId == 0) {
+        sys_fatal("DynOS_Sound_GetDevice: Could not open sound device.");
+    }
+    SDL_PauseAudioDevice(sSoundDeviceId, 0);
+    return sSoundDeviceId;
+}
+
+bool DynOS_Sound_LoadRAW(const String& aName, const ubyte *aData, int aLength, float aVolume, ubyte aPriority) {
+    if (sLoadedSounds.FindIf([&aName](const SoundData *aSoundData) { return aSoundData->mName == aName; }) != -1) {
+        return false;
+    }
+
+    SoundData *_SoundData = New<SoundData>();
+    _SoundData->mName     = aName;
+    _SoundData->mData[0]  = CopyBytes(aData, aLength * sizeof(ubyte));
+    _SoundData->mData[1]  = CopyBytes(aData, aLength * sizeof(ubyte));
+    _SoundData->mLength   = aLength;
+    _SoundData->mVolume   = aVolume;
+    _SoundData->mPriority = aPriority;
+    sLoadedSounds.Add(_SoundData);
+    return true;
+}
+
+bool DynOS_Sound_LoadWAV(const String& aName, const SysPath& aFilename, float aVolume, ubyte aPriority) {
+    if (sLoadedSounds.FindIf([&aName](const SoundData *aSoundData) { return aSoundData->mName == aName; }) != -1) {
+        return false;
+    }
+
+    SDL_AudioSpec _Spec;
+    ubyte *_Data;
+    int _Length;
+    if (!SDL_LoadWAV(aFilename.c_str(), &_Spec, &_Data, (uint *) &_Length)) {
+        sys_fatal("DynOS_Sound_LoadWAV: Unable to load file %s.", aFilename.c_str());
+        return false;
+    }
+    if (_Spec.freq != AUDIO_FREQUENCY) {
+        sys_fatal("DynOS_Sound_LoadWAV: From file %s, audio frequency should be %d, is %d.", aFilename.c_str(), AUDIO_FREQUENCY, _Spec.freq);
+        return false;
+    }
+    if (_Spec.format != AUDIO_FORMAT) {
+        sys_fatal("DynOS_Sound_LoadWAV: From file %s, audio format is not Signed 16-bit PCM.", aFilename.c_str());
+        return false;
+    }
+    if (_Spec.channels != SOUND_CHANNELS) {
+        sys_fatal("DynOS_Sound_LoadWAV: From file %s, audio channel count should be %d, is %d.", aFilename.c_str(), SOUND_CHANNELS, _Spec.channels);
+        return false;
+    }
+
+    SoundData *_SoundData = New<SoundData>();
+    _SoundData->mName     = aName;
+    _SoundData->mData[0]  = _Data;
+    _SoundData->mData[1]  = CopyBytes(_Data, _Length * sizeof(ubyte));
+    _SoundData->mLength   = _Length;
+    _SoundData->mVolume   = aVolume;
+    _SoundData->mPriority = aPriority;
+    sLoadedSounds.Add(_SoundData);
+    return true;
+}
+
+void DynOS_Sound_Play(const String& aName, float *aPos) {
+    int _SoundDataIndex = sLoadedSounds.FindIf([&aName](const SoundData *aSoundData) { return aSoundData->mName == aName; });
+    if (_SoundDataIndex == -1) {
+        return;
+    }
+
+    // Update playing sound
+    if (SDL_GetQueuedAudioSize(DynOS_Sound_GetDevice()) == 0) {
+        sPlayingSound = NULL;
+    }
+
+    // Don't overwrite playing sounds with higher aPriority
+    // Sounds with equal aPriority cancel out each other
+    SoundData *_SoundData = sLoadedSounds[_SoundDataIndex];
+    if (sPlayingSound != NULL && sPlayingSound->mPriority > _SoundData->mPriority) {
+        return;
+    }
+
+    float aVolume = _SoundData->mVolume * (configMasterVolume / 127.f) * (configSfxVolume / 127.f);
+    float aDistance = (aPos == NULL ? 0 : vec3f_length(aPos));
+    DynOS_Audio_Mix(_SoundData->mData[1], _SoundData->mData[0], _SoundData->mLength, aVolume, aDistance);
+    SDL_ClearQueuedAudio(DynOS_Sound_GetDevice());
+    SDL_QueueAudio(DynOS_Sound_GetDevice(), _SoundData->mData[1], _SoundData->mLength);
+    sPlayingSound = _SoundData;
+}
+
+void DynOS_Sound_Stop() {
+    SDL_ClearQueuedAudio(DynOS_Sound_GetDevice());
+    sPlayingSound = NULL;
+}
+
+bool DynOS_Sound_IsPlaying(const String& aName) {
+    return (SDL_GetQueuedAudioSize(DynOS_Sound_GetDevice()) != 0) && (aName.Empty() || sPlayingSound->mName == aName);
+}
diff --git a/data/dynos_c.cpp b/data/dynos_c.cpp
new file mode 100644
index 0000000..10d3146
--- /dev/null
+++ b/data/dynos_c.cpp
@@ -0,0 +1,412 @@
+#include "dynos.cpp.h"
+extern "C" {
+
+//
+// C dynamic array, vector-like struct
+//
+
+typedef struct __DynArrayHeader {
+    int size;
+    int count;
+    int capacity;
+} __DynArrayHeader;
+
+#define da                   (*dah)
+#define buffer_at(index)     ((void *) ((size_t) da + sizeof(__DynArrayHeader) + ((size_t) da->size * (size_t) (index))))
+
+void *__da_do(int func, void **pda, int index, void *item, bool (*eq)(void *, void *)) {
+    __DynArrayHeader **dah = (__DynArrayHeader **) pda;
+    switch (func) {
+        case 0: { // new
+            void *p; dah = (__DynArrayHeader **) &p;
+            da = (__DynArrayHeader *) calloc(1, sizeof(__DynArrayHeader) + 4 * index);
+            da->size = index;
+            da->count = 0;
+            da->capacity = 4;
+            return (void *) da;
+        } break;
+
+        case 1: { // delete
+            if (da) {
+                free(da);
+                da = NULL;
+            }
+        } break;
+
+        case 2: { // count
+            if (da) {
+                return (void *) (size_t) (da->count);
+            }
+            return (void *) (size_t) (0);
+        } break;
+
+        case 3: { // add
+            if (da) {
+                if (da->count == da->capacity) {
+                    int _size = da->size;
+                    int _count = da->count;
+                    int _capacity = da->capacity;
+                    void *p = calloc(1, sizeof(__DynArrayHeader) + _capacity * 2 * _size);
+                    memcpy(p, da, sizeof(__DynArrayHeader) + _count * _size);
+                    free(da);
+                    da = (__DynArrayHeader *) p;
+                    da->size = _size;
+                    da->count = _count;
+                    da->capacity = _capacity * 2;
+                }
+                memcpy(buffer_at(da->count), item, da->size);
+                da->count += 1;
+            }
+        } break;
+
+        case 4: { // rem
+            if (da) {
+                if (index == -1) {
+                    da->count = 0;
+                } else {
+                    memmove(buffer_at(index), buffer_at(index + 1), (da->count - index - 1) * da->size);
+                    da->count -= 1;
+                }
+            }
+        } break;
+
+        case 5: { // get
+            if (da) {
+                return buffer_at(index);
+            }
+        } break;
+
+        case 6: { // set
+            if (da) {
+                memcpy(buffer_at(index), item, da->size);
+            }
+        } break;
+
+        case 7: { // find
+            void *cur = buffer_at(0);
+            void *end = buffer_at(da->count);
+            if (eq) {
+                for (int i = 0; cur < end; i++, cur = (void *) ((size_t) cur + (size_t) da->size)) {
+                    if (eq && eq(cur, item)) {
+                        return (void *) (size_t) (i);
+                    }
+                }
+            } else {
+                for (int i = 0; cur < end; i++, cur = (void *) ((size_t) cur + (size_t) da->size)) {
+                    if (memcmp(cur, item, da->size) == 0) {
+                        return (void *) (size_t) (i);
+                    }
+                }
+            }
+            return (void *) (size_t) (-1);
+        } break;
+    }
+    return NULL;
+}
+
+#undef da
+#undef buffer_at
+
+//
+// C++ to C wrappers
+//
+
+//
+// Main
+//
+
+bool dynos_warp_to_level(int level, int act) {
+    return DynOS_WarpToLevel(level, act);
+}
+
+bool dynos_restart_level() {
+    return DynOS_RestartLevel();
+}
+
+bool dynos_exit_level(int delay) {
+    return DynOS_ExitLevel(delay);
+}
+
+bool dynos_warp_to_castle(int level) {
+    return DynOS_WarpToCastle(level);
+}
+
+bool dynos_return_to_main_menu() {
+    return DynOS_ReturnToMainMenu();
+}
+
+void dynos_add_routine(ubyte type, DynosRoutine routine, void *data) {
+    return DynOS_AddRoutine(type, routine, data);
+}
+
+int dynos_is_level_exit() {
+    return DynOS_IsLevelExit();
+}
+
+void dynos_update_gfx() {
+    return DynOS_UpdateGfx();
+}
+
+//
+// Opt
+//
+
+int dynos_opt_get_value(const char *name) {
+    return DynOS_Opt_GetValue(name);
+}
+
+void dynos_opt_set_value(const char *name, int value) {
+    return DynOS_Opt_SetValue(name, value);
+}
+
+void dynos_opt_add_action(const char *funcname, bool (*funcptr)(const char *), bool overwrite) {
+    return DynOS_Opt_AddAction(funcname, funcptr, overwrite);
+}
+
+//
+// Conversion
+//
+
+ubyte *rgba16_to_rgba32(const ubyte *data, size_t length) {
+    return RGBA16_RGBA32(data, length);
+}
+
+ubyte *rgba32_to_rgba32(const ubyte *data, size_t length) {
+    return RGBA32_RGBA32(data, length);
+}
+
+ubyte *ia4_to_rgba32(const ubyte *data, size_t length) {
+    return IA4_RGBA32(data, length);
+}
+
+ubyte *ia8_to_rgba32(const ubyte *data, size_t length) {
+    return IA8_RGBA32(data, length);
+}
+
+ubyte *ia16_to_rgba32(const ubyte *data, size_t length) {
+    return IA16_RGBA32(data, length);
+}
+
+ubyte *ci4_to_rgba32(const ubyte *data, size_t length, const ubyte *palette) {
+    return CI4_RGBA32(data, length, palette);
+}
+
+ubyte *ci8_to_rgba32(const ubyte *data, size_t length, const ubyte *palette) {
+    return CI8_RGBA32(data, length, palette);
+}
+
+ubyte *i4_to_rgba32(const ubyte *data, size_t length) {
+    return I4_RGBA32(data, length);
+}
+
+ubyte *i8_to_rgba32(const ubyte *data, size_t length) {
+    return I8_RGBA32(data, length);
+}
+
+ubyte *convert_to_rgba32(const ubyte *data, size_t length, int format, int size, const ubyte *palette) {
+    return ConvertToRGBA32(data, length, format, size, palette);
+}
+
+//
+// Gfx
+//
+
+bool dynos_gfx_is_loaded_texture_pointer(void *ptr) {
+    return DynOS_Gfx_IsLoadedTexturePointer(ptr);
+}
+
+bool dynos_gfx_is_texture_pointer(void *ptr) {
+    return DynOS_Gfx_IsTexturePointer(ptr);
+}
+
+ubyte *dynos_gfx_get_texture_data(void *ptr, int *width, int *height) {
+    if (ptr) {
+        DataNode<TexData> *_Node = (DataNode<TexData> *) ptr;
+        *width = _Node->mData->mRawWidth;
+        *height = _Node->mData->mRawHeight;
+        return _Node->mData->mRawData.begin();
+    }
+    return NULL;
+}
+
+void *dynos_gfx_get_texture(const char *texname) {
+    return (void *) DynOS_Gfx_GetTexture(texname);
+}
+
+void *dynos_gfx_load_texture_raw(const ubyte *rgba32buffer, int width, int height, const char *texname) {
+    return (void *) DynOS_Gfx_LoadTextureRAW(rgba32buffer, width, height, texname);
+}
+
+void *dynos_gfx_load_texture_png(const ubyte *pngdata, uint pnglength, const char *texname) {
+    return (void *) DynOS_Gfx_LoadTexturePNG(pngdata, pnglength, texname);
+}
+
+void *dynos_gfx_load_texture_file(const char *filename, const char *texname) {
+    return (void *) DynOS_Gfx_LoadTextureFile(filename, texname);
+}
+
+void dynos_gfx_bind_texture(void *node, void *bind) {
+    return DynOS_Gfx_BindTexture((DataNode<TexData> *) node, bind);
+}
+
+void dynos_gfx_unload_texture(void *node) {
+    return DynOS_Gfx_UnloadTexture((DataNode<TexData> *) node);
+}
+
+int dynos_gfx_import_texture(void **output, void *ptr, int tile, void *grapi, void **hashmap, void *pool, int *poolpos, int poolsize) {
+    return DynOS_Gfx_ImportTexture(output, ptr, tile, grapi, hashmap, pool, (uint *) poolpos, (uint) poolsize);
+}
+
+void dynos_gfx_update_animation(void *ptr) {
+    return DynOS_Gfx_UpdateAnimation(ptr);
+}
+
+//
+// Audio
+//
+
+void dynos_audio_mix(ubyte *output, const ubyte *input, int length, float volume, float distance) {
+    return DynOS_Audio_Mix(output, input, length, volume, distance);
+}
+
+bool dynos_music_load_raw(const char *name, const ubyte *data, int length, int loop, float volume) {
+    return DynOS_Music_LoadRAW(name, data, length, loop, volume);
+}
+
+bool dynos_music_load_wav(const char *name, const char *filename, int loop, float volume) {
+    return DynOS_Music_LoadWAV(name, filename, loop, volume);
+}
+
+void dynos_music_play(const char *name) {
+    return DynOS_Music_Play(name);
+}
+
+void dynos_music_stop() {
+    return DynOS_Music_Stop();
+}
+
+void dynos_music_pause() {
+    return DynOS_Music_Pause();
+}
+
+void dynos_music_resume() {
+    return DynOS_Music_Resume();
+}
+
+bool dynos_music_is_playing(const char *name) {
+    return DynOS_Music_IsPlaying(name);
+}
+
+bool dynos_sound_load_raw(const char *name, const ubyte *data, int length, float volume, ubyte priority) {
+    return DynOS_Sound_LoadRAW(name, data, length, volume, priority);
+}
+
+bool dynos_sound_load_wav(const char *name, const char *filename, float volume, ubyte priority) {
+    return DynOS_Sound_LoadWAV(name, filename, volume, priority);
+}
+
+void dynos_sound_play(const char *name, float *pos) {
+    return DynOS_Sound_Play(name, pos);
+}
+
+void dynos_sound_stop() {
+    return DynOS_Sound_Stop();
+}
+
+bool dynos_sound_is_playing(const char *name) {
+    return DynOS_Sound_IsPlaying(name);
+}
+
+//
+// String
+//
+
+ubyte *dynos_string_convert(const char *str, bool heap) {
+    return DynOS_String_Convert(str, heap);
+}
+
+ubyte *dynos_string_decapitalize(ubyte *str64) {
+    return DynOS_String_Decapitalize(str64);
+}
+
+int dynos_string_length(const ubyte *str64) {
+    return DynOS_String_Length(str64);
+}
+
+int dynos_string_cwidth(ubyte c64) {
+    return DynOS_String_WidthChar64(c64);
+}
+
+int dynos_string_width(const ubyte *str64) {
+    return DynOS_String_Width(str64);
+}
+
+//
+// Geo
+//
+
+int dynos_geo_get_actor_count() {
+    return DynOS_Geo_GetActorCount();
+}
+
+const char *dynos_geo_get_actor_name(int index) {
+    return DynOS_Geo_GetActorName(index);
+}
+
+void *dynos_geo_get_actor_layout(int index) {
+    return DynOS_Geo_GetActorLayout(index);
+}
+
+int dynos_geo_get_actor_index(const void *geolayout) {
+    return DynOS_Geo_GetActorIndex(geolayout);
+}
+
+void *dynos_geo_get_function_pointer_from_name(const char *name) {
+    return DynOS_Geo_GetFunctionPointerFromName(name);
+}
+
+void *dynos_geo_get_function_pointer_from_index(int index) {
+    return DynOS_Geo_GetFunctionPointerFromIndex(index);
+}
+
+int dynos_geo_get_function_index(const void *ptr) {
+    return DynOS_Geo_GetFunctionIndex(ptr);
+}
+
+void *dynos_geo_get_graph_node(const void *geolayout, bool keepInMemory) {
+    return DynOS_Geo_GetGraphNode(geolayout, keepInMemory);
+}
+
+void *dynos_geo_spawn_object(const void *geolayout, void *parent, const void *behavior) {
+    return DynOS_Geo_SpawnObject(geolayout, parent, behavior);
+}
+
+//
+// Levels
+//
+
+int dynos_level_get_count(bool noCastle) {
+    return DynOS_Level_GetCount(noCastle);
+}
+
+int *dynos_level_get_list(bool noCastle, bool ordered) {
+    return DynOS_Level_GetList(noCastle, ordered);
+}
+
+int dynos_level_get_course(int level) {
+    return DynOS_Level_GetCourse(level);
+}
+
+void *dynos_level_get_script(int level) {
+    return DynOS_Level_GetScript(level);
+}
+
+ubyte *dynos_level_get_name(int level, bool decaps, bool addCourseNum) {
+    return DynOS_Level_GetName(level, decaps, addCourseNum);
+}
+
+ubyte *dynos_level_get_act_name(int level, int act, bool decaps, bool addStarNum) {
+    return DynOS_Level_GetActName(level, act, decaps, addStarNum);
+}
+
+}
diff --git a/data/dynos_gfx_dyncmd.cpp b/data/dynos_gfx_dyncmd.cpp
new file mode 100644
index 0000000..a1ee160
--- /dev/null
+++ b/data/dynos_gfx_dyncmd.cpp
@@ -0,0 +1,787 @@
+#include "dynos.cpp.h"
+
+//
+// Cappy Eyes
+//
+
+#define CAPPY_EYES_POINT_COUNT      32     // Default value
+#define CAPPY_EYES_RADIUS           44.f   // Default value
+#define CAPPY_EYES_FORWARD_OFFSET   8.f    // Default value
+#define CAPPY_EYES_GAP              0.90f
+#define CAPPY_EYES_TEXCOORDS_MULT   1.05f
+#define CAPPY_EYES_WH_RATIO         0.75f
+#define CAPPY_EYES_DEPTH            16
+#define CAPPY_EYES_CURVE            12
+
+static const unsigned char sCappyEyesTexDataPng[] = {
+    0x89, 0x50, 0x4E, 0x47, 0xD,  0xA,  0x1A, 0xA,  0x0,  0x0,  0x0,  0xD,  0x49, 0x48, 0x44, 0x52,
+    0x0,  0x0,  0x0,  0x80, 0x0,  0x0,  0x0,  0xC0, 0x8,  0x6,  0x0,  0x0,  0x0,  0xCC, 0x66, 0x6B,
+    0xA7, 0x0,  0x0,  0x0,  0x9,  0x70, 0x48, 0x59, 0x73, 0x0,  0x0,  0xE,  0xC3, 0x0,  0x0,  0xE,
+    0xC3, 0x1,  0xC7, 0x6F, 0xA8, 0x64, 0x0,  0x0,  0x19, 0x26, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA,
+    0xED, 0x5D, 0x9,  0x58, 0x56, 0xD5, 0xBA, 0xC6, 0x79, 0x44, 0x45, 0x40, 0x73, 0xC4, 0x11, 0x9C,
+    0xC5, 0x39, 0x54, 0x9C, 0xD2, 0x8C, 0x9C, 0xE7, 0x72, 0x2A, 0xBD, 0xEA, 0x29, 0x8F, 0x59, 0x76,
+    0x72, 0xC0, 0x4A, 0x33, 0xB3, 0x6E, 0x59, 0xB7, 0xEC, 0x74, 0xEF, 0x55, 0x33, 0xBB, 0x9A, 0x95,
+    0x69, 0x5A, 0xF6, 0xDC, 0x4C, 0x33, 0x8F, 0x3F, 0x20, 0x92, 0x86, 0x94, 0x96, 0x53, 0x66, 0x6A,
+    0x9A, 0x21, 0x29, 0x4E, 0x39, 0xA1, 0xF0, 0x9E, 0xEF, 0xDD, 0xB8, 0x11, 0x10, 0x54, 0xFE, 0xFD,
+    0xF,  0x6B, 0xC3, 0xFA, 0x9E, 0xE7, 0x7D, 0xE0, 0xDF, 0x7B, 0xD,  0xEF, 0xF7, 0xAD, 0x77, 0xAD,
+    0xBD, 0xD6, 0xFA, 0xF7, 0xBF, 0xB7, 0x4F, 0x68, 0x68, 0x28, 0x34, 0xA,  0x2E, 0x7C, 0x74, 0x10,
+    0xB4, 0x0,  0x74, 0x20, 0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34,
+    0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4,
+    0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4, 0x0,  0x34, 0xB4, 0x0,
+    0x34, 0xB4, 0x0,  0x6C, 0x83, 0xF0, 0xF0, 0x70, 0x4C, 0x9A, 0x34, 0x9,  0x8B, 0x17, 0x2F, 0xC6,
+    0x97, 0x5F, 0x7E, 0x89, 0xED, 0xDB, 0xB7, 0xE3, 0xC8, 0x91, 0x23, 0x48, 0x4E, 0x4E, 0xCE, 0x11,
+    0x3C, 0xC7, 0x34, 0x4C, 0xCB, 0x3C, 0xCC, 0xCB, 0x32, 0xB4, 0x0,  0x6C, 0x84, 0xD1, 0xA3, 0x47,
+    0x63, 0xC5, 0x8A, 0x15, 0xF8, 0xF9, 0xE7, 0x9F, 0x91, 0x9A, 0x9A, 0xA,  0xAB, 0xC6, 0x32, 0x58,
+    0x16, 0xCB, 0x64, 0xD9, 0x5A, 0x0,  0xA,  0xA2, 0x4F, 0x9F, 0x3E, 0x46, 0x8F, 0x3D, 0x71, 0xE2,
+    0x4,  0xDC, 0x6D, 0xAC, 0x83, 0x75, 0xB1, 0x4E, 0x2D, 0x0,  0x2F, 0x63, 0xD0, 0xA0, 0x41, 0x58,
+    0xB7, 0x6E, 0x9D, 0x4B, 0x7A, 0xBA, 0x33, 0x23, 0x3,  0xEB, 0x26, 0x7,  0x2D, 0x0,  0x2F, 0xF4,
+    0xF8, 0xAF, 0xBF, 0xFE, 0xDA, 0x2B, 0xD,  0x9F, 0x93, 0x10, 0xC8, 0xC5, 0xAE, 0x23, 0x82, 0xAD,
+    0x4,  0x10, 0x16, 0x16, 0x86, 0xA5, 0x4B, 0x97, 0xE2, 0xEA, 0xD5, 0xAB, 0x50, 0xCD, 0xC8, 0x89,
+    0xDC, 0xC8, 0x51, 0xB,  0xC0, 0xD,  0x98, 0x3A, 0x75, 0x2A, 0x12, 0x13, 0x13, 0xA1, 0xBA, 0x91,
+    0x23, 0xB9, 0x6A, 0x1,  0xB8, 0x8,  0x6D, 0xDB, 0xB6, 0xC5, 0x9A, 0x35, 0x6B, 0x60, 0x37, 0x23,
+    0x67, 0x72, 0xD7, 0x2,  0xB0, 0x80, 0x88, 0x88, 0x8,  0xEC, 0xDF, 0xBF, 0x1F, 0x76, 0x35, 0x72,
+    0xA7, 0xF,  0x5A, 0x0,  0x4E, 0x60, 0xE2, 0xC4, 0x89, 0xB8, 0x70, 0xE1, 0x2,  0xEC, 0x6E, 0xF4,
+    0x81, 0xBE, 0x68, 0x1,  0xE4, 0x1,  0x73, 0xE6, 0xCC, 0xC1, 0xB5, 0x6B, 0xD7, 0x90, 0x5F, 0x8C,
+    0xBE, 0xD0, 0x27, 0x2D, 0x80, 0xBB, 0xC0, 0xC2, 0x85, 0xB,  0x91, 0x5F, 0x8D, 0xBE, 0x69, 0x1,
+    0xE4, 0x82, 0x96, 0x2D, 0x5B, 0x62, 0xED, 0xDA, 0xB5, 0xC8, 0xEF, 0x46, 0x1F, 0xE9, 0xAB, 0x16,
+    0x40, 0x36, 0x70, 0xAF, 0xBD, 0xA0, 0x18, 0x7D, 0xD5, 0x2,  0xC8, 0x4,  0x6E, 0xA0, 0x14, 0x34,
+    0xA3, 0xCF, 0x5A, 0x0,  0x82, 0x37, 0xDF, 0x7C, 0x13, 0x5,  0xD5, 0xE8, 0x7B, 0x81, 0x16, 0xC0,
+    0x94, 0x29, 0x53, 0x94, 0xD8, 0xCF, 0xF7, 0xE6, 0xF7, 0x8,  0x8C, 0x41, 0x81, 0x14, 0x40, 0xBF,
+    0x7E, 0xFD, 0xF2, 0xC5, 0x3A, 0xDF, 0x15, 0xFB, 0x4,  0x8C, 0x45, 0x81, 0x12, 0x0,  0xBF, 0x30,
+    0xF9, 0xE5, 0x97, 0x5F, 0xA0, 0x2D, 0xDD, 0x18, 0xB,  0x6F, 0x7D, 0x89, 0xE4, 0x15, 0x1,  0xAC,
+    0x5F, 0xBF, 0x5E, 0xB7, 0x7A, 0x36, 0x63, 0x4C, 0xA,  0x84, 0x0,  0x22, 0x23, 0x23, 0x75, 0x6B,
+    0xE7, 0x62, 0x8C, 0x4D, 0xBE, 0x16, 0x40, 0xCF, 0x9E, 0x3D, 0xF5, 0x75, 0xFF, 0xE,  0xF3, 0x1,
+    0xC6, 0x28, 0x5F, 0xA,  0x80, 0xBB, 0x5F, 0xBC, 0xE3, 0x56, 0xDB, 0xED, 0x8D, 0x31, 0xF2, 0xE4,
+    0x4E, 0xA1, 0xC7, 0x4,  0x30, 0x7F, 0xFE, 0x7C, 0xDD, 0xBA, 0x77, 0x69, 0x8C, 0x55, 0xBE, 0x12,
+    0x40, 0x8F, 0x1E, 0x3D, 0x70, 0xF1, 0xE2, 0x45, 0xDD, 0xB2, 0x77, 0x69, 0x8C, 0x15, 0x63, 0x96,
+    0x6F, 0x4,  0xB0, 0x71, 0xE3, 0x46, 0xDD, 0xAA, 0x79, 0x34, 0xC6, 0x2C, 0x5F, 0x8,  0x80, 0x37,
+    0x43, 0x68, 0x73, 0xCE, 0x3C, 0x71, 0x23, 0x89, 0x5B, 0x5,  0xC0, 0x7B, 0xE2, 0xF8, 0x73, 0x2B,
+    0x6D, 0xCE, 0x19, 0x63, 0xE7, 0xEE, 0xFB, 0xA,  0xDD, 0x2A, 0x80, 0x57, 0x5E, 0x79, 0x45, 0xB7,
+    0xA2, 0x45, 0x63, 0xC,  0x6D, 0x29, 0x0,  0x2A, 0xD7, 0xE,  0xB7, 0x71, 0xAB, 0x6E, 0x8C, 0xA1,
+    0x3B, 0x47, 0x1,  0x1F, 0x15, 0x7B, 0x7F, 0xEA, 0x95, 0x2B, 0x38, 0xBD, 0x61, 0x3,  0xE,  0x4E,
+    0x9E, 0x8C, 0x1F, 0xFB, 0xF7, 0x47, 0x42, 0x58, 0x18, 0xE2, 0x82, 0x82, 0x10, 0x1B, 0x18, 0x68,
+    0x80, 0xFF, 0xF3, 0x18, 0xCF, 0x31, 0xD,  0xD3, 0x32, 0x8F, 0x1E, 0x5,  0x14, 0x11, 0x80, 0x33,
+    0xBD, 0x3F, 0x2D, 0x35, 0x15, 0x7F, 0x7E, 0xFE, 0xB9, 0xD1, 0xA8, 0x31, 0xBE, 0xBE, 0x70, 0xF8,
+    0x14, 0xCA, 0x13, 0x98, 0x87, 0x79, 0x59, 0x46, 0x5A, 0x3E, 0xFB, 0x8A, 0xD9, 0x9D, 0xA3, 0x80,
+    0x5B, 0x4,  0x30, 0x6F, 0xDE, 0xBC, 0x3C, 0xF5, 0xF6, 0xDF, 0x17, 0x2D, 0xC2, 0xF6, 0x90, 0x6,
+    0x70, 0x14, 0x2A, 0xEC, 0x12, 0xB0, 0x2C, 0x96, 0x99, 0x9F, 0x46, 0x5,  0xC6, 0xD4, 0x16, 0x2,
+    0xE0, 0x36, 0xE6, 0xDD, 0xCE, 0xFC, 0x93, 0xD6, 0xAE, 0x45, 0x6C, 0xE5, 0x2A, 0xD2, 0x68, 0x45,
+    0xB2, 0x20, 0xCA, 0xA7, 0x30, 0x12, 0x4,  0x87, 0xA5, 0x67, 0x27, 0xA,  0xCE, 0xF8, 0xF8, 0xE0,
+    0x92, 0x20, 0xE5, 0x6,  0xF8, 0x3F, 0x8F, 0xF1, 0x1C, 0xD3, 0x30, 0x2D, 0xF3, 0x64, 0x2F, 0x87,
+    0x65, 0x27, 0xE5, 0x93, 0x1B, 0x4D, 0x19, 0x53, 0x77, 0x6C, 0x11, 0xBB, 0x5C, 0x0,  0x7C, 0xAA,
+    0xC6, 0x9D, 0x2C, 0xE5, 0xCF, 0x3F, 0xB1, 0x77, 0xC4, 0x48, 0x38, 0xA,  0x17, 0xCD, 0x82, 0xDD,
+    0xD2, 0x68, 0x27, 0xA5, 0x21, 0x53, 0xA4, 0x51, 0x91, 0x47, 0x30, 0xF,  0xF3, 0xB2, 0x8C, 0xEC,
+    0xE5, 0xB2, 0x2E, 0xD6, 0x69, 0x77, 0x63, 0x6C, 0x95, 0x17, 0x40, 0x6C, 0x6C, 0xEC, 0x6D, 0x9D,
+    0x38, 0x13, 0x1D, 0x83, 0xD8, 0x7B, 0xAA, 0x49, 0xC3, 0x14, 0xCB, 0x40, 0x42, 0xA1, 0xA2, 0x38,
+    0x2B, 0x43, 0x37, 0x5C, 0x4,  0x96, 0xC5, 0x32, 0x33, 0xD7, 0xC1, 0x3A, 0x59, 0xB7, 0x9D, 0x8D,
+    0xB1, 0x55, 0x5A, 0x0,  0xBC, 0xB5, 0xE9, 0x76, 0xF7, 0xF8, 0x25, 0xAD, 0xFD, 0xC,  0x51, 0x25,
+    0xCB, 0xC0, 0x51, 0xA4, 0xB8, 0x81, 0x58, 0x69, 0x98, 0x24, 0xE9, 0xA1, 0x70, 0x13, 0x58, 0x36,
+    0xEB, 0x30, 0xEB, 0x63, 0xDD, 0xE4, 0x60, 0x57, 0x63, 0x6C, 0x5D, 0x7D, 0xFB, 0x98, 0x4B, 0x5,
+    0xB0, 0x6A, 0xD5, 0xAA, 0x5C, 0xC9, 0xFF, 0xF1, 0x7F, 0xCB, 0xE0, 0x28, 0x56, 0x4A, 0x1A, 0xA2,
+    0x84, 0x81, 0x5D, 0x85, 0x8B, 0xE3, 0xAA, 0x34, 0xE,  0xDC, 0xC,  0xD6, 0xC1, 0xBA, 0xCC, 0x7A,
+    0xC9, 0x81, 0x5C, 0xEC, 0x6A, 0x8C, 0xB1, 0x92, 0x2,  0xE0, 0x32, 0x25, 0xB7, 0x9B, 0x3D, 0x8E,
+    0xBD, 0xF5, 0x36, 0x1C, 0x45, 0x4B, 0x1A, 0x88, 0x92, 0x46, 0x38, 0x2A, 0x80, 0x87, 0xC1, 0x3A,
+    0x59, 0xB7, 0xC9, 0x83, 0x9C, 0xEC, 0x68, 0x8C, 0xB1, 0x2B, 0x97, 0x84, 0x3E, 0xEE, 0xBE, 0xD5,
+    0x2B, 0xE9, 0xB3, 0xCF, 0xE1, 0x28, 0x2E, 0xC3, 0x7E, 0xD1, 0x52, 0x88, 0x96, 0xC0, 0x9F, 0x12,
+    0xC0, 0x4B, 0x60, 0xDD, 0xD1, 0x86, 0x0,  0x4A, 0x19, 0x9C, 0xC8, 0xCD, 0x8E, 0xE6, 0xCA, 0x5B,
+    0xC7, 0x7C, 0xDC, 0x39, 0xF9, 0x3B, 0xF7, 0x5D, 0x3C, 0xA2, 0xCB, 0x7,  0xC8, 0xB0, 0x5B, 0x1A,
+    0x31, 0x12, 0xF4, 0x53, 0x2,  0x98, 0x90, 0x6,  0x40, 0x49, 0x5F, 0xA0, 0x74, 0x79, 0xA0, 0xAC,
+    0x1F, 0x50, 0xCE, 0xFF, 0x26, 0xF8, 0x99, 0xC7, 0x79, 0x9E, 0xE9, 0x32, 0xE7, 0xB3, 0x8,  0x72,
+    0x20, 0x17, 0x72, 0x22, 0x37, 0x72, 0x2C, 0xC8, 0x93, 0x41, 0x1F, 0x57, 0xDD, 0xF0, 0x91, 0x7D,
+    0xF2, 0x77, 0xF9, 0xE8, 0x6F, 0xD8, 0x56, 0xB3, 0xAE, 0x4,  0xBA, 0xC,  0x62, 0x4,  0x67, 0x5,
+    0x20, 0x4A, 0xB0, 0xD1, 0x2B, 0x0,  0x15, 0x2B, 0x3,  0x55, 0x6A, 0x2,  0xB5, 0x82, 0x81, 0xE0,
+    0xC6, 0x40, 0x83, 0x66, 0x40, 0xA3, 0xE6, 0xE9, 0x7F, 0xF9, 0x99, 0xC7, 0x79, 0x9E, 0xE9, 0x98,
+    0x9E, 0xF9, 0xCC, 0x32, 0x2C, 0xE2, 0xEC, 0xD,  0x4E, 0xE4, 0x46, 0x8E, 0xE4, 0x6A, 0xB7, 0xC9,
+    0xA0, 0xAB, 0x6E, 0x18, 0x71, 0x89, 0x0,  0x16, 0x2C, 0x58, 0x70, 0xCB, 0xB6, 0x6E, 0x42, 0xE7,
+    0xEE, 0x32, 0xCC, 0x96, 0x45, 0x94, 0xE0, 0x94, 0x0,  0x44, 0x29, 0xE9, 0xD5, 0x15, 0x2A, 0x1,
+    0xD5, 0x6B, 0x3,  0x8D, 0x5B, 0x0,  0xED, 0x3B, 0x1,  0x3D, 0x1F, 0x4,  0xFA, 0xF,  0x4,  0x6,
+    0xE,  0x5,  0x6,  0xD,  0x4B, 0xFF, 0xCB, 0xCF, 0x3C, 0xCE, 0xF3, 0x4C, 0xC7, 0xF4, 0xCC, 0xC7,
+    0xFC, 0x66, 0x59, 0x16, 0x71, 0xEA, 0x6,  0x37, 0x72, 0x24, 0x57, 0xBB, 0x6D, 0x1F, 0x33, 0xE6,
+    0xCA, 0x8,  0x60, 0xEF, 0xDE, 0xBD, 0x59, 0xC8, 0x1D, 0xFF, 0x9F, 0x45, 0x12, 0x58, 0x5F, 0x3,
+    0x87, 0x4A, 0x94, 0x93, 0xDE, 0x2B, 0x28, 0x53, 0x11, 0x8,  0xAC, 0xE,  0xD4, 0x97, 0xDE, 0xDD,
+    0xA1, 0xB,  0x30, 0x60, 0x8,  0x30, 0xEE, 0x31, 0xE0, 0x99, 0x69, 0xC0, 0x73, 0xB3, 0x81, 0x39,
+    0x73, 0x81, 0xB9, 0xF3, 0xD2, 0xFF, 0xF2, 0x33, 0x8F, 0xF3, 0x3C, 0xD3, 0x31, 0x3D, 0xF3, 0x31,
+    0x3F, 0xCB, 0x31, 0xCB, 0xB4, 0x8,  0x72, 0x33, 0x79, 0x92, 0xB3, 0x9D, 0x8C, 0x31, 0x57, 0x42,
+    0x0,  0x1C, 0x8A, 0x32, 0xDB, 0xA5, 0x5F, 0xF,  0x23, 0xC6, 0xBF, 0x2A, 0x1C, 0x12, 0xDC, 0x84,
+    0x12, 0xE5, 0x91, 0x26, 0x40, 0x69, 0x69, 0xB4, 0x0,  0x69, 0xBC, 0x86, 0xA1, 0x40, 0x77, 0xE9,
+    0xD9, 0x63, 0xC6, 0x3,  0x33, 0x9F, 0x7,  0xDE, 0x78, 0xB,  0x78, 0xF7, 0x3D, 0xE0, 0xC3, 0xF,
+    0x65, 0x7D, 0xB3, 0x1A, 0xF8, 0x74, 0x4D, 0xFA, 0x5F, 0x7E, 0xE6, 0x71, 0x9E, 0x67, 0x3A, 0xA6,
+    0x67, 0x3E, 0xE6, 0x67, 0x39, 0x2C, 0x8F, 0xE5, 0x5A, 0x4,  0xB9, 0x91, 0x23, 0xB9, 0x92, 0x33,
+    0xB9, 0xDB, 0xC9, 0x5C, 0x71, 0x19, 0xB0, 0x2C, 0x80, 0x59, 0xB3, 0x66, 0x65, 0x21, 0xB5, 0xAB,
+    0xCF, 0x40, 0x9,  0x68, 0x79, 0x6C, 0x2D, 0x59, 0x1,  0x57, 0x4A, 0x72, 0x32, 0x27, 0x93, 0xBA,
+    0x8A, 0x55, 0xE5, 0xBA, 0xDE, 0x14, 0xB8, 0x2F, 0x2,  0x98, 0xF0, 0x38, 0xF0, 0xD2, 0x2B, 0xC0,
+    0x92, 0xA5, 0xC0, 0xE7, 0x32, 0xB,  0xFF, 0x7A, 0x13, 0x10, 0x15, 0x5,  0x6C, 0xDB, 0x6,  0xC4,
+    0xC5, 0xA5, 0xFF, 0xE5, 0x67, 0x1E, 0xE7, 0x79, 0xA6, 0x63, 0x7A, 0xE6, 0x63, 0x7E, 0x96, 0xC3,
+    0xF2, 0x58, 0x2E, 0xCB, 0xB7, 0x8,  0x72, 0x24, 0x57, 0x72, 0x26, 0x77, 0x3B, 0x19, 0x63, 0xEF,
+    0x75, 0x1,  0x6C, 0xDE, 0xBC, 0xF9, 0xE6, 0x92, 0x6F, 0x8D, 0x2C, 0xF9, 0x18, 0x4C, 0xC1, 0x89,
+    0x52, 0xD2, 0x4B, 0x89, 0x72, 0x32, 0x89, 0xAB, 0x29, 0x13, 0xBA, 0x8E, 0xDD, 0x80, 0x47, 0xA5,
+    0x27, 0xCF, 0x7D, 0x19, 0x58, 0xB6, 0x1C, 0xF8, 0x6A, 0x43, 0x7A, 0x83, 0x27, 0x24, 0x0,  0x7B,
+    0xF6, 0xF0, 0x91, 0x5A, 0x37, 0xC1, 0xCF, 0x3C, 0xCE, 0xF3, 0x4C, 0xC7, 0xF4, 0xCC, 0xC7, 0xFC,
+    0x2C, 0x87, 0xE5, 0xB1, 0x5C, 0xB3, 0xE,  0x8B, 0x20, 0x57, 0x93, 0x37, 0x7D, 0xB0, 0x8B, 0x31,
+    0xF6, 0x5E, 0x15, 0x40, 0x9B, 0x36, 0x6D, 0x32, 0x36, 0x7F, 0x38, 0x89, 0xDA, 0xD1, 0xB2, 0xBD,
+    0x4,  0xD1, 0xF,  0xF1, 0x46, 0x60, 0xA5, 0x87, 0x96, 0x9,  0x94, 0xEB, 0x76, 0x10, 0xD0, 0xBC,
+    0x1D, 0x30, 0xF8, 0x61, 0x19, 0xCE, 0x67, 0xA5, 0xF7, 0x68, 0x36, 0x2A, 0x7F, 0x24, 0xF2, 0xD3,
+    0x4F, 0xC0, 0xE1, 0xC3, 0x7C, 0x2,  0x33, 0x70, 0xF2, 0x24, 0xC0, 0x2F, 0x6C, 0xF8, 0x97, 0x9F,
+    0x79, 0x9C, 0xE7, 0xBF, 0xFD, 0x36, 0x3D, 0x3D, 0xF3, 0x31, 0x3F, 0xCB, 0x69, 0xD6, 0x2E, 0xBD,
+    0x5C, 0x96, 0xCF, 0x7A, 0x5C, 0x80, 0x78, 0x43, 0x4,  0x7E, 0x86, 0xF,  0x76, 0x99, 0x10, 0x32,
+    0xF6, 0x6C, 0x3,  0xAF, 0x9,  0x60, 0xDC, 0xB8, 0x71, 0x37, 0x6F, 0x5A, 0xF8, 0x78, 0x15, 0x1C,
+    0xC,  0xA2, 0xE0, 0x5C, 0x69, 0x69, 0x18, 0xA2, 0x5C, 0x15, 0xE9, 0xAD, 0x21, 0x40, 0x27, 0x99,
+    0x27, 0x4C, 0x98, 0x8,  0xFC, 0xD7, 0xDB, 0xE9, 0xC3, 0xBA, 0xC,  0xF3, 0x69, 0xD2, 0xCB, 0xD3,
+    0x8E, 0x1D, 0x43, 0xDA, 0xA9, 0x53, 0xF4, 0x44, 0xD6, 0x8D, 0x97, 0x1,  0x7E, 0x7F, 0xCF, 0xBF,
+    0xF2, 0x99, 0xC7, 0x8D, 0xF3, 0x22, 0x82, 0x34, 0x5E, 0x16, 0x3E, 0xFB, 0x2C, 0x3D, 0xFF, 0x78,
+    0x29, 0xA7, 0x63, 0x77, 0x59, 0x19, 0x84, 0xA4, 0x97, 0x6F, 0xD6, 0x65, 0x11, 0xE4, 0x6C, 0xF2,
+    0xA7, 0x2F, 0x76, 0x31, 0xB6, 0x81, 0xD7, 0x4,  0x60, 0x3E, 0xD1, 0x8B, 0x3D, 0xE6, 0xDB, 0xC6,
+    0xAD, 0x25, 0x78, 0xFE, 0xD8, 0xCB, 0x80, 0x96, 0xA9, 0x94, 0xE,  0x3F, 0x99, 0xB0, 0x5,  0xCB,
+    0xDA, 0x3E, 0xA2, 0x3F, 0xF0, 0xF4, 0xC,  0x63, 0x62, 0x97, 0xBA, 0x71, 0x13, 0xAE, 0xCB, 0xF0,
+    0x9E, 0x26, 0x3D, 0x3C, 0xED, 0xF4, 0x69, 0x99, 0x35, 0x5E, 0xE2, 0x73, 0xD4, 0xB8, 0xB8, 0x95,
+    0x82, 0xD2, 0xD2, 0xFF, 0xF2, 0xB3, 0x1C, 0x4F, 0x93, 0x11, 0x81, 0xE9, 0xAE, 0x49, 0xFA, 0xBF,
+    0x36, 0x6C, 0xC0, 0xF5, 0xC5, 0x4B, 0xA4, 0x9C, 0xE9, 0xB2, 0x44, 0xEC, 0x7,  0xD4, 0x6B, 0x9A,
+    0x5E, 0xBE, 0x59, 0x97, 0xB,  0xB0, 0xD7, 0x10, 0x81, 0xBF, 0xE1, 0x8B, 0x5D, 0x46, 0x1,  0xAB,
+    0x4F, 0x1E, 0xB3, 0x24, 0x0,  0xF3, 0xB7, 0x7E, 0x7F, 0x2C, 0xFF, 0x8,  0x8E, 0xD2, 0x1,  0x88,
+    0x96, 0x21, 0xF9, 0x4A, 0xD9, 0x7B, 0x0,  0x13, 0x1,  0x32, 0x4C, 0x37, 0x69, 0x2B, 0x4B, 0x39,
+    0x19, 0xB6, 0x9F, 0x9B, 0x83, 0xE4, 0xE5, 0x1F, 0xE0, 0x2F, 0x87, 0x3,  0xD7, 0xD9, 0xAB, 0x39,
+    0xCC, 0xFF, 0xF5, 0x57, 0x7A, 0x63, 0xB3, 0xE1, 0xB3, 0x83, 0xC7, 0xCF, 0x9F, 0x47, 0xDA, 0xF1,
+    0xE3, 0xB8, 0xBE, 0x7B, 0x37, 0xCE, 0x6F, 0xD9, 0x82, 0xFD, 0xCB, 0x96, 0xE1, 0x97, 0xC8, 0x67,
+    0x81, 0xFE, 0xC3, 0x80, 0x46, 0xAD, 0x0,  0xFF, 0xA0, 0x9B, 0x75, 0xB9, 0x0,  0xE4, 0x4E, 0x1F,
+    0xE8, 0xB,  0x7D, 0xB2, 0x83, 0xB1, 0xD,  0xBC, 0x22, 0x0,  0x5E, 0x7B, 0x2E, 0x73, 0xB8, 0x16,
+    0x8B, 0xF,  0xEB, 0x2A, 0x41, 0xB,  0xC4, 0xFE, 0x32, 0x32, 0x31, 0x2B, 0x5B, 0xE5, 0x26, 0x2,
+    0xEB, 0x0,  0xA1, 0xED, 0x71, 0xED, 0xA1, 0x47, 0xB0, 0xFD, 0x85, 0x39, 0x38, 0xF8, 0xF1, 0xC7,
+    0xB8, 0x14, 0x1B, 0x8B, 0x54, 0x99, 0xE8, 0xA5, 0xF1, 0x5A, 0xCF, 0xFC, 0x66, 0xCF, 0xCF, 0xB2,
+    0x93, 0x74, 0x63, 0x24, 0xE0, 0x28, 0x90, 0x98, 0x88, 0xD4, 0x7D, 0xFB, 0x70, 0x69, 0xEB, 0x56,
+    0x23, 0xFF, 0x4A, 0x99, 0xF9, 0x2E, 0x1F, 0x38, 0x4,  0x29, 0x4D, 0x39, 0xF,  0xA8, 0x9D, 0xB5,
+    0x3E, 0x17, 0x80, 0x3E, 0xD0, 0x17, 0xFA, 0x64, 0x7,  0x63, 0x1B, 0x58, 0x99, 0x7,  0x38, 0x2D,
+    0x0,  0xBE, 0x3E, 0xC5, 0xD8, 0xEF, 0xDF, 0xFE, 0x1D, 0x1C, 0x32, 0x7C, 0x12, 0x17, 0x7D, 0xAB,
+    0x1,  0x99, 0x51, 0xA9, 0x1E, 0x52, 0x42, 0x3B, 0xE0, 0xBD, 0xA1, 0xF,  0xE1, 0xD3, 0x17, 0x5F,
+    0xC4, 0xE1, 0xD5, 0xAB, 0x71, 0x45, 0xAE, 0xE7, 0xA9, 0x7,  0xE,  0x20, 0x2D, 0x29, 0x29, 0xFD,
+    0x9A, 0x7F, 0x3B, 0x1,  0xC8, 0x79, 0xA6, 0x63, 0x7A, 0xE6, 0x63, 0x7E, 0x96, 0xF3, 0xD4, 0xE0,
+    0xC1, 0x78, 0xA6, 0x51, 0x33, 0xA4, 0x4,  0xD6, 0xCD, 0x5A, 0x9F, 0xB,  0x40, 0x1F, 0x4C, 0x7F,
+    0xE8, 0x9B, 0x1D, 0xCC, 0xCA, 0xAB, 0x6C, 0x9C, 0x16, 0x80, 0xF9, 0x74, 0xAF, 0x7D, 0x7F, 0x7B,
+    0x52, 0x82, 0x55, 0x19, 0xBB, 0xD9, 0x83, 0xCA, 0x55, 0xCF, 0x82, 0x8B, 0x95, 0xEA, 0xE0, 0xF1,
+    0x90, 0x46, 0xF8, 0x7B, 0xBF, 0x7E, 0x58, 0xFD, 0xC2, 0xB,  0x38, 0xB4, 0x6A, 0x15, 0x2E, 0x73,
+    0x4,  0x90, 0x1E, 0xCD, 0x9E, 0x7D, 0xC7, 0x11, 0x40, 0xCE, 0x73, 0xA4, 0xE0, 0x88, 0x71, 0x59,
+    0x4,  0xC0, 0xFC, 0xAB, 0xE7, 0xCC, 0xC1, 0xE4, 0x81, 0x3,  0xD1, 0x26, 0x24, 0x4,  0xFD, 0x7C,
+    0xFD, 0xA4, 0xC1, 0xAA, 0xDE, 0x52, 0xAF, 0x55, 0xD0, 0x17, 0xFA, 0x44, 0xDF, 0xEC, 0x60, 0x56,
+    0x9E, 0x36, 0xE6, 0xB4, 0x0,  0xF8, 0x96, 0x8C, 0x94, 0xE4, 0x33, 0x88, 0xAE, 0x54, 0x1B, 0xE,
+    0xB9, 0x76, 0x26, 0x1B, 0xC1, 0xAB, 0x91, 0x5,  0x63, 0xCA, 0xFA, 0xA1, 0x71, 0xAD, 0x5A, 0x18,
+    0x1B, 0x11, 0x81, 0x65, 0x91, 0x91, 0xD8, 0xF7, 0xC1, 0x7,  0xB8, 0xC0, 0x39, 0xC0, 0x8F, 0x3F,
+    0x1A, 0x33, 0x7C, 0x5E, 0xE3, 0x6F, 0x3B, 0x7,  0xE0, 0x6A, 0x40, 0xE6, 0xA,  0x9C, 0x33, 0xFC,
+    0x15, 0x15, 0x85, 0x7D, 0x2B, 0x56, 0xE0, 0x83, 0x99, 0x33, 0x31, 0xBE, 0x77, 0x6F, 0x34, 0xAB,
+    0x5B, 0x17, 0x65, 0x4B, 0x95, 0xC2, 0xF0, 0xA2, 0xA5, 0x6F, 0xA9, 0xD7, 0x2A, 0xE8, 0xB,  0x7D,
+    0xA2, 0x6F, 0xF4, 0x51, 0x75, 0x63, 0x5B, 0x78, 0x5C, 0x0,  0xBC, 0x4B, 0xF5, 0xF8, 0xA2, 0xA5,
+    0x12, 0xA8, 0x2A, 0xD8, 0xC1, 0x5E, 0x58, 0x3E, 0x28, 0xB,  0x96, 0xC9, 0x6C, 0xBA, 0x54, 0xF1,
+    0xE2, 0xA8, 0x5B, 0xB5, 0x2A, 0x86, 0x76, 0xE9, 0x82, 0x7F, 0x3E, 0xF9, 0x24, 0xE2, 0x17, 0x2F,
+    0xC6, 0xE9, 0x8D, 0x1B, 0x91, 0x62, 0xAE, 0x2,  0xB8, 0x4,  0xBC, 0xDD, 0x2A, 0x40, 0x56, 0x9,
+    0xC6, 0x2A, 0xE0, 0xFB, 0xEF, 0x8D, 0x7C, 0xCC, 0xFF, 0x8E, 0x94, 0xF3, 0x70, 0xB7, 0x6E, 0x8,
+    0xA9, 0x51, 0xC3, 0x28, 0xDF, 0xC7, 0xC7, 0xC7, 0xA8, 0x2B, 0x7B, 0xFD, 0x56, 0x41, 0x9F, 0xE8,
+    0x1B, 0x7D, 0xB4, 0xC3, 0x1D, 0xC3, 0x1E, 0x15, 0x40, 0xFB, 0xF6, 0xED, 0xD3, 0xB7, 0x7D, 0x7,
+    0xC,  0x87, 0x43, 0x2,  0x75, 0xA8, 0xBC, 0xF4, 0x9C, 0xA,  0xB5, 0x32, 0x70, 0x40, 0xAE, 0xA3,
+    0xBE, 0x3E, 0x85, 0x50, 0xBC, 0x68, 0x51, 0x54, 0xF3, 0xF7, 0xC7, 0x3,  0x32, 0x49, 0x99, 0x33,
+    0x66, 0xC,  0xBE, 0x7E, 0xFD, 0x75, 0xFC, 0xB6, 0x66, 0xD,  0x2E, 0xCB, 0x84, 0xCE, 0x58, 0x9,
+    0xFC, 0xF6, 0xDB, 0xED, 0xF7, 0x1,  0xE4, 0x3C, 0xD3, 0x31, 0xFD, 0x6F, 0x6B, 0xD7, 0x1A, 0xF9,
+    0x59, 0xCE, 0x83, 0xED, 0xDA, 0xA1, 0x46, 0x60, 0x20, 0x4A, 0x14, 0x2B, 0x66, 0x8,  0x80, 0x75,
+    0xB1, 0xCE, 0xCC, 0x1C, 0xAC, 0x82, 0x3E, 0xD1, 0x37, 0xFA, 0x68, 0x7,  0x63, 0x9B, 0x78, 0x4C,
+    0x0,  0x63, 0xC7, 0x8E, 0x35, 0x7E, 0x74, 0x11, 0x15, 0x50, 0x47, 0x82, 0x54, 0xD,  0xE7, 0xFD,
+    0x64, 0x36, 0xEE, 0x57, 0xC7, 0x40, 0x6A, 0x85, 0xDA, 0x68, 0x51, 0x24, 0xBD, 0x67, 0x16, 0x29,
+    0x5C, 0x18, 0x15, 0x7D, 0x7D, 0x8D, 0xEB, 0xF5, 0x63, 0x7D, 0xFB, 0xE2, 0xBD, 0x69, 0xD3, 0x10,
+    0xFF, 0xEE, 0xBB, 0x38, 0xB9, 0x7E, 0x3D, 0xAE, 0xC4, 0xC5, 0xA5, 0x5F, 0xA,  0x7E, 0xFD, 0xD5,
+    0x58, 0xEA, 0x71, 0x4E, 0xC0, 0xEB, 0xBD, 0xF1, 0x97, 0x9F, 0xE5, 0x38, 0xCF, 0x33, 0x1D, 0xD3,
+    0x33, 0x1F, 0xF3, 0xB3, 0x9C, 0xB6, 0xD,  0x1A, 0x18, 0xE5, 0xB2, 0x7C, 0xD6, 0x43, 0xB0, 0x4E,
+    0xD6, 0x6D, 0xF2, 0xB0, 0xA,  0xFA, 0x44, 0xDF, 0xE8, 0xA3, 0x1D, 0x7E, 0x60, 0xC2, 0x36, 0xF1,
+    0x98, 0x0,  0xF8, 0x5B, 0xB5, 0xD3, 0x9B, 0xB6, 0xC0, 0x21, 0xD7, 0xCA, 0x38, 0xF6, 0x7E, 0xBF,
+    0xBA, 0x19, 0xF8, 0x48, 0x66, 0xCF, 0x66, 0xA3, 0x14, 0x12, 0x94, 0x94, 0x61, 0x3A, 0xA8, 0x72,
+    0x65, 0xF4, 0x94, 0x51, 0x60, 0xC6, 0xF0, 0xE1, 0xF8, 0x64, 0xF6, 0x6C, 0xFC, 0xB0, 0x74, 0xA9,
+    0xD1, 0xA8, 0x5C, 0xDA, 0xA5, 0xEC, 0xDC, 0x69, 0x34, 0x74, 0xEA, 0xDE, 0xBD, 0x19, 0xE0, 0x67,
+    0x1E, 0xE7, 0x79, 0xA6, 0x63, 0x7A, 0xE6, 0x63, 0x7E, 0x96, 0xC3, 0xF2, 0x58, 0x6E, 0xA1, 0x1B,
+    0xF5, 0x98, 0xF8, 0xC8, 0xD8, 0x7C, 0xAA, 0xEB, 0x32, 0xD0, 0x37, 0xFA, 0x48, 0x5F, 0x55, 0x37,
+    0x67, 0x7F, 0x3F, 0xE8, 0x94, 0x0,  0xF8, 0x3E, 0x9C, 0x83, 0x53, 0x67, 0x49, 0x70, 0x6A, 0xE0,
+    0x20, 0x87, 0xCC, 0x8A, 0xF5, 0xC,  0xA4, 0x4A, 0xD0, 0x42, 0xA,  0x17, 0xCB, 0xD2, 0x28, 0xEC,
+    0xA5, 0xE5, 0xCA, 0x94, 0x41, 0xC3, 0xA0, 0x20, 0xC,  0xEC, 0xD4, 0x9,  0xB3, 0x1F, 0x79, 0x4,
+    0x9F, 0xC8, 0x8A, 0x80, 0x3D, 0xFA, 0xA8, 0x94, 0xC3, 0x6B, 0xFB, 0x85, 0x2D, 0x5B, 0x8C, 0xFD,
+    0x1,  0xAE, 0x10, 0xF8, 0x97, 0x9F, 0x79, 0x9C, 0xE7, 0x99, 0x8E, 0xE9, 0x99, 0x8F, 0xF9, 0x59,
+    0xE,  0xCB, 0xCB, 0xDC, 0xFB, 0x4D, 0xB0, 0x6E, 0x72, 0x30, 0xF9, 0x58, 0x5,  0x7D, 0x33, 0x7C,
+    0x9C, 0x3A, 0x4B, 0x79, 0x1,  0xB0, 0x4D, 0x3C, 0x26, 0x80, 0x9D, 0xD2, 0x3B, 0xB7, 0xB7, 0xEA,
+    0x2,  0x47, 0xF9, 0x9A, 0x48, 0x66, 0xB0, 0xFC, 0x83, 0xD,  0x7C, 0x24, 0x33, 0xE7, 0xEC, 0x8D,
+    0x42, 0x14, 0x2B, 0x52, 0x4,  0xFE, 0xE5, 0xCA, 0xA1, 0xB9, 0xCC, 0xDC, 0x7,  0x77, 0xEE, 0x8C,
+    0xC8, 0x11, 0x23, 0xB0, 0x64, 0xEA, 0x54, 0xAC, 0x7F, 0xED, 0x35, 0xEC, 0x58, 0xB4, 0x8,  0x7B,
+    0x64, 0x75, 0xF0, 0xCB, 0xCA, 0x95, 0x38, 0x2C, 0xCB, 0x3C, 0xFE, 0xE5, 0x67, 0x1E, 0xE7, 0x79,
+    0xA6, 0x63, 0x7A, 0xE6, 0x63, 0x7E, 0x96, 0xC3, 0xF2, 0x72, 0xAA, 0xC7, 0x18, 0x5,  0xB8, 0xAB,
+    0x77, 0x83, 0x8F, 0x55, 0xD0, 0x37, 0xFA, 0x48, 0x5F, 0x55, 0x37, 0xB6, 0x89, 0xC7, 0x4,  0x70,
+    0x6C, 0xCF, 0x5E, 0x9,  0x4C, 0x10, 0xA2, 0xA4, 0x87, 0xA4, 0xFA, 0x87, 0x48, 0xB0, 0x42, 0x90,
+    0x5A, 0x31, 0xF8, 0x96, 0xDE, 0x9F, 0xF9, 0x52, 0xC0, 0x9,  0x61, 0x40, 0xF9, 0xF2, 0x68, 0x24,
+    0xCB, 0xC2, 0xFB, 0x65, 0x18, 0x1F, 0xDF, 0xAB, 0x17, 0x66, 0x8D, 0x1A, 0x85, 0xB7, 0x9F, 0x78,
+    0x2,  0xEF, 0x4F, 0x9F, 0x8E, 0xF,  0x9F, 0x7B, 0xE,  0x1F, 0x3F, 0xFF, 0xBC, 0xF1, 0x97, 0x9F,
+    0x79, 0x9C, 0xE7, 0x99, 0x8E, 0xE9, 0x99, 0x8F, 0xF9, 0x59, 0x4E, 0xA1, 0x5C, 0x1A, 0x3F, 0x63,
+    0x14, 0xA8, 0x18, 0x6C, 0x70, 0xB2, 0xA,  0xFA, 0x46, 0x1F, 0xE9, 0x6B, 0xCA, 0xA9, 0xD3, 0x4A,
+    0xB,  0x80, 0xAF, 0xB4, 0xF5, 0x88, 0x0,  0xB8, 0xED, 0x98, 0xB4, 0x7E, 0x13, 0x1C, 0x12, 0x98,
+    0x78, 0x4E, 0x98, 0x2,  0x1A, 0x1A, 0xD8, 0x5C, 0xAE, 0x66, 0xAE, 0x8D, 0x62, 0x8A, 0x80, 0x3D,
+    0x97, 0xC3, 0x37, 0xAF, 0xE1, 0xAD, 0xEA, 0xD7, 0xC7, 0xFD, 0xAD, 0x5B, 0xE3, 0xA1, 0xAE, 0x5D,
+    0x31, 0xF6, 0xC1, 0x7,  0x31, 0x41, 0xD6, 0xF6, 0x26, 0xF8, 0x99, 0xC7, 0x79, 0x9E, 0xE9, 0x98,
+    0x9E, 0xF9, 0x98, 0xFF, 0x76, 0x8D, 0x6F, 0x82, 0x5C, 0x4C, 0x5E, 0x56, 0x41, 0x1F, 0xE9, 0xEB,
+    0xA9, 0xAF, 0xBE, 0x51, 0xFE, 0x46, 0x51, 0x67, 0xB6, 0x84, 0xF3, 0x2C, 0x0,  0xBE, 0x22, 0xF5,
+    0xD7, 0x79, 0x6F, 0x48, 0x50, 0x6A, 0xE3, 0xA0, 0x7F, 0x7D, 0x20, 0xB0, 0x91, 0x81, 0x9,  0x25,
+    0x2B, 0xDC, 0xB1, 0x61, 0xCC, 0x39, 0x1,  0x27, 0x70, 0x7E, 0x32, 0x8B, 0xAF, 0x1E, 0x10, 0x80,
+    0xE0, 0xEA, 0xD5, 0xD1, 0xB4, 0x4E, 0x1D, 0xB4, 0xA8, 0x57, 0xF,  0xAD, 0x82, 0x83, 0x8D, 0xBF,
+    0xFC, 0xCC, 0xE3, 0x3C, 0xCF, 0x74, 0x4C, 0x9F, 0xD3, 0x35, 0x3F, 0x37, 0x90, 0x8B, 0xC9, 0xCB,
+    0x2A, 0xE8, 0x23, 0x7D, 0xA5, 0xCF, 0xAA, 0x9B, 0x33, 0xAF, 0xAF, 0xCD, 0xB3, 0x0,  0xF8, 0xE4,
+    0xAA, 0x5D, 0x83, 0x1F, 0x85, 0x43, 0x7A, 0xC6, 0xC9, 0x40, 0xE9, 0x25, 0x95, 0x9A, 0x20, 0x35,
+    0xB0, 0x31, 0xAA, 0x16, 0x2E, 0x7A, 0xD7, 0xD,  0x54, 0xE8, 0x86, 0x10, 0x38, 0x9C, 0x73, 0x33,
+    0x87, 0x3B, 0x7A, 0xE5, 0x4A, 0x97, 0xCE, 0x0,  0x3F, 0xF3, 0x38, 0xCF, 0x33, 0x5D, 0xA1, 0xBB,
+    0x2C, 0xD7, 0x4,  0xB9, 0x90, 0x13, 0xB9, 0x59, 0x5,  0x7D, 0xA4, 0xAF, 0xF4, 0x59, 0x75, 0x73,
+    0xE6, 0xA9, 0x62, 0x79, 0x16, 0x0,  0x5F, 0x7F, 0xB6, 0xB5, 0x76, 0x4B, 0x9,  0x4A, 0x5D, 0x5C,
+    0x31, 0x82, 0xD4, 0x14, 0xD1, 0x15, 0xEA, 0xE4, 0xA9, 0x81, 0x3C, 0x1,  0x72, 0x22, 0x37, 0xAB,
+    0xA0, 0x8F, 0xF4, 0x95, 0x3E, 0xAB, 0x6E, 0xCE, 0xBC, 0x9A, 0x2E, 0xCF, 0x2,  0x58, 0xFC, 0xD2,
+    0xCB, 0x70, 0xC8, 0xEC, 0x78, 0x2B, 0x87, 0xFF, 0xCA, 0xCD, 0xC,  0x4C, 0x29, 0x1D, 0xA0, 0x9C,
+    0x0,  0xC8, 0xC9, 0xE4, 0x67, 0x15, 0xF4, 0x95, 0x3E, 0x5F, 0x3E, 0xF6, 0xBB, 0xD2, 0x2,  0x78,
+    0xE7, 0x9D, 0x77, 0xDC, 0x2F, 0x80, 0x55, 0xB3, 0x5F, 0x92, 0x60, 0xD4, 0xC7, 0xCE, 0x80, 0x6,
+    0xC0, 0x3D, 0xA1, 0x6,  0x5A, 0x14, 0x2D, 0xA5, 0x9C, 0x0,  0xC8, 0xC9, 0xE4, 0x67, 0x15, 0xF4,
+    0x95, 0x3E, 0x9F, 0xD9, 0xB6, 0x43, 0x69, 0x1,  0x2C, 0x5F, 0xBE, 0xDC, 0xFD, 0x2,  0xF8, 0x6A,
+    0xC6, 0x6C, 0x38, 0x64, 0x8D, 0xBC, 0x87, 0x93, 0xA4, 0x7B, 0x5A, 0x20, 0xA5, 0x72, 0x28, 0x4A,
+    0xFA, 0x14, 0x52, 0x4E, 0x0,  0xE4, 0x44, 0x6E, 0xE4, 0x68, 0x15, 0xF4, 0x95, 0x3E, 0x27, 0xAE,
+    0x5A, 0xA7, 0xB4, 0x0,  0xD6, 0xAD, 0x5B, 0xE7, 0x7E, 0x1,  0x38, 0x26, 0xCF, 0x90, 0x60, 0x84,
+    0xE0, 0x10, 0xAF, 0x91, 0x55, 0x5A, 0x61, 0x77, 0x40, 0x23, 0xE5, 0x1A, 0xDF, 0x4,  0xB9, 0x91,
+    0xA3, 0x55, 0xD0, 0x57, 0xFA, 0x7C, 0xF4, 0xAD, 0xC5, 0x4A, 0xB,  0x60, 0xCB, 0x96, 0x2D, 0xEE,
+    0x17, 0x40, 0xEC, 0xE8, 0x89, 0x70, 0xC8, 0x90, 0x78, 0x82, 0xC3, 0x63, 0xD5, 0xD6, 0x78, 0x5F,
+    0xD6, 0xC8, 0xAA, 0xA,  0x80, 0xDC, 0xC8, 0xD1, 0x2A, 0xE8, 0x2B, 0x7D, 0x3E, 0xF0, 0xB4, 0xDA,
+    0x5B, 0xC2, 0xCE, 0xEC, 0x6,  0xE6, 0x59, 0x0,  0x71, 0xBD, 0x47, 0x48, 0x30, 0x1A, 0x22, 0xB9,
+    0xAA, 0xF4, 0x8E, 0x6A, 0x6D, 0x31, 0xA5, 0x4C, 0x65, 0x65, 0x5,  0x40, 0x6E, 0xE4, 0x68, 0x15,
+    0xF4, 0x95, 0x3E, 0xEF, 0x1A, 0x3A, 0x5E, 0x69, 0x1,  0xF0, 0xE5, 0x53, 0x6E, 0x17, 0xC0, 0xB6,
+    0xFB, 0x6,  0xC1, 0x21, 0xD7, 0xC4, 0xB3, 0xEC, 0x1D, 0xD5, 0xDA, 0x61, 0x60, 0x49, 0x3F, 0x65,
+    0x5,  0x40, 0x6E, 0xE4, 0x68, 0x15, 0xE7, 0xAA, 0xB6, 0x31, 0x7C, 0x4E, 0xE8, 0x35, 0x42, 0xB,
+    0x20, 0x2E, 0xAC, 0x97, 0x4,  0xA3, 0x31, 0x2E, 0xB2, 0x77, 0x54, 0xBF, 0x17, 0x5D, 0x4A, 0x94,
+    0x53, 0x56, 0x0,  0xE4, 0x46, 0x8E, 0x56, 0x41, 0x5F, 0xE9, 0xF3, 0x8E, 0xF0, 0x7E, 0x4A, 0xB,
+    0x20, 0x29, 0x29, 0xC9, 0x3,  0x23, 0x40, 0xEB, 0x9E, 0x70, 0x54, 0x6A, 0x82, 0x8B, 0xC,  0x4E,
+    0x8D, 0xF6, 0x68, 0x55, 0xAC, 0x8C, 0xB2, 0x2,  0x20, 0x37, 0x72, 0xB4, 0x8A, 0xCB, 0x35, 0xC2,
+    0xC,  0x9F, 0xBF, 0x6D, 0x1B, 0xA1, 0xB4, 0x0,  0x92, 0x93, 0x93, 0xDD, 0x2F, 0x80, 0x98, 0x90,
+    0x8E, 0x12, 0x8C, 0xA6, 0x48, 0x31, 0x82, 0xD3, 0x1,  0x4D, 0x8A, 0x95, 0x56, 0x56, 0x0,  0xE4,
+    0x46, 0x8E, 0x56, 0x41, 0x5F, 0xE9, 0x73, 0x6C, 0xC3, 0x4E, 0x5A, 0x0,  0xD1, 0x75, 0xEE, 0x85,
+    0xA3, 0x72, 0x33, 0xA4, 0xD4, 0xEC, 0x8,  0xD4, 0xC,  0x47, 0x60, 0x2E, 0x5F, 0x1,  0xAB, 0x0,
+    0x72, 0x23, 0x47, 0xAB, 0xB8, 0x2E, 0xA0, 0xCF, 0x31, 0xE2, 0xBB, 0xCA, 0xC6, 0x1F, 0x8B, 0xBA,
+    0x7F, 0x1F, 0xA0, 0x72, 0x73, 0x3,  0x69, 0x41, 0xD2, 0x1B, 0x4,  0xBE, 0x85, 0x8A, 0x28, 0x2B,
+    0x0,  0x72, 0xC3, 0xD,  0x9E, 0x56, 0x61, 0xFA, 0xAD, 0xBA, 0xB9, 0x5D, 0x0,  0x51, 0x41, 0x32,
+    0x21, 0xE2, 0x1E, 0x40, 0xAD, 0x2E, 0x6,  0x54, 0x6D, 0x7C, 0x13, 0x26, 0x4F, 0x2B, 0x48, 0x13,
+    0xD0, 0x67, 0xFA, 0x5E, 0xE0, 0x5,  0x10, 0xDB, 0xA8, 0xAB, 0x4,  0xA3, 0x5,  0xAE, 0xD7, 0xEA,
+    0x2A, 0xC1, 0xE9, 0xAA, 0xFE, 0x25, 0xE0, 0x6,  0x4F, 0x2B, 0x48, 0x31, 0x4,  0xD0, 0x2,  0xB1,
+    0x8D, 0xD5, 0xFE, 0xBD, 0x20, 0x6F, 0xA,  0x71, 0xBB, 0x0,  0xB6, 0x36, 0xEB, 0x1,  0x47, 0x95,
+    0x96, 0x48, 0xA9, 0x2D, 0xC1, 0xA8, 0xDD, 0xD,  0x75, 0x8A, 0x96, 0x54, 0x56, 0x0,  0xE4, 0x46,
+    0x8E, 0x56, 0x41, 0x5F, 0xE9, 0xF3, 0xB6, 0xD0, 0xFB, 0xF5, 0x24, 0x30, 0x2E, 0x7C, 0x90, 0x4,
+    0xA3, 0x15, 0x2E, 0x33, 0x38, 0x75, 0xBA, 0xA3, 0x45, 0x71, 0x5F, 0x65, 0x5,  0x40, 0x6E, 0xE4,
+    0x68, 0x15, 0x17, 0xC5, 0x57, 0xFA, 0xBC, 0xA3, 0xCB, 0x50, 0x2D, 0x0,  0x43, 0x0,  0x55, 0x5B,
+    0x4B, 0x50, 0xEE, 0x93, 0xE0, 0xF4, 0x40, 0x17, 0x85, 0x77, 0x2,  0xC9, 0x8D, 0x1C, 0xAD, 0x82,
+    0xBE, 0xD2, 0xE7, 0x1D, 0x5D, 0x87, 0xE9, 0x8D, 0xA0, 0x6D, 0x11, 0xA3, 0x24, 0x18, 0x6D, 0x70,
+    0x8E, 0x2,  0xA8, 0xDB, 0x13, 0x43, 0x14, 0xFE, 0x2E, 0x80, 0xDC, 0xC8, 0xD1, 0x2A, 0xCE, 0x1A,
+    0x2,  0x68, 0x83, 0xEF, 0x7,  0x4C, 0xD0, 0x5B, 0xC1, 0x71, 0x3,  0xC6, 0xC1, 0xC1, 0x2F, 0x48,
+    0xEA, 0x88, 0x0,  0xEA, 0x3D, 0x80, 0x19, 0x15, 0x6A, 0x2B, 0x2B, 0x0,  0x72, 0x23, 0x47, 0xAB,
+    0xA0, 0xAF, 0xF4, 0x79, 0xD7, 0x88, 0xC9, 0x5A, 0x0,  0x5B, 0xC7, 0x3C, 0x2D, 0xC1, 0x68, 0x87,
+    0x13, 0x9C, 0x3,  0xD4, 0x8B, 0xC0, 0x27, 0x95, 0x43, 0x95, 0x15, 0x0,  0xB9, 0x91, 0xA3, 0x55,
+    0xD0, 0x57, 0xFA, 0x7C, 0x60, 0x9A, 0xDA, 0x2F, 0xC2, 0x8C, 0x8F, 0x8F, 0x77, 0xBF, 0x0,  0x36,
+    0x3F, 0xF5, 0x3C, 0x1C, 0xD5, 0xEF, 0xC5, 0x21, 0xAE, 0x2,  0xEA, 0xF7, 0xC2, 0x81, 0xA0, 0xCE,
+    0xCA, 0xA,  0x80, 0xDC, 0xC8, 0xD1, 0x2A, 0xE8, 0x2B, 0x7D, 0x3E, 0xFA, 0xDF, 0xCB, 0x95, 0x16,
+    0x80, 0x33, 0xCF, 0x9,  0xC8, 0xB3, 0x0,  0xFE, 0x3F, 0x72, 0xAE, 0x4,  0x23, 0xC,  0x7B, 0xB8,
+    0x49, 0x12, 0xDC, 0x1B, 0xA9, 0x12, 0x20, 0x15, 0x77, 0x3,  0xC9, 0x89, 0xDC, 0xC8, 0xD1, 0x2A,
+    0xE8, 0x2B, 0x7D, 0x4E, 0x5C, 0xB3, 0x41, 0x69, 0x1,  0x38, 0xF3, 0xFB, 0xC0, 0x3C, 0xB,  0xE0,
+    0xE3, 0xD9, 0x2F, 0xC3, 0x51, 0xA3, 0x3D, 0x76, 0x72, 0x8B, 0x34, 0xA4, 0xAF, 0x81, 0xE,  0xA5,
+    0x2A, 0x2A, 0x27, 0x0,  0x72, 0x32, 0xF9, 0x59, 0x5,  0x7D, 0xA5, 0xCF, 0x67, 0xBE, 0xFD, 0x5E,
+    0x69, 0x1,  0x2C, 0x5D, 0xBA, 0xD4, 0xFD, 0x2,  0xF8, 0xDF, 0xB9, 0x14, 0x40, 0x7,  0x6C, 0xE5,
+    0x17, 0x25, 0x21, 0xFD, 0xC,  0x3C, 0xEF, 0x1F, 0xAC, 0x9C, 0x0,  0xC8, 0xC9, 0xE4, 0x67, 0x15,
+    0xF4, 0x95, 0x3E, 0x5F, 0x3E, 0xFE, 0x87, 0xD2, 0x2,  0x70, 0xE6, 0x11, 0xF2, 0x79, 0x16, 0x0,
+    0x1F, 0x50, 0xBC, 0xB5, 0x69, 0x4,  0x1C, 0x35, 0x3B, 0xE2, 0xA,  0x3,  0xD4, 0x60, 0x0,  0x76,
+    0xD7, 0xEA, 0xA6, 0xDE, 0xD,  0xA1, 0xC2, 0x89, 0xDC, 0xAC, 0x82, 0x3E, 0xD2, 0x57, 0xFA, 0xAC,
+    0xBA, 0x39, 0xF3, 0xF0, 0xE8, 0x3C, 0xB,  0x80, 0x8F, 0x26, 0xDD, 0x35, 0xEA, 0x1F, 0x12, 0x94,
+    0x70, 0x9C, 0xC,  0x96, 0x6B, 0x6C, 0xC3, 0x81, 0x6,  0xEA, 0x29, 0x74, 0x63, 0x8,  0xB9, 0x98,
+    0xBC, 0xAC, 0x82, 0x3E, 0xD2, 0x57, 0xFA, 0xAC, 0xBA, 0x39, 0xF3, 0xD8, 0xD8, 0x3C, 0xB,  0x20,
+    0x22, 0x22, 0x2,  0xBF, 0xBE, 0xBE, 0x4,  0xE,  0xB9, 0x2E, 0x1E, 0xAC, 0xD7, 0x53, 0x82, 0x34,
+    0xC8, 0xC0, 0xB4, 0x8A, 0xEA, 0x5C, 0x6,  0xC8, 0xC5, 0xE4, 0x65, 0x15, 0xF4, 0x91, 0xBE, 0xD2,
+    0x67, 0xD5, 0x8D, 0x6D, 0xE3, 0x76, 0x1,  0xF0, 0xFD, 0xB5, 0x27, 0x37, 0x46, 0x4B, 0x50, 0x3A,
+    0x23, 0x9E, 0x7B, 0xE5, 0x8D, 0x86, 0x18, 0x88, 0xAF, 0xDD, 0x5D, 0x19, 0x1,  0x90, 0x8B, 0xC9,
+    0xCB, 0x2A, 0xE8, 0x23, 0x7D, 0x3D, 0xF5, 0x4D, 0xAC, 0xD2, 0x8D, 0x7F, 0xED, 0xDA, 0x35, 0xA7,
+    0xDE, 0x2D, 0xEC, 0xD4, 0x3,  0x22, 0x8E, 0xFE, 0xB4, 0xF,  0xE,  0x59, 0x1A, 0x45, 0xC9, 0xFA,
+    0x38, 0xB5, 0xF1, 0x50, 0xE0, 0x6,  0x3A, 0x94, 0xF2, 0x57, 0x60, 0xF6, 0xEF, 0x9F, 0xC1, 0xC7,
+    0x2A, 0xE8, 0x1B, 0x7D, 0xA4, 0xAF, 0x29, 0xA7, 0xCF, 0x2A, 0x2D, 0x80, 0xE3, 0xC7, 0x8F, 0x7B,
+    0xEE, 0x9,  0x21, 0x7C, 0x40, 0xF1, 0xF6, 0x6E, 0xA3, 0x25, 0x30, 0x5D, 0x91, 0xCC, 0x6B, 0x65,
+    0x93, 0x87, 0xC,  0x6C, 0x52, 0xE0, 0x6,  0x11, 0x72, 0x30, 0xF9, 0x58, 0x5,  0x7D, 0xA3, 0x8F,
+    0xF4, 0x55, 0x75, 0x73, 0xF6, 0xA1, 0xD1, 0x4E, 0x9,  0x60, 0xE5, 0xCA, 0x95, 0x38, 0xF8, 0xC2,
+    0x3F, 0xE1, 0xA8, 0xDD, 0xD,  0x7,  0xB9, 0x59, 0xD2, 0xE4, 0xE1, 0xC,  0x74, 0xF0, 0xE2, 0x2F,
+    0x85, 0x59, 0x77, 0x66, 0x2E, 0x56, 0x41, 0xDF, 0xC,  0x1F, 0xC5, 0x57, 0xD5, 0x8D, 0x6D, 0xE2,
+    0x31, 0x1,  0xCC, 0x9D, 0x3B, 0x17, 0xA7, 0xA3, 0x76, 0x48, 0x70, 0xEE, 0x43, 0x5C, 0xDD, 0xFB,
+    0x81, 0xA6, 0x23, 0x32, 0xB0, 0xA9, 0xB6, 0xF7, 0x96, 0x84, 0xAC, 0x3B, 0x33, 0x17, 0xAB, 0xA0,
+    0x6F, 0xF4, 0x91, 0xBE, 0xAA, 0x6E, 0x6C, 0x13, 0x8F, 0x9,  0x60, 0xF8, 0xF0, 0xE1, 0x48, 0xBD,
+    0x72, 0x15, 0x51, 0xD,  0x22, 0xE0, 0x90, 0x49, 0xD2, 0xF9, 0x26, 0xC3, 0x80, 0x66, 0x23, 0x33,
+    0xD0, 0xC7, 0xB7, 0x9A, 0xC7, 0x1B, 0x9F, 0x75, 0x66, 0xE6, 0x60, 0x15, 0xF4, 0x89, 0xBE, 0xD1,
+    0x47, 0xFA, 0xAA, 0xBA, 0xB1, 0x4D, 0x3C, 0x26, 0x0,  0xBE, 0xBC, 0x98, 0xF7, 0x9F, 0xED, 0x7A,
+    0x34, 0x52, 0x82, 0xD4, 0x3,  0x87, 0xB8, 0x69, 0xD2, 0x6C, 0x54, 0x6,  0xFE, 0x94, 0xD9, 0x73,
+    0x55, 0xF,  0x3E, 0x33, 0x80, 0x75, 0xB1, 0xCE, 0xCC, 0x1C, 0xAC, 0x82, 0x3E, 0xD1, 0x37, 0xFA,
+    0xA8, 0xBA, 0xB1, 0x2D, 0x9C, 0x7D, 0xA1, 0xB4, 0xD3, 0xF,  0x8B, 0xE6, 0x77, 0xCF, 0xC7, 0x97,
+    0xAF, 0x83, 0x43, 0x86, 0xC9, 0x1D, 0xF5, 0x1F, 0x4,  0x9A, 0x3F, 0x92, 0x5,  0x9B, 0xEB, 0xDC,
+    0x8F, 0x22, 0x1E, 0x78, 0x6E, 0x0,  0xEB, 0x60, 0x5D, 0xD9, 0xEB, 0xB7, 0xA,  0xFA, 0x44, 0xDF,
+    0xE8, 0xA3, 0xEA, 0xE6, 0xCC, 0x7D, 0x0,  0x96, 0x5,  0xB0, 0x7E, 0xFD, 0x7A, 0xA4, 0x9C, 0x3D,
+    0x8F, 0xE8, 0x26, 0x7D, 0x25, 0x50, 0x3D, 0x91, 0xDC, 0x74, 0x38, 0x10, 0xFA, 0x68, 0x16, 0x3C,
+    0x5B, 0xB9, 0x99, 0xDB, 0x5,  0xC0, 0x3A, 0xB2, 0xD7, 0x6B, 0x15, 0xF4, 0x85, 0x3E, 0xD1, 0x37,
+    0xFA, 0xA8, 0xBA, 0xB1, 0x2D, 0x3C, 0x2E, 0x0,  0x3E, 0x9B, 0x96, 0xB6, 0x6F, 0xFA, 0x1B, 0x70,
+    0xD4, 0x7B, 0x0,  0xBB, 0x1B, 0xF4, 0x7,  0x5A, 0x8C, 0xCD, 0x82, 0xD4, 0xD0, 0x31, 0x98, 0x14,
+    0xD0, 0xD0, 0x6D, 0x8D, 0xCF, 0xB2, 0x59, 0x47, 0xF6, 0x7A, 0xAD, 0x82, 0xBE, 0xD0, 0x27, 0xFA,
+    0x66, 0x7,  0x73, 0xF6, 0x39, 0xC1, 0x96, 0x4,  0x30, 0x68, 0xD0, 0x20, 0xA3, 0xF2, 0x73, 0x9,
+    0xFB, 0x24, 0x58, 0x11, 0x6,  0x2E, 0x72, 0xF8, 0x6C, 0xF1, 0x1F, 0xB7, 0x60, 0x5A, 0xA5, 0xA6,
+    0xAE, 0xDF, 0xEE, 0xE5, 0x13, 0x4A, 0x72, 0xA8, 0xCB, 0x2A, 0xE8, 0x83, 0xE9, 0xF,  0x7D, 0xB3,
+    0x83, 0xB1, 0x2D, 0x3C, 0x2E, 0x0,  0x6E, 0x3B, 0x9E, 0x3B, 0x77, 0x2E, 0xFD, 0x56, 0xA4, 0xBE,
+    0x93, 0xE0, 0x90, 0x6B, 0xE6, 0xFE, 0x46, 0x83, 0x81, 0x96, 0xE3, 0x72, 0xC4, 0x6B, 0xD5, 0xDA,
+    0xBA, 0x64, 0x4E, 0xC0, 0x32, 0x58, 0x56, 0x6E, 0xF5, 0x58, 0x5,  0x7D, 0xA0, 0x2F, 0xF4, 0xC9,
+    0xE,  0xC6, 0x36, 0x70, 0x66, 0xB,  0xD8, 0x25, 0xAF, 0x8D, 0xE3, 0x33, 0x69, 0x68, 0x7F, 0x7C,
+    0xBA, 0x49, 0x82, 0xD6, 0xB,  0xD1, 0xC1, 0xBD, 0x71, 0xA5, 0xA5, 0xF4, 0xA4, 0x56, 0x13, 0x72,
+    0xC4, 0xF7, 0xD,  0x7,  0xA2, 0x4B, 0xD9, 0x2A, 0xCE, 0xDF, 0xE6, 0x2D, 0x79, 0x59, 0x46, 0x6E,
+    0xE5, 0x5B, 0x5,  0xB9, 0xD3, 0x7,  0xFA, 0x42, 0x9F, 0xEC, 0x60, 0xCE, 0x3C, 0x17, 0xC8, 0x65,
+    0x2,  0x30, 0x5F, 0x1C, 0x65, 0xBC, 0x38, 0xB2, 0xFB, 0x78, 0x38, 0x24, 0x78, 0x7B, 0xB9, 0x8F,
+    0xDE, 0xEA, 0x6F, 0xB7, 0xC5, 0x5A, 0x99, 0xB5, 0xB7, 0xCA, 0xC3, 0x8E, 0x21, 0xD3, 0x32, 0xCF,
+    0x9D, 0xCA, 0xB5, 0xA,  0x72, 0xA7, 0xF,  0xF4, 0xC5, 0x2E, 0x2F, 0x8E, 0xB4, 0xF2, 0xC2, 0x28,
+    0xCB, 0x2,  0x18, 0x39, 0x72, 0x64, 0x6,  0x91, 0xC4, 0x75, 0x5B, 0x24, 0x78, 0x7D, 0xC,  0x9C,
+    0xE3, 0xF5, 0xB4, 0xF5, 0xE3, 0x77, 0xC4, 0x49, 0xB9, 0xDE, 0xBE, 0x5F, 0xAB, 0x2B, 0x1E, 0xF1,
+    0xF,  0xC1, 0x10, 0xBF, 0xBA, 0x59, 0xC0, 0x63, 0x3C, 0xC7, 0x34, 0x77, 0x53, 0x96, 0x55, 0x90,
+    0xB3, 0xC9, 0x9F, 0xBE, 0xD8, 0xC5, 0xD8, 0x6,  0x5E, 0x13, 0x0,  0xAF, 0x3D, 0xA7, 0x4F, 0x9F,
+    0xCE, 0x18, 0x5,  0x76, 0xF4, 0x96, 0xB9, 0x40, 0x48, 0x5F, 0xC4, 0x73, 0x2E, 0xD0, 0x66, 0xA2,
+    0xAD, 0x40, 0xCE, 0xE4, 0x4E, 0x1F, 0xEC, 0xD2, 0xFB, 0x19, 0x7B, 0x2B, 0xD7, 0x7F, 0x97, 0xBC,
+    0x3E, 0xFE, 0x8B, 0x2F, 0xBE, 0xC8, 0x20, 0x94, 0xF4, 0x55, 0xAC, 0x4,  0xB1, 0x9F, 0x81, 0x13,
+    0x5C, 0x9E, 0xB5, 0x9D, 0x64, 0xB,  0x90, 0xAB, 0xC9, 0x9B, 0x3E, 0xD8, 0xC5, 0x18, 0x7B, 0xAF,
+    0xBE, 0x3E, 0x9E, 0x98, 0x3A, 0x75, 0x6A, 0x16, 0x52, 0xBB, 0xC6, 0xCD, 0x81, 0x43, 0xD6, 0xD1,
+    0x5B, 0x65, 0xB2, 0x76, 0x85, 0xBD, 0xAB, 0xED, 0x13, 0x4A, 0x83, 0x1C, 0xC9, 0x95, 0x9C, 0xC9,
+    0xDD, 0x4E, 0xC6, 0xD8, 0x7B, 0x5D, 0x0,  0xE1, 0xE1, 0xE1, 0xC6, 0x5E, 0xB4, 0x69, 0x97, 0x8E,
+    0x25, 0x22, 0xA6, 0xE5, 0xC3, 0x12, 0xD0, 0x1,  0x48, 0x68, 0xF2, 0x10, 0xD2, 0xDA, 0x4D, 0x6,
+    0x14, 0x5,  0xB9, 0x91, 0x23, 0xB9, 0x92, 0x33, 0xB9, 0xDB, 0xC5, 0x18, 0x73, 0xC6, 0xDE, 0xEB,
+    0x2,  0x20, 0xF8, 0x93, 0xA4, 0x2C, 0x77, 0xA7, 0x7C, 0xB8, 0x1E, 0xE,  0xF6, 0x2A, 0xC1, 0x21,
+    0x6E, 0xAF, 0xDE, 0xFB, 0x94, 0x92, 0x20, 0x37, 0x93, 0x27, 0x39, 0xDB, 0xC9, 0x9C, 0xF9, 0x19,
+    0x98, 0xDB, 0x4,  0x30, 0x6F, 0xDE, 0xBC, 0x2C, 0xE4, 0x38, 0x89, 0x4A, 0x18, 0x3E, 0x53, 0x2,
+    0x3B, 0x8,  0x51, 0x32, 0xB9, 0x3A, 0xD5, 0xFA, 0x31, 0x9,  0xF8, 0x14, 0xA5, 0x40, 0x4E, 0xE4,
+    0x46, 0x8E, 0xE4, 0x6A, 0x97, 0x89, 0x9F, 0x69, 0x8C, 0xB9, 0x32, 0x2,  0xE0, 0x50, 0x74, 0xF5,
+    0x6A, 0xD6, 0xEF, 0xCC, 0x2F, 0xFF, 0x9E, 0x84, 0x6D, 0x9D, 0xC7, 0xC3, 0x21, 0x41, 0x8E, 0x91,
+    0xF5, 0xF5, 0x59, 0x4E, 0xB8, 0xC2, 0xFE, 0xA1, 0x4,  0xC8, 0x85, 0x9C, 0xC8, 0x8D, 0x1C, 0xC9,
+    0xD5, 0x4E, 0xC6, 0x58, 0xBB, 0x62, 0xF8, 0x77, 0x99, 0x0,  0x88, 0x8D, 0x1B, 0x37, 0xDE, 0xBA,
+    0x4D, 0xB9, 0xFB, 0x20, 0xA2, 0x5B, 0x8D, 0x94, 0x40, 0xF,  0x91, 0x80, 0xF,  0xC3, 0xA9, 0x36,
+    0x7F, 0x7,  0xDA, 0x3F, 0xE3, 0x55, 0x90, 0x3,  0xB9, 0x90, 0x13, 0xB9, 0x91, 0xA3, 0xDD, 0x8C,
+    0xB1, 0x76, 0x55, 0xBB, 0xB9, 0x4C, 0x0,  0x93, 0x26, 0xE5, 0xBC, 0x77, 0x9E, 0xB4, 0x69, 0x3B,
+    0x1C, 0x4D, 0x25, 0xE0, 0xD2, 0xE3, 0xA2, 0x9B, 0x88, 0x8,  0x38, 0x12, 0x74, 0x98, 0xE6, 0x15,
+    0xB0, 0x6E, 0x72, 0x20, 0x17, 0x72, 0x22, 0x37, 0x3B, 0x1A, 0x63, 0xAD, 0x9C, 0x0,  0xB8, 0x21,
+    0xC1, 0x47, 0x94, 0xE4, 0x64, 0xC7, 0x96, 0x7D, 0x29, 0x41, 0x1F, 0x66, 0x20, 0x4A, 0x66, 0xDD,
+    0x47, 0x39, 0x27, 0xE8, 0x30, 0xDD, 0xA3, 0x60, 0x9D, 0xAC, 0xDB, 0xE4, 0x41, 0x4E, 0x76, 0x34,
+    0xC6, 0xD8, 0xEA, 0xE6, 0x8F, 0x5B, 0x4,  0x40, 0x2C, 0x59, 0x92, 0xFB, 0xAF, 0x67, 0xFE, 0xF8,
+    0xCC, 0x1,  0x47, 0x33, 0x59, 0x1E, 0xB2, 0x11, 0x4,  0xBB, 0x5A, 0x8C, 0xC1, 0xD5, 0xE,  0x53,
+    0x81, 0x8E, 0x33, 0xDC, 0xA,  0xD6, 0xC1, 0xBA, 0xCC, 0x7A, 0xC9, 0x81, 0x5C, 0xEC, 0x6A, 0x8C,
+    0xB1, 0x2B, 0xDB, 0xCC, 0xA5, 0x2,  0xE8, 0xD1, 0xA3, 0x87, 0xF1, 0xB,  0x95, 0x5C, 0xD5, 0xBB,
+    0x69, 0x7,  0xA2, 0x42, 0x65, 0x4E, 0xD0, 0xE4, 0x61, 0x3,  0xB1, 0xCD, 0x46, 0x22, 0xE9, 0xDE,
+    0x27, 0x81, 0xF0, 0x99, 0x6E, 0x1,  0xCB, 0x66, 0x1D, 0x66, 0x7D, 0xAC, 0x9B, 0x1C, 0xEC, 0x6A,
+    0x8C, 0x2D, 0x63, 0xAC, 0xAC, 0x0,  0xCC, 0x5B, 0xC5, 0x6E, 0x67, 0x67, 0xE2, 0xF7, 0x21, 0xB6,
+    0xF3, 0x63, 0x72, 0xD,  0x1E, 0x9E, 0x81, 0x4,  0xE9, 0xA1, 0x67, 0x39, 0x43, 0xF,  0x7F, 0xD6,
+    0x25, 0x60, 0x59, 0x2C, 0x33, 0x73, 0x1D, 0xAC, 0x93, 0x75, 0xDB, 0xD9, 0xAC, 0xDC, 0xFA, 0xE5,
+    0x31, 0x1,  0x8C, 0x1E, 0x7D, 0xE7, 0x5F, 0xD1, 0xA4, 0x24, 0x9F, 0xC7, 0xDE, 0xE9, 0xEF, 0x48,
+    0xC3, 0x8C, 0xC8, 0x82, 0xDD, 0x2D, 0xC7, 0xE3, 0xA4, 0xAC, 0xD1, 0x53, 0xD8, 0x90, 0x9D, 0x9E,
+    0xCF, 0x13, 0x98, 0x87, 0x79, 0x59, 0x46, 0xF6, 0x72, 0x59, 0x17, 0xEB, 0xB4, 0xBB, 0x31, 0xB6,
+    0xCA, 0xB,  0x80, 0xD8, 0xB5, 0x6B, 0xD7, 0xDD, 0x4D, 0x68, 0xBE, 0xF9, 0xE,  0xB1, 0x5D, 0x26,
+    0xCA, 0x75, 0x79, 0x64, 0x16, 0x44, 0x35, 0x1F, 0x85, 0x84, 0x96, 0xE3, 0x70, 0xB8, 0xDD, 0x13,
+    0x48, 0xC,  0x7B, 0x1A, 0x67, 0x64, 0x6,  0x7F, 0x29, 0x3C, 0x12, 0x29, 0x9D, 0x9E, 0x33, 0xC0,
+    0xFF, 0x79, 0x8C, 0xE7, 0x98, 0x86, 0x69, 0x99, 0x27, 0x7B, 0x39, 0x2C, 0x9B, 0x75, 0xE4, 0x7,
+    0x63, 0x4C, 0xDD, 0xD1, 0x56, 0x6E, 0x11, 0x40, 0xF6, 0x2F, 0x88, 0x6E, 0xBB, 0xA7, 0x7D, 0x35,
+    0x5,  0xBF, 0xAF, 0xFE, 0x17, 0xB6, 0xF7, 0x99, 0x2A, 0x8D, 0x36, 0xCA, 0x25, 0x60, 0x59, 0x2C,
+    0x93, 0x65, 0xE7, 0x17, 0x73, 0xC5, 0x17, 0x3F, 0x1E, 0x13, 0x0,  0x97, 0x29, 0xBC, 0x57, 0x3D,
+    0x2F, 0xC6, 0xAD, 0xD8, 0x3F, 0xFF, 0xB5, 0x13, 0x3F, 0x3E, 0xF5, 0x16, 0x62, 0xC2, 0x26, 0xC0,
+    0xD1, 0x7C, 0x74, 0x9E, 0xC0, 0x3C, 0xCC, 0xCB, 0x32, 0xEC, 0xB6, 0xAD, 0x7B, 0x27, 0x63, 0x2C,
+    0x5D, 0xB9, 0xF4, 0x73, 0xBB, 0x0,  0xF2, 0x3A, 0xA,  0xE4, 0x34, 0x2A, 0x9C, 0x8E, 0xDD, 0x8D,
+    0x83, 0xFF, 0xB9, 0x42, 0x1A, 0x75, 0x1,  0x12, 0x46, 0xBD, 0x88, 0xB8, 0x7,  0x9E, 0x96, 0x21,
+    0x7D, 0x92, 0x1,  0xFE, 0xCF, 0x63, 0x3C, 0xC7, 0x34, 0x4C, 0x9B, 0x9F, 0x7A, 0xBB, 0xA7, 0x7A,
+    0xBF, 0x5B, 0x5,  0xE0, 0xCC, 0x28, 0xA0, 0xCD, 0xB3, 0xBD, 0xDF, 0xAD, 0x2,  0xB0, 0x3A, 0xA,
+    0x68, 0x73, 0x7F, 0xEF, 0x77, 0xBB, 0x0,  0xA8, 0xDC, 0x1F, 0x7E, 0xF8, 0x41, 0xB7, 0xA2, 0x93,
+    0xC6, 0xD8, 0xB9, 0xB3, 0xF7, 0xBB, 0x5D, 0x0,  0xC4, 0xB0, 0x61, 0xC3, 0xB2, 0xDC, 0x31, 0xA4,
+    0xED, 0x2E, 0xE7, 0x41, 0x12, 0x33, 0xC6, 0xCE, 0xDD, 0xED, 0xE3, 0x76, 0x1,  0x10, 0x2B, 0x56,
+    0xAC, 0xD0, 0x2D, 0x9A, 0x47, 0x63, 0xCC, 0x3C, 0xD1, 0x36, 0x1E, 0x11, 0x0,  0x6F, 0x5E, 0xC8,
+    0xED, 0x9B, 0x42, 0x6D, 0x39, 0x7F, 0xE3, 0xE7, 0xAA, 0x1B, 0x3E, 0x94, 0x10, 0x80, 0x9E, 0x10,
+    0xAA, 0x35, 0xF1, 0xF3, 0x8A, 0x0,  0xB2, 0xFF, 0x86, 0x40, 0x5B, 0xCE, 0xE6, 0x8A, 0x7B, 0xFD,
+    0x95, 0x15, 0x0,  0x87, 0xB5, 0x13, 0x27, 0x4E, 0xE8, 0x56, 0xCE, 0xC5, 0x18, 0x1B, 0x4F, 0xD,
+    0xFD, 0x5E, 0x11, 0x80, 0xF9, 0xAC, 0x61, 0xBD, 0x2A, 0xC8, 0x79, 0xD6, 0xEF, 0xCC, 0xB3, 0x7E,
+    0x6D, 0x27, 0x80, 0x3B, 0xDD, 0x39, 0x54, 0x50, 0xCD, 0xD5, 0x77, 0xFA, 0x28, 0x2D, 0x0,  0x6E,
+    0x6E, 0xC4, 0xC5, 0xC5, 0xE9, 0x56, 0xBF, 0x61, 0x8C, 0x85, 0xBB, 0x37, 0x7C, 0x94, 0x12, 0x0,
+    0xD1, 0xB5, 0x6B, 0x57, 0x3D, 0x1F, 0xB8, 0x71, 0xDD, 0x67, 0x2C, 0xBC, 0xD5, 0xE,  0x5E, 0x13,
+    0x80, 0xF9, 0xC0, 0xC9, 0xEC, 0x3F, 0x28, 0x29, 0x48, 0x46, 0xDF, 0x9D, 0x7D, 0xC0, 0x63, 0xBE,
+    0x10, 0x0,  0x31, 0x65, 0xCA, 0x94, 0x2,  0x39, 0x29, 0xA4, 0xCF, 0xF4, 0xDD, 0xDB, 0xF1, 0xF7,
+    0xBA, 0x0,  0xCC, 0xD7, 0xD0, 0x14, 0x24, 0x11, 0xD0, 0x57, 0x67, 0x5E, 0xEF, 0x92, 0x6F, 0x5,
+    0x90, 0xD3, 0xF,  0x4C, 0xF3, 0xB3, 0xB9, 0xEA, 0x87, 0x9D, 0xF9, 0x4A, 0x0,  0xC4, 0xFC, 0xF9,
+    0xF3, 0xF3, 0xF5, 0x48, 0x40, 0xDF, 0xE8, 0xA3, 0x4A, 0x31, 0x57, 0x4A, 0x0,  0xC4, 0xB4, 0x69,
+    0xD3, 0x6E, 0xFB, 0xE3, 0x12, 0xBB, 0x1A, 0x7D, 0xA2, 0x6F, 0xAA, 0xC5, 0x5B, 0x39, 0x1,  0x10,
+    0x63, 0xC7, 0x8E, 0xCD, 0x78, 0x8,  0x65, 0x7E, 0x30, 0xFA, 0x42, 0x9F, 0x54, 0x8C, 0xB5, 0x92,
+    0x2,  0x20, 0x6,  0xC,  0x18, 0x80, 0x23, 0x47, 0x8E, 0xD8, 0xBE, 0xF1, 0xE9, 0x3,  0x7D, 0x51,
+    0x35, 0xCE, 0xCA, 0xA,  0x80, 0x68, 0xDF, 0xBE, 0xBD, 0xF1, 0x42, 0x64, 0xBB, 0x1A, 0xB9, 0xD3,
+    0x7,  0x95, 0x63, 0xAC, 0xB4, 0x0,  0x4C, 0xBC, 0xFA, 0xEA, 0xAB, 0xB6, 0x9A, 0x17, 0x90, 0x2B,
+    0x39, 0xDB, 0x21, 0xB6, 0xB6, 0x10, 0x0,  0x31, 0x64, 0xC8, 0x10, 0xEC, 0xDC, 0xB9, 0x53, 0xF9,
+    0xC6, 0x27, 0x47, 0x72, 0xB5, 0x4B, 0x5C, 0x6D, 0x23, 0x0,  0x13, 0x33, 0x67, 0xCE, 0x54, 0xF2,
+    0xF6, 0x32, 0x72, 0x22, 0x37, 0xBB, 0xC5, 0xD3, 0x76, 0x2,  0x30, 0xE7, 0x6,  0xB,  0x17, 0x2E,
+    0xC4, 0x85, 0xB,  0x17, 0xBC, 0xDE, 0xF0, 0xE4, 0x40, 0x2E, 0xAA, 0x5F, 0xEB, 0xF3, 0x95, 0x0,
+    0x32, 0xDF, 0x61, 0xC4, 0xA7, 0x65, 0x27, 0x27, 0x27, 0x7B, 0xBC, 0xE1, 0x59, 0x27, 0xEB, 0xF6,
+    0xF4, 0x1D, 0x3C, 0x5A, 0x0,  0x39, 0x20, 0x2C, 0x2C, 0xC,  0x91, 0x91, 0x91, 0x88, 0x89, 0x89,
+    0x71, 0xEB, 0x64, 0x91, 0x65, 0xB3, 0xE,  0xD6, 0xC5, 0x3A, 0xF3, 0x43, 0xEC, 0xF2, 0x85, 0x0,
+    0xB2, 0xDF, 0x67, 0xC0, 0x97, 0x28, 0xF2, 0x69, 0x1A, 0x89, 0x89, 0xD6, 0x1F, 0xFD, 0xCA, 0x32,
+    0x58, 0x16, 0xCB, 0xF4, 0xE6, 0xF7, 0xF6, 0x5A, 0x0,  0x4E, 0x82, 0xAF, 0x54, 0x67, 0x8F, 0x5D,
+    0xB0, 0x60, 0x81, 0xF1, 0x7A, 0x55, 0xBE, 0x61, 0x83, 0x8F, 0x59, 0xCD, 0x9,  0x3C, 0xC7, 0x34,
+    0x4C, 0xCB, 0x3C, 0xCE, 0xBC, 0x8E, 0x5D, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43,
+    0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,
+    0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40,
+    0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0x43, 0xB,  0x40, 0xC3, 0x7B, 0xF8, 0x37,
+    0xC2, 0xB2, 0x9,  0x1F, 0xF6, 0x7F, 0x4,  0x7E, 0x0,  0x0,  0x0,  0x0,  0x49, 0x45, 0x4E, 0x44,
+    0xAE, 0x42, 0x60, 0x82,
+};
+
+struct v3f {
+    float x = 0;
+    float y = 0;
+    float z = 0;
+};
+
+bool DynOS_Gfx_IsCappyEyesDisplayList(GfxData* aGfxData, const String& aNodeName) {
+    SysPath _Filename = fstring("%s/%s/%s__ID%X.txt", sys_exe_path(), DYNOS_FOLDER, aNodeName.begin(), aGfxData->mModelIdentifier);
+    FILE *f = fopen(_Filename.c_str(), "r");
+    if (f) { fclose(f); return true; }
+    return false;
+}
+
+static bool GetDataFromFile(GfxData* aGfxData, const String& aNodeName,
+    Array<v3f>& aPoints, Array<v3f>& aNormals, Array<v3f>& aTop,
+    size_t& aPointCount, float& aRadius, float& aFwdOffset) {
+
+    String _NodeName = aNodeName.SubString(0, aNodeName.FindLast('.'));
+    SysPath _Filename = fstring("%s/%s/%s__ID%X.txt", sys_exe_path(), DYNOS_FOLDER, _NodeName.begin(), aGfxData->mModelIdentifier);
+    FILE* _File = fopen(_Filename.c_str(), "r");
+    if (!_File) return false;
+
+    char _Buffer[256];
+    while (fgets(_Buffer, 256, _File)) {
+        Array<String> tokens = Split(_Buffer, " \t\r\n");
+        if (tokens.Empty()) continue;
+
+        if (tokens[0] == "p" && tokens.Count() >= 4) {
+            aPoints.Add({
+                tokens[1].ParseFloat(),
+                tokens[2].ParseFloat(),
+                tokens[3].ParseFloat()
+            });
+        }
+        if (tokens[0] == "n" && tokens.Count() >= 4) {
+            aNormals.Add({
+                tokens[1].ParseFloat(),
+                tokens[2].ParseFloat(),
+                tokens[3].ParseFloat()
+            });
+        }
+        if (tokens[0] == "v" && tokens.Count() >= 4) {
+            aTop.Add({
+                tokens[1].ParseFloat(),
+                tokens[2].ParseFloat(),
+                tokens[3].ParseFloat()
+            });
+        }
+        if (tokens[0] == "c" && tokens.Count() >= 2) {
+            aPointCount = (size_t) tokens[1].ParseInt();
+        }
+        if (tokens[0] == "r" && tokens.Count() >= 2) {
+            aRadius = tokens[1].ParseFloat();
+        }
+        if (tokens[0] == "f" && tokens.Count() >= 2) {
+            aFwdOffset = tokens[1].ParseFloat();
+        }
+    }
+    fclose(_File);
+
+    if (aPoints.Empty()) {
+        PrintError("  ERROR: Missing points in file \"%s\"", _Filename.c_str());
+        return false;
+    }
+    if (aNormals.Empty()) {
+        PrintError("  ERROR: Missing normals in file \"%s\"", _Filename.c_str());
+        return false;
+    }
+    if (aTop.Empty()) {
+        PrintError("  ERROR: Missing top in file \"%s\"", _Filename.c_str());
+        return false;
+    }
+    if (aPointCount == 0) {
+        aPointCount = CAPPY_EYES_POINT_COUNT;
+    }
+    if (aRadius == 0) {
+        aRadius = CAPPY_EYES_RADIUS;
+    }
+    if (aFwdOffset == 0) {
+        aFwdOffset = CAPPY_EYES_FORWARD_OFFSET;
+    }
+    return true;
+}
+
+static float GetMagnitude(const v3f& aVector) {
+    return sqrtf(
+        (aVector.x * aVector.x) +
+        (aVector.y * aVector.y) +
+        (aVector.z * aVector.z)
+    );
+}
+
+static v3f GetOrigin(const Array<v3f>& aPoints) {
+    v3f aOrigin = { 0, 0, 0 };
+    for (const v3f& p : aPoints) {
+        aOrigin.x += p.x;
+        aOrigin.y += p.y;
+        aOrigin.z += p.z;
+    }
+    aOrigin.x /= (float) aPoints.Count();
+    aOrigin.y /= (float) aPoints.Count();
+    aOrigin.z /= (float) aPoints.Count();
+    return aOrigin;
+}
+
+static v3f GetForwardAxis(const Array<v3f>& aNormals) {
+    v3f _FwdAxis = { 0, 0, 0 };
+    for (const v3f& n : aNormals) {
+        _FwdAxis.x += n.x;
+        _FwdAxis.y += n.y;
+        _FwdAxis.z += n.z;
+    }
+    float _FwdAxisMag = GetMagnitude(_FwdAxis);
+    _FwdAxis.x /= _FwdAxisMag;
+    _FwdAxis.y /= _FwdAxisMag;
+    _FwdAxis.z /= _FwdAxisMag;
+    return _FwdAxis;
+}
+
+static v3f GetVerticalAxis(const v3f& aFwdAxis, const v3f& aOrigin, const v3f& aTop) {
+
+    // Pseudo-vertical axis
+    v3f _PseudoVrtAxis = { aTop.x - aOrigin.x, aTop.y - aOrigin.y, aTop.z - aOrigin.z };
+    float _PseudoVrtAxisMag = GetMagnitude(_PseudoVrtAxis);
+    _PseudoVrtAxis.x /= _PseudoVrtAxisMag;
+    _PseudoVrtAxis.y /= _PseudoVrtAxisMag;
+    _PseudoVrtAxis.z /= _PseudoVrtAxisMag;
+
+    // True vertical axis
+    // V = pV - (pV . F) * F
+    float _PseudoVrtAxisDotFwdAxis = (_PseudoVrtAxis.x * aFwdAxis.x) + (_PseudoVrtAxis.y * aFwdAxis.y) + (_PseudoVrtAxis.z * aFwdAxis.z);
+    v3f _VrtAxis = {
+        _PseudoVrtAxis.x - _PseudoVrtAxisDotFwdAxis * aFwdAxis.x,
+        _PseudoVrtAxis.y - _PseudoVrtAxisDotFwdAxis * aFwdAxis.y,
+        _PseudoVrtAxis.z - _PseudoVrtAxisDotFwdAxis * aFwdAxis.z
+    };
+    float _VrtAxisMag = GetMagnitude(_VrtAxis);
+    _VrtAxis.x /= _VrtAxisMag;
+    _VrtAxis.y /= _VrtAxisMag;
+    _VrtAxis.z /= _VrtAxisMag;
+    return _VrtAxis;
+}
+
+static v3f GetHorizontalAxis(const v3f& aFwdAxis, const v3f& aVrtAxis) {
+
+    // Rodrigues' rotation formula with theta = -90 degrees
+    // H = (V x F) + F * (V . F)
+    float _VrtAxisDotFwdAxis = (aVrtAxis.x * aFwdAxis.x) + (aVrtAxis.y * aFwdAxis.y) + (aVrtAxis.z * aFwdAxis.z);
+    v3f _HrzAxis = {
+        (aFwdAxis.z * aVrtAxis.y) - (aFwdAxis.y * aVrtAxis.z) + aFwdAxis.x * _VrtAxisDotFwdAxis,
+        (aFwdAxis.x * aVrtAxis.z) - (aFwdAxis.z * aVrtAxis.x) + aFwdAxis.y * _VrtAxisDotFwdAxis,
+        (aFwdAxis.y * aVrtAxis.x) - (aFwdAxis.x * aVrtAxis.y) + aFwdAxis.z * _VrtAxisDotFwdAxis
+    };
+    float _HrzAxisMag = GetMagnitude(_HrzAxis);
+    _HrzAxis.x /= _HrzAxisMag;
+    _HrzAxis.y /= _HrzAxisMag;
+    _HrzAxis.z /= _HrzAxisMag;
+    return _HrzAxis;
+}
+
+//
+// Cappy eyes display list
+//
+
+static Vtx CappyEyesGetVertex(const v3f& aOrigin, const v3f& aHrzAxis, const v3f& aVrtAxis, const v3f& aFwdAxis, float aHrzValue, float aVrtValue, float aFwdValue, float aTexU, float aTexV) {
+    if (aTexU < 0) aTexU = ((aTexU + 0.5f) * CAPPY_EYES_TEXCOORDS_MULT) - 0.5f;
+    else           aTexU = ((aTexU - 0.5f) * CAPPY_EYES_TEXCOORDS_MULT) + 0.5f;
+    if (aTexV < 0) aTexV = ((aTexV + 0.5f) * CAPPY_EYES_TEXCOORDS_MULT) - 0.5f;
+    else           aTexV = ((aTexV - 0.5f) * CAPPY_EYES_TEXCOORDS_MULT) + 0.5f;
+    Vtx _Vertex = { { { 0, 0, 0 }, 0, { (short) (aTexU * 0x1000), (short) (aTexV * 0x1800) }, { (ubyte) (aFwdAxis.x * 127.f), (ubyte) (aFwdAxis.y * 127.f), (ubyte) (aFwdAxis.z * 127.f), 0xff } } };
+    _Vertex.v.ob[0] = aHrzValue * aHrzAxis.x + aVrtValue * aVrtAxis.x + aFwdValue * aFwdAxis.x + aOrigin.x;
+    _Vertex.v.ob[1] = aHrzValue * aHrzAxis.y + aVrtValue * aVrtAxis.y + aFwdValue * aFwdAxis.y + aOrigin.y;
+    _Vertex.v.ob[2] = aHrzValue * aHrzAxis.z + aVrtValue * aVrtAxis.z + aFwdValue * aFwdAxis.z + aOrigin.z;
+    return _Vertex;
+}
+
+static DataNode<Gfx>* CappyEyesGetDisplayListNode(GfxData* aGfxData, const String& aNodeName) {
+
+    // Load data from file
+    Array<v3f> _Points;
+    Array<v3f> _Normals;
+    Array<v3f> _Top;
+    size_t _PointCount = 0;
+    float _Radius = 0;
+    float _FwdOffset = 0;
+    if (!GetDataFromFile(aGfxData, aNodeName, _Points, _Normals, _Top, _PointCount, _Radius, _FwdOffset)) {
+        return NULL;
+    }
+
+    // Axes
+    v3f _Origin  = GetOrigin(_Points);
+    v3f _FwdAxis = GetForwardAxis(_Normals);
+    v3f _VrtAxis = GetVerticalAxis(_FwdAxis, _Origin, _Top[0]);
+    v3f _HrzAxis = GetHorizontalAxis(_FwdAxis, _VrtAxis);
+
+    // Offset
+    _Origin.x += _FwdAxis.x * _FwdOffset;
+    _Origin.y += _FwdAxis.y * _FwdOffset;
+    _Origin.z += _FwdAxis.z * _FwdOffset;
+
+    // Texture (loaded only once)
+    DataNode<TexData> *_TextureNode = NULL;
+    for (auto &node : aGfxData->mTextures) {
+        if (node->mName == GFX_DYN_CMD_ID "cappy_eyes_texture") {
+            _TextureNode = node;
+            break;
+        }
+    }
+    if (!_TextureNode) {
+        _TextureNode = New<DataNode<TexData>>();
+        _TextureNode->mName = GFX_DYN_CMD_ID "cappy_eyes_texture";
+        _TextureNode->mData = New<TexData>();
+        _TextureNode->mData->mPngData = Array<ubyte>(sCappyEyesTexDataPng, sCappyEyesTexDataPng + sizeof(sCappyEyesTexDataPng));
+        _TextureNode->mLoadIndex = aGfxData->mLoadIndex++;
+        aGfxData->mTextures.Add(_TextureNode);
+    }
+
+    // Vertices
+    DataNode<Vtx>* _VertexNode = New<DataNode<Vtx>>();
+    _VertexNode->mName = String(GFX_DYN_CMD_ID "cappy_eyes_vtx_%s", aNodeName.begin());
+    _VertexNode->mData = New<Vtx>(((_PointCount * 4llu) + 2llu) * 2llu);
+    _VertexNode->mSize = ((_PointCount * 4llu) + 2llu) * 2llu;
+    _VertexNode->mLoadIndex = aGfxData->mLoadIndex++;
+    Vtx* pVertex = _VertexNode->mData;
+
+    // Vertex display list
+    DataNode<Gfx>* _VertexDisplayListNode = New<DataNode<Gfx>>();
+    _VertexDisplayListNode->mName = String(GFX_DYN_CMD_ID "cappy_eyes_vtx_dl_%s", aNodeName.begin());
+    _VertexDisplayListNode->mData = New<Gfx>((((_PointCount * 4llu) + 3llu) * 2llu) + 1llu);
+    _VertexDisplayListNode->mSize = (((_PointCount * 4llu) + 3llu) * 2llu) + 1llu;
+    _VertexDisplayListNode->mLoadIndex = aGfxData->mLoadIndex++;
+    Gfx* pVertexDisplayList = _VertexDisplayListNode->mData;
+
+    // +1 for Left eye, -1 for Right eye
+    for (float sign = +1; sign >= -1; sign -= 2) {
+
+        // The eye
+        aGfxData->mPointerList.Add(pVertexDisplayList);
+        gSPVertex(pVertexDisplayList++, pVertex, _PointCount + 1, 0);
+
+        *(pVertex++) = CappyEyesGetVertex(_Origin, _HrzAxis, _VrtAxis, _FwdAxis, sign * CAPPY_EYES_GAP * (_Radius * CAPPY_EYES_WH_RATIO), 0, -(1.f - coss(0x2000)) * CAPPY_EYES_CURVE, 0.5f, 0.5f);
+        for (int i = 0; i != _PointCount; ++i) {
+            short a = (short) ((65536.f * i) / _PointCount);
+            float u = (1.f - ((1.f + sins(a)) / 2.f)) * sign - ((sign - 1.f) / 2.f);
+            float v = (1.f - ((1.f + coss(a)) / 2.f));
+            float f = (1.f - (coss((sins(-sign * a) + 1.f) * 0x2000))) * CAPPY_EYES_CURVE;
+
+            *(pVertex++) = CappyEyesGetVertex(_Origin, _HrzAxis, _VrtAxis, _FwdAxis, (sign * CAPPY_EYES_GAP - sins(a)) * (_Radius * CAPPY_EYES_WH_RATIO), coss(a) * _Radius, -f, u, v);
+
+            uint v0 = 0;
+            uint v1 = (i + 1);
+            uint v2 = (((i + 2) - 1) % _PointCount) + 1;
+            gSP1Triangle(pVertexDisplayList++, v0, v1, v2, 0);
+        }
+
+        // Border of the eye
+        aGfxData->mPointerList.Add(pVertexDisplayList);
+        gSPVertex(pVertexDisplayList++, pVertex, _PointCount * 2, 0);
+
+        for (int i = 0; i != _PointCount; ++i) {
+            short a = (short)((65536.f * i) / _PointCount);
+            float u = (1.f - ((1.f + sins(a)) / 2.f)) * sign - ((sign - 1.f) / 2.f);
+            float v = (1.f - ((1.f + coss(a)) / 2.f));
+            float f = (1.f - (coss((sins(-sign * a) + 1.f) * 0x2000))) * CAPPY_EYES_CURVE;
+
+            *(pVertex++) = CappyEyesGetVertex(_Origin, _HrzAxis, _VrtAxis, _FwdAxis, (sign * CAPPY_EYES_GAP - sins(a)) * (_Radius * CAPPY_EYES_WH_RATIO), coss(a) * _Radius, -f,                    u, v);
+            *(pVertex++) = CappyEyesGetVertex(_Origin, _HrzAxis, _VrtAxis, _FwdAxis, (sign * CAPPY_EYES_GAP - sins(a)) * (_Radius * CAPPY_EYES_WH_RATIO), coss(a) * _Radius, -f - CAPPY_EYES_DEPTH, u, v);
+
+            uint v0 = (2 * i + 0);
+            uint v1 = (2 * i + 1);
+            uint v2 = (2 * i + 2) % (_PointCount * 2);
+            uint v3 = (2 * i + 3) % (_PointCount * 2);
+            gSP1Triangle(pVertexDisplayList++, v0, v1, v2, 0);
+            gSP1Triangle(pVertexDisplayList++, v2, v1, v3, 0);
+        }
+
+        // Back of the eye
+        aGfxData->mPointerList.Add(pVertexDisplayList);
+        gSPVertex(pVertexDisplayList++, pVertex, _PointCount + 1, 0);
+
+        *(pVertex++) = CappyEyesGetVertex(_Origin, _HrzAxis, _VrtAxis, _FwdAxis, sign * CAPPY_EYES_GAP * (_Radius * CAPPY_EYES_WH_RATIO), 0, -(1.f - coss(0x2000)) * CAPPY_EYES_CURVE - CAPPY_EYES_DEPTH, 0, 0);
+        for (int i = 0; i != _PointCount; ++i) {
+            short a = (short)((65536.f * i) / _PointCount);
+            float f = (1.f - (coss((sins(-sign * a) + 1.f) * 0x2000))) * CAPPY_EYES_CURVE;
+
+            *(pVertex++) = CappyEyesGetVertex(_Origin, _HrzAxis, _VrtAxis, _FwdAxis, (sign * CAPPY_EYES_GAP - sins(a)) * (_Radius * CAPPY_EYES_WH_RATIO), coss(a) * _Radius, -f - CAPPY_EYES_DEPTH, 0, 0);
+
+            uint v0 = 0;
+            uint v1 = (i + 1);
+            uint v2 = (((i + 2) - 1) % _PointCount) + 1;
+            gSP1Triangle(pVertexDisplayList++, v0, v2, v1, 0);
+        }
+    }
+    gSPEndDisplayList(pVertexDisplayList++);
+
+    // Display list
+    DataNode<Gfx>* _DisplayListNode = New<DataNode<Gfx>>();
+    _DisplayListNode->mName = String(GFX_DYN_CMD_ID "cappy_eyes_dl_%s", aNodeName.begin());
+    _DisplayListNode->mData = New<Gfx>(0x100);
+    _DisplayListNode->mLoadIndex = aGfxData->mLoadIndex++;
+    Gfx* pDisplayList = _DisplayListNode->mData;
+
+    // Append Cappy's texture and vertices
+    gDPPipeSync(pDisplayList++);
+    gSPClearGeometryMode(pDisplayList++, METAL_BITS);
+    gDPSetCombineLERP(pDisplayList++, 0, 0, 0, TEXEL0, TEXEL0, 0, ENVIRONMENT, 0, 0, 0, 0, TEXEL0, TEXEL0, 0, ENVIRONMENT, 0);
+    gSPTexture(pDisplayList++, 0xFFFF, 0xFFFF, 0, G_TX_RENDERTILE, G_ON);
+    aGfxData->mPointerList.Add(pDisplayList);
+    gDPLoadTextureBlock(pDisplayList++, _TextureNode, G_IM_FMT_RGBA, G_IM_SIZ_32b, 128, 192, 0, 0, 0, 0, 0, 0, 0);
+    aGfxData->mPointerList.Add(pDisplayList);
+    gSPDisplayList(pDisplayList++, _VertexDisplayListNode);
+    gSPTexture(pDisplayList++, 0xFFFF, 0xFFFF, 0, G_TX_RENDERTILE, G_OFF);
+    gDPPipeSync(pDisplayList++);
+
+    // Restore previous context
+    *(pDisplayList++) = aGfxData->mGfxContext.mCombineMode;
+    *(pDisplayList++) = aGfxData->mGfxContext.mSpTexture;
+    *(pDisplayList++) = aGfxData->mGfxContext.mTxLoadTile;
+    gDPTileSync(pDisplayList++);
+    *(pDisplayList++) = aGfxData->mGfxContext.mTxRenderTile;
+    *(pDisplayList++) = aGfxData->mGfxContext.mSetTileSize;
+
+    // Metal code
+    // We assume that the last loaded texture is the metal texture
+    if (aGfxData->mGfxContext.mMetalBits.words.w1 != 0) {
+        gSPSetGeometryMode(pDisplayList++, aGfxData->mGfxContext.mMetalBits.words.w1);
+        aGfxData->mPointerList.Add(pDisplayList);
+        gDPLoadTextureBlock(pDisplayList++, aGfxData->mGfxContext.mCurrentTexture, G_IM_FMT_RGBA, G_IM_SIZ_16b, 64, 32, 0,
+            G_TX_WRAP | G_TX_NOMIRROR, G_TX_WRAP | G_TX_NOMIRROR, 6, 5, G_TX_NOLOD, G_TX_NOLOD);
+    }
+
+    // End display list
+    gSPEndDisplayList(pDisplayList++);
+    _DisplayListNode->mSize = (uint) (pDisplayList - _DisplayListNode->mData);
+
+    // Append nodes
+    aGfxData->mVertices.Add(_VertexNode);
+    aGfxData->mDisplayLists.Add(_VertexDisplayListNode);
+    aGfxData->mDisplayLists.Add(_DisplayListNode);
+    return _DisplayListNode;
+}
+
+//
+// Gfx Dynamic Commands
+//
+
+void DynOS_Gfx_PushDynCmd(GfxData* aGfxData, DataNode<Gfx>* aNode, Gfx*& aHead, ubyte aCmd) {
+	switch (aCmd) {
+
+    case GFXDYNCMD_CAPPY_EYES: {
+        DataNode<Gfx>* node = CappyEyesGetDisplayListNode(aGfxData, aNode->mName);
+        if (node) {
+            aGfxData->mGfxDynCmds.Add({ aNode->mData, (uint) (aHead - aNode->mData), GFXDYNCMD_CAPPY_EYES });
+            gDPNoOp(aHead++);
+            aGfxData->mPointerList.Add(aHead);
+            gSPDisplayList(aHead++, node);
+        }
+    } break;
+
+    }
+}
diff --git a/data/dynos_gfx_init.cpp b/data/dynos_gfx_init.cpp
new file mode 100644
index 0000000..68c0ba6
--- /dev/null
+++ b/data/dynos_gfx_init.cpp
@@ -0,0 +1,59 @@
+#include "dynos.cpp.h"
+
+Array<ActorGfx> &DynOS_Gfx_GetActorList() {
+    static Array<ActorGfx> sActorGfxList;
+    return sActorGfxList;
+}
+
+// Not recommended because Array uses memcpy to copy its data,
+// but safe since this particular array is only get by reference
+Array<SysPath> &DynOS_Gfx_GetPackList() {
+    static Array<SysPath> sPackList;
+    return sPackList;
+}
+
+Array<String> DynOS_Gfx_Init() {
+
+    // Alloc and init the actors gfx list
+    Array<ActorGfx> &pActorGfxList = DynOS_Gfx_GetActorList();
+    pActorGfxList.Resize(DynOS_Geo_GetActorCount());
+    for (int i = 0; i != DynOS_Geo_GetActorCount(); ++i) {
+        pActorGfxList[i].mPackIndex = -1;
+        pActorGfxList[i].mGfxData   = NULL;
+        pActorGfxList[i].mGraphNode = (GraphNode *) DynOS_Geo_GetGraphNode(DynOS_Geo_GetActorLayout(i), false);
+    }
+
+    // Scan the DynOS packs folder
+    Array<SysPath> &pDynosPacks = DynOS_Gfx_GetPackList();
+    SysPath _DynosPacksFolder = fstring("%s/%s", sys_exe_path(), DYNOS_PACKS_FOLDER);
+    DIR *_DynosPacksDir = opendir(_DynosPacksFolder.c_str());
+    if (_DynosPacksDir) {
+        struct dirent *_DynosPacksEnt = NULL;
+        while ((_DynosPacksEnt = readdir(_DynosPacksDir)) != NULL) {
+
+            // Skip . and ..
+            if (SysPath(_DynosPacksEnt->d_name) == ".") continue;
+            if (SysPath(_DynosPacksEnt->d_name) == "..") continue;
+
+            // If pack folder exists, add it to the pack list
+            SysPath _PackFolder = fstring("%s/%s", _DynosPacksFolder.c_str(), _DynosPacksEnt->d_name);
+            if (fs_sys_dir_exists(_PackFolder.c_str())) {
+                pDynosPacks.Add(_PackFolder);
+
+                // Scan folder for subfolders to convert into .bin files
+                DynOS_Gfx_GeneratePack(_PackFolder);
+            }
+        }
+        closedir(_DynosPacksDir);
+    }
+
+    // Return a list of pack names
+    Array<String> _PackNames;
+    for (const auto& _Pack : pDynosPacks) {
+        size_t _DirSep1 = _Pack.find_last_of('\\');
+        size_t _DirSep2 = _Pack.find_last_of('/');
+        SysPath _DirName = _Pack.substr(MAX(_DirSep1, _DirSep2) + 1);
+        _PackNames.Add(_DirName.c_str());
+    }
+    return _PackNames;
+}
diff --git a/data/dynos_gfx_load.cpp b/data/dynos_gfx_load.cpp
new file mode 100644
index 0000000..1a31d59
--- /dev/null
+++ b/data/dynos_gfx_load.cpp
@@ -0,0 +1,286 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "geo_commands.h"
+}
+
+//
+// Pointers
+//
+
+static void *GetPointerFromData(GfxData *aGfxData, const String &aPtrName, uint aPtrData) {
+
+    // Lights
+    for (auto& _Node : aGfxData->mLights) {
+        if (_Node->mName == aPtrName) {
+            if (aPtrData == 1) {
+                return (void *) &_Node->mData->l[0];
+            }
+            if (aPtrData == 2) {
+                return (void *) &_Node->mData->a;
+            }
+            sys_fatal("Unknown Light type: %u", aPtrData);
+        }
+    }
+
+    // Textures
+    for (auto& _Node : aGfxData->mTextures) {
+        if (_Node->mName == aPtrName) {
+            return (void *) _Node;
+        }
+    }
+
+    // Display lists
+    for (auto &_Node : aGfxData->mDisplayLists) {
+        if (_Node->mName == aPtrName) {
+            return (void *) _Node->mData;
+        }
+    }
+
+    // Geo layouts
+    for (auto &_Node : aGfxData->mGeoLayouts) {
+        if (_Node->mName == aPtrName) {
+            return (void *) _Node->mData;
+        }
+    }
+
+    // Vertices
+    for (auto &_Node : aGfxData->mVertices) {
+        if (_Node->mName == aPtrName) {
+            return (void *) (_Node->mData + aPtrData);
+        }
+    }
+
+    // Error
+    sys_fatal("Pointer not found: %s", aPtrName.begin());
+    return NULL;
+}
+
+static void *ReadPointer(FILE *aFile, GfxData *aGfxData, uint aValue) {
+
+    // FUNC
+    if (aValue == FUNCTION_CODE) {
+        int _GeoFunctionIndex = ReadBytes<int>(aFile);
+        return DynOS_Geo_GetFunctionPointerFromIndex(_GeoFunctionIndex);
+    }
+
+    // PNTR
+    if (aValue == POINTER_CODE) {
+        String _PtrName; _PtrName.Read(aFile);
+        uint   _PtrData = ReadBytes<uint>(aFile);
+        return GetPointerFromData(aGfxData, _PtrName, _PtrData);
+    }
+
+    // Not a pointer
+    return NULL;
+}
+
+//
+// Read binary
+//
+
+static void LoadLightData(FILE *aFile, GfxData *aGfxData) {
+    DataNode<Lights1> *_Node = New<DataNode<Lights1>>();
+
+    // Name
+    _Node->mName.Read(aFile);
+
+    // Data
+    _Node->mData = New<Lights1>();
+    *_Node->mData = ReadBytes<Lights1>(aFile);
+
+    // Append
+    aGfxData->mLights.Add(_Node);
+}
+
+static void LoadTextureData(FILE *aFile, GfxData *aGfxData) {
+    DataNode<TexData> *_Node = New<DataNode<TexData>>();
+
+    // Name
+    _Node->mName.Read(aFile);
+
+    // Data
+    _Node->mData = New<TexData>();
+    _Node->mData->mUploaded = false;
+    _Node->mData->mBind = NULL;
+    _Node->mData->mPngData.Read(aFile);
+    if (!_Node->mData->mPngData.Empty()) {
+        ubyte *_RawData = stbi_load_from_memory(_Node->mData->mPngData.begin(), _Node->mData->mPngData.Count(), &_Node->mData->mRawWidth, &_Node->mData->mRawHeight, NULL, 4);
+        _Node->mData->mRawFormat = G_IM_FMT_RGBA;
+        _Node->mData->mRawSize   = G_IM_SIZ_32b;
+        _Node->mData->mRawData   = Array<ubyte>(_RawData, _RawData + (_Node->mData->mRawWidth * _Node->mData->mRawHeight * 4));
+        free(_RawData);
+    } else { // Probably a palette
+        _Node->mData->mRawData   = Array<ubyte>();
+        _Node->mData->mRawWidth  = 0;
+        _Node->mData->mRawHeight = 0;
+        _Node->mData->mRawFormat = 0;
+        _Node->mData->mRawSize   = 0;
+    }
+
+    // Append
+    aGfxData->mTextures.Add(_Node);
+}
+
+static void LoadVertexData(FILE *aFile, GfxData *aGfxData) {
+    DataNode<Vtx> *_Node = New<DataNode<Vtx>>();
+
+    // Name
+    _Node->mName.Read(aFile);
+
+    // Data
+    _Node->mSize = ReadBytes<uint>(aFile);
+    _Node->mData = New<Vtx>(_Node->mSize);
+    for (uint i = 0; i != _Node->mSize; ++i) {
+        _Node->mData[i].n.ob[0] = ReadBytes<short>(aFile);
+        _Node->mData[i].n.ob[1] = ReadBytes<short>(aFile);
+        _Node->mData[i].n.ob[2] = ReadBytes<short>(aFile);
+        _Node->mData[i].n.flag  = ReadBytes<short>(aFile);
+        _Node->mData[i].n.tc[0] = ReadBytes<short>(aFile);
+        _Node->mData[i].n.tc[1] = ReadBytes<short>(aFile);
+        _Node->mData[i].n.n[0]  = ReadBytes<byte> (aFile);
+        _Node->mData[i].n.n[1]  = ReadBytes<byte> (aFile);
+        _Node->mData[i].n.n[2]  = ReadBytes<byte> (aFile);
+        _Node->mData[i].n.a     = ReadBytes<ubyte>(aFile);
+    }
+
+    // Append
+    aGfxData->mVertices.Add(_Node);
+}
+
+static void LoadDisplayListData(FILE *aFile, GfxData *aGfxData) {
+    DataNode<Gfx> *_Node = New<DataNode<Gfx>>();
+
+    // Name
+    _Node->mName.Read(aFile);
+
+    // Data
+    _Node->mSize = ReadBytes<uint>(aFile);
+    _Node->mData = New<Gfx>(_Node->mSize);
+    for (uint i = 0; i != _Node->mSize; ++i) {
+        uint _WordsW0 = ReadBytes<uint>(aFile);
+        uint _WordsW1 = ReadBytes<uint>(aFile);
+        void *_Ptr = ReadPointer(aFile, aGfxData, _WordsW1);
+        if (_Ptr) {
+            _Node->mData[i].words.w0 = (uintptr_t) _WordsW0;
+            _Node->mData[i].words.w1 = (uintptr_t) _Ptr;
+        } else {
+            _Node->mData[i].words.w0 = (uintptr_t) _WordsW0;
+            _Node->mData[i].words.w1 = (uintptr_t) _WordsW1;
+        }
+    }
+
+    // Append
+    aGfxData->mDisplayLists.Add(_Node);
+}
+
+static void LoadGeoLayoutData(FILE *aFile, GfxData *aGfxData) {
+    DataNode<GeoLayout> *_Node = New<DataNode<GeoLayout>>();
+
+    // Name
+    _Node->mName.Read(aFile);
+
+    // Data
+    _Node->mSize = ReadBytes<uint>(aFile);
+    _Node->mData = New<GeoLayout>(_Node->mSize);
+    for (uint i = 0; i != _Node->mSize; ++i) {
+        uint _Value = ReadBytes<uint>(aFile);
+        void *_Ptr = ReadPointer(aFile, aGfxData, _Value);
+        if (_Ptr) {
+            _Node->mData[i] = (uintptr_t) _Ptr;
+        } else {
+            _Node->mData[i] = (uintptr_t) _Value;
+        }
+    }
+
+    // Append
+    aGfxData->mGeoLayouts.Add(_Node);
+}
+
+static void LoadGfxDynCmd(FILE *aFile, GfxData *aGfxData) {
+    GfxDynCmd _Cmd;
+
+    // Data
+    String _DisplayListName; _DisplayListName.Read(aFile);
+    for (auto& _DisplayList : aGfxData->mDisplayLists) {
+        if (_DisplayList->mName == _DisplayListName) {
+            _Cmd.mData = _DisplayList->mData;
+            break;
+        }
+    }
+    if (!_Cmd.mData) {
+        sys_fatal("Display list not found: %s", _DisplayListName.begin());
+    }
+    _Cmd.mOffset = ReadBytes<uint>(aFile);
+    _Cmd.mType   = ReadBytes<ubyte>(aFile);
+
+    // Append
+    aGfxData->mGfxDynCmds.Add(_Cmd);
+}
+
+static void LoadAnimationData(FILE *aFile, GfxData *aGfxData) {
+    DataNode<AnimData> *_Node = New<DataNode<AnimData>>();
+
+    // Name
+    _Node->mName.Read(aFile);
+
+    // Data
+    _Node->mData = New<AnimData>();
+    _Node->mData->mFlags = ReadBytes<short>(aFile);
+    _Node->mData->mUnk02 = ReadBytes<short>(aFile);
+    _Node->mData->mUnk04 = ReadBytes<short>(aFile);
+    _Node->mData->mUnk06 = ReadBytes<short>(aFile);
+    _Node->mData->mUnk08 = ReadBytes<short>(aFile);
+    _Node->mData->mUnk0A.second = ReadBytes<short>(aFile);
+    _Node->mData->mLength = ReadBytes<uint>(aFile);
+    _Node->mData->mValues.second.Read(aFile);
+    _Node->mData->mIndex.second.Read(aFile);
+
+    // Append
+    aGfxData->mAnimations.Add(_Node);
+}
+
+static void LoadAnimationTable(FILE *aFile, GfxData *aGfxData) {
+    void *_AnimationPtr = NULL;
+
+    // Data
+    String _AnimationName; _AnimationName.Read(aFile);
+    if (_AnimationName != "NULL") {
+        for (auto &_AnimData : aGfxData->mAnimations) {
+            if (_AnimData->mName == _AnimationName) {
+                _AnimationPtr = (void *) _AnimData->mData;
+                break;
+            }
+        }
+        if (!_AnimationPtr) {
+            sys_fatal("Animation not found: %s", _AnimationName.begin());
+        }
+    }
+
+    // Append
+    aGfxData->mAnimationTable.Add({ "", _AnimationPtr });
+}
+
+GfxData *DynOS_Gfx_LoadFromBinary(const SysPath &aFilename) {
+    FILE *_File = fopen(aFilename.c_str(), "rb");
+    if (!_File) {
+        return NULL;
+    }
+
+    // Data
+    GfxData *_GfxData = New<GfxData>();
+    for (bool _Done = false; !_Done;) {
+        switch (ReadBytes<ubyte>(_File)) {
+            case DATA_TYPE_LIGHT:           LoadLightData      (_File, _GfxData); break;
+            case DATA_TYPE_TEXTURE:         LoadTextureData    (_File, _GfxData); break;
+            case DATA_TYPE_VERTEX:          LoadVertexData     (_File, _GfxData); break;
+            case DATA_TYPE_DISPLAY_LIST:    LoadDisplayListData(_File, _GfxData); break;
+            case DATA_TYPE_GEO_LAYOUT:      LoadGeoLayoutData  (_File, _GfxData); break;
+            case DATA_TYPE_ANIMATION:       LoadAnimationData  (_File, _GfxData); break;
+            case DATA_TYPE_ANIMATION_TABLE: LoadAnimationTable (_File, _GfxData); break;
+            case DATA_TYPE_GFXDYNCMD:       LoadGfxDynCmd      (_File, _GfxData); break;
+            default:                        _Done = true;                         break;
+        }
+    }
+    fclose(_File);
+    return _GfxData;
+}
diff --git a/data/dynos_gfx_read.cpp b/data/dynos_gfx_read.cpp
new file mode 100644
index 0000000..78f3a20
--- /dev/null
+++ b/data/dynos_gfx_read.cpp
@@ -0,0 +1,1917 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "actors/common1.h"
+#include "geo_commands.h"
+#define STB_IMAGE_WRITE_IMPLEMENTATION
+#include "stb/stb_image_write.h"
+}
+
+#define LAYER_FORCE                     0
+#define LAYER_OPAQUE                    1
+#define LAYER_OPAQUE_DECAL              2
+#define LAYER_OPAQUE_INTER              3
+#define LAYER_ALPHA                     4
+#define LAYER_TRANSPARENT               5
+#define LAYER_TRANSPARENT_DECAL         6
+#define LAYER_TRANSPARENT_INTER         7
+#define DISPLAY_LIST_SIZE_PER_TOKEN     4
+#define GEO_LAYOUT_SIZE_PER_TOKEN       4
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wnarrowing"
+
+static DataNode<Gfx>* ParseDisplayListData(GfxData* aGfxData, DataNode<Gfx>* aNode);
+static DataNode<GeoLayout>* ParseGeoLayoutData(GfxData* aGfxData, DataNode<GeoLayout>* aNode, bool aDisplayPercent);
+
+//
+// Model files
+//
+
+enum {
+    COMMENT_NONE = 0,
+    COMMENT_START,       // first slash
+    COMMENT_SINGLE_LINE, // double slash, reset to COMMENT_NONE if \\n is hit
+    COMMENT_BLOCK,       // slash-star, set to comment block end if * is hit
+    COMMENT_BLOCK_END,   // slash-star-star, set to comment none if / is hit, else return to COMMENT_BLOCK
+};
+
+struct IfDefPtr { const char *mPtr; size_t mSize; bool mErase; };
+static IfDefPtr GetNearestIfDefPointer(char *pFileBuffer) {
+    static const IfDefPtr sIfDefs[] = {
+        { "#ifdef VERSION_JP",  17, true  },
+        { "#ifndef VERSION_JP", 18, false },
+        { "#ifdef VERSION_EU",  17, true  },
+        { "#ifdef TEXTURE_FIX", 18, false },
+    };
+    IfDefPtr _Nearest = { NULL, 0, false };
+    for (const auto &_IfDef : sIfDefs) {
+        const char *_Ptr = strstr(pFileBuffer, _IfDef.mPtr);
+        if (_Ptr != NULL && (_Nearest.mPtr == NULL || _Nearest.mPtr > _Ptr)) {
+            _Nearest.mPtr = _Ptr;
+            _Nearest.mSize = _IfDef.mSize;
+            _Nearest.mErase = _IfDef.mErase;
+        }
+    }
+    return _Nearest;
+}
+
+static char *LoadFileBuffer(FILE* aFile, GfxData* aGfxData) {
+    fseek(aFile, 0, SEEK_END);
+    int _Length = ftell(aFile);
+    if (aGfxData && aGfxData->mModelIdentifier == 0) {
+        aGfxData->mModelIdentifier = (uint) _Length;
+    }
+
+    // Remove comments
+    rewind(aFile);
+    char *_FileBuffer = New<char>(_Length + 1);
+    char *pFileBuffer = _FileBuffer;
+    char _Previous = 0;
+    char _Current = 0;
+    int _CommentType = 0;
+    while (fread(&_Current, 1, 1, aFile)) {
+        if (_CommentType == COMMENT_NONE) {
+            if (_Current == '/') {
+                _CommentType = COMMENT_START;
+            } else {
+                *(pFileBuffer++) = _Current;
+            }
+        } else if (_CommentType == COMMENT_START) {
+            if (_Current == '/') {
+                _CommentType = COMMENT_SINGLE_LINE;
+            } else if (_Current == '*') {
+                _CommentType = COMMENT_BLOCK;
+            } else {
+                _CommentType = COMMENT_NONE;
+                *(pFileBuffer++) = _Previous;
+                *(pFileBuffer++) = _Current;
+            }
+        } else if (_CommentType == COMMENT_SINGLE_LINE) {
+            if (_Current == '\n') {
+                _CommentType = COMMENT_NONE;
+                *(pFileBuffer++) = _Current;
+            }
+        } else if (_CommentType == COMMENT_BLOCK) {
+            if (_Current == '*') {
+                _CommentType = COMMENT_BLOCK_END;
+            }
+        } else if (_CommentType == COMMENT_BLOCK_END) {
+            if (_Current == '/') {
+                _CommentType = COMMENT_NONE;
+            } else {
+                _CommentType = COMMENT_BLOCK;
+            }
+        }
+        _Previous = _Current;
+    }
+    *(pFileBuffer++) = 0;
+
+    // Remove ifdef blocks
+    // Doesn't support nested blocks
+    for (pFileBuffer = _FileBuffer; pFileBuffer != NULL;) {
+        IfDefPtr _IfDefPtr = GetNearestIfDefPointer(pFileBuffer);
+        if (_IfDefPtr.mPtr) {
+            char *pIfDef = (char *) _IfDefPtr.mPtr;
+            char *pElse  = (char *) strstr(_IfDefPtr.mPtr, "#else");
+            char *pEndIf = (char *) strstr(_IfDefPtr.mPtr, "#endif");
+
+            if (pElse && pElse < pEndIf) {
+                if (_IfDefPtr.mErase) memset(pIfDef, ' ', pElse + 5 - pIfDef);
+                else                  memset(pElse,  ' ', pEndIf - pElse);
+            } else {
+                if (_IfDefPtr.mErase) memset(pIfDef, ' ', pEndIf - pIfDef);
+            }
+
+            memset(pIfDef, ' ', _IfDefPtr.mSize);
+            memset(pEndIf, ' ', 6);
+            pFileBuffer = pEndIf;
+        } else {
+            pFileBuffer = NULL;
+        }
+    }
+
+    return _FileBuffer;
+}
+
+template <typename T>
+static void AppendNewNode(GfxData *aGfxData, DataNodes<T> &aNodes, const String &aName, String *&aDataName, Array<String> *&aDataTokens) {
+    DataNode<T> *_Node = New<DataNode<T>>();
+    _Node->mName = aName;
+    _Node->mModelIdentifier = aGfxData->mModelIdentifier;
+    aNodes.Add(_Node);
+    aDataName = &_Node->mName;
+    aDataTokens = &_Node->mTokens;
+}
+
+static void ScanModelFile(GfxData *aGfxData, const SysPath &aFilename) {
+    FILE *_File = fopen(aFilename.c_str(), "rb");
+    if (!_File) return;
+
+    // Load file into a buffer while removing all comments
+    char *_FileBuffer = LoadFileBuffer(_File, aGfxData);
+    fclose(_File);
+
+    // Scanning the loaded data
+    int _DataType = DATA_TYPE_NONE;
+    String* pDataName = NULL;
+    Array<String> *pDataTokens = NULL;
+    char *pDataStart = NULL;
+    bool _DataIgnore = false; // Needed to ignore the '#include "file.h"' strings
+    String _Buffer = "";
+    for (char *c = _FileBuffer; *c != 0; ++c) {
+
+        // Scanning data type
+        if (_DataType == DATA_TYPE_NONE) {
+
+            // Reading data type name
+            if ((*c >= 'A' && *c <= 'Z') || (*c >= 'a' && *c <= 'z') || (*c >= '0' && *c <= '9') || (*c == '_') || (*c == '\"')) {
+                if (*c == '\"') {
+                    _DataIgnore = !_DataIgnore;
+                } else if (!_DataIgnore) {
+                    _Buffer.Add(*c);
+                }
+            }
+
+            // Retrieving data type
+            else if (_Buffer.Length() != 0) {
+                if (_Buffer == "static") {
+                    // Ignore static keyword
+                } else if (_Buffer == "const") {
+                    // Ignore const keyword
+                } else if (_Buffer == "inline") {
+                    // Ignore inline keyword
+                } else if (_Buffer == "include") {
+                    // Ignore include keyword
+                } else if (_Buffer == "ALIGNED8") {
+                    // Ignore ALIGNED8 keyword
+                } else if (_Buffer == "UNUSED") {
+                    // Ignore UNUSED keyword
+                } else if (_Buffer == "u64") {
+                    _DataType = DATA_TYPE_UNUSED;
+                } else if (_Buffer == "Lights1") {
+                    _DataType = DATA_TYPE_LIGHT;
+                } else if (_Buffer == "u8") {
+                    _DataType = DATA_TYPE_TEXTURE;
+                } else if (_Buffer == "Vtx") {
+                    _DataType = DATA_TYPE_VERTEX;
+                } else if (_Buffer == "Gfx") {
+                    _DataType = DATA_TYPE_DISPLAY_LIST;
+                } else if (_Buffer == "GeoLayout") {
+                    _DataType = DATA_TYPE_GEO_LAYOUT;
+                } else {
+                    PrintError("  ERROR: Unknown type name: %s", _Buffer.begin());
+                }
+                _Buffer.Clear();
+            }
+        }
+
+        // Scanning data identifier
+        else if (!pDataTokens) {
+
+            // Reading data identifier name
+            if ((*c >= 'A' && *c <= 'Z') || (*c >= 'a' && *c <= 'z') || (*c >= '0' && *c <= '9') || (*c == '_')) {
+                _Buffer.Add(*c);
+            }
+
+            // Adding new data node
+            else if (_Buffer.Length() != 0) {
+                switch (_DataType) {
+                    case DATA_TYPE_LIGHT:        AppendNewNode(aGfxData, aGfxData->mLights,       _Buffer, pDataName, pDataTokens); break;
+                    case DATA_TYPE_TEXTURE:      AppendNewNode(aGfxData, aGfxData->mTextures,     _Buffer, pDataName, pDataTokens); break;
+                    case DATA_TYPE_VERTEX:       AppendNewNode(aGfxData, aGfxData->mVertices,     _Buffer, pDataName, pDataTokens); break;
+                    case DATA_TYPE_DISPLAY_LIST: AppendNewNode(aGfxData, aGfxData->mDisplayLists, _Buffer, pDataName, pDataTokens); break;
+                    case DATA_TYPE_GEO_LAYOUT:   AppendNewNode(aGfxData, aGfxData->mGeoLayouts,   _Buffer, pDataName, pDataTokens); break;
+                    case DATA_TYPE_UNUSED:       pDataTokens = (Array<String> *) 1;                                                 break;
+                }
+                _Buffer.Clear();
+            }
+        }
+
+        // Looking for data
+        else if (pDataStart == 0) {
+            if (*c == '=') {
+                pDataStart = c + 1;
+            } else if (*c == ';') {
+                PrintError("  ERROR: %s: Unexpected end of data", pDataName->begin());
+            }
+        }
+
+        // Data end
+        else if (*c == ';') {
+            if (_DataType != DATA_TYPE_UNUSED) {
+                char* pDataEnd = &*c;
+                String _Token = "";
+                for (ubyte _Bracket = 0; pDataStart <= pDataEnd; pDataStart++) {
+                    if (*pDataStart == '(') _Bracket++;
+                    if (*pDataStart == ' ' || *pDataStart == '\t' || *pDataStart == '\r' || *pDataStart == '\n') continue;
+                    if (_Bracket <= 1 && (*pDataStart == '(' || *pDataStart == ')' || *pDataStart == ',' || *pDataStart == '{' || *pDataStart == '}' || *pDataStart == ';')) {
+                        if (_Token.Length() != 0) {
+                            pDataTokens->Add(_Token);
+                            _Token.Clear();
+                        }
+                    } else {
+                        _Token.Add(*pDataStart);
+                    }
+                    if (*pDataStart == ')') _Bracket--;
+                }
+            }
+            _DataType   = DATA_TYPE_NONE;
+            pDataName   = NULL;
+            pDataTokens = NULL;
+            pDataStart  = NULL;
+            _DataIgnore = false;
+            _Buffer     = "";
+        }
+    }
+
+    Delete(_FileBuffer);
+    Print("Data read from file \"%s\"", aFilename.c_str());
+}
+
+//
+// Lights
+//
+
+static DataNode<Lights1>* ParseLightData(GfxData* aGfxData, DataNode<Lights1>* aNode) {
+    if (aNode->mData) return aNode;
+
+    // Check tokens count
+    if (aNode->mTokens.Count() < 10) {
+        PrintError("  ERROR: %s: not enough data", aNode->mName.begin());
+        return aNode;
+    }
+
+    // Parse def token
+    if (aNode->mTokens[0] != "gdSPDefLights1") {
+        PrintError("  ERROR: Invalid def token: should be gdSPDefLights1, is %s", aNode->mTokens[0].begin());
+        return aNode;
+    }
+
+    // Parse data tokens
+    ubyte ar = (ubyte) aNode->mTokens[1].ParseInt();
+    ubyte ag = (ubyte) aNode->mTokens[2].ParseInt();
+    ubyte ab = (ubyte) aNode->mTokens[3].ParseInt();
+    ubyte r1 = (ubyte) aNode->mTokens[4].ParseInt();
+    ubyte g1 = (ubyte) aNode->mTokens[5].ParseInt();
+    ubyte b1 = (ubyte) aNode->mTokens[6].ParseInt();
+    byte  x1 = (byte)  aNode->mTokens[7].ParseInt();
+    byte  y1 = (byte)  aNode->mTokens[8].ParseInt();
+    byte  z1 = (byte)  aNode->mTokens[9].ParseInt();
+    aNode->mData = New<Lights1>();
+    *aNode->mData = gdSPDefLights1(ar, ag, ab, r1, g1, b1, x1, y1, z1);
+    aNode->mLoadIndex = aGfxData->mLoadIndex++;
+    return aNode;
+}
+
+//
+// Textures
+//
+
+static TexData* LoadTextureFromFile(GfxData *aGfxData, const String& aFile) {
+
+    // Image file
+    String _TexturePath = aFile.SubString(aFile.Find('/') + 1); // Remove the "actors/"
+    SysPath _Filename = fstring("%s/%s.png", aGfxData->mPackFolder.c_str(), _TexturePath.begin());
+    FILE *_File = fopen(_Filename.c_str(), "rb");
+    if (!_File) {
+        PrintError("  ERROR: Unable to open file \"%s\"", _Filename.c_str());
+        return NULL;
+    }
+
+    // Texture data
+    fseek(_File, 0, SEEK_END);
+    TexData* _Texture = New<TexData>();
+    _Texture->mPngData.Resize(ftell(_File)); rewind(_File);
+    fread(_Texture->mPngData.begin(), sizeof(ubyte), _Texture->mPngData.Count(), _File);
+    fclose(_File);
+    return _Texture;
+}
+
+static void ConvertTextureDataToPng(GfxData *aGfxData, TexData* aTexture) {
+
+    // Convert to RGBA32
+    const ubyte *_Palette = (aGfxData->mGfxContext.mCurrentPalette ? aGfxData->mGfxContext.mCurrentPalette->mData->mRawData.begin() : NULL);
+    ubyte *_Buffer = ConvertToRGBA32(aTexture->mRawData.begin(), aTexture->mRawData.Count(), aTexture->mRawFormat, aTexture->mRawSize, _Palette);
+    if (_Buffer == NULL) {
+        PrintError("  ERROR: Unknown texture format");
+        return;
+    }
+
+    // Convert to PNG
+    int _PngLength = 0;
+    ubyte *_PngData = stbi_write_png_to_mem(_Buffer, 0, aTexture->mRawWidth, aTexture->mRawHeight, 4, &_PngLength);
+    if (!_PngData || !_PngLength) {
+        PrintError("  ERROR: Cannot convert texture to PNG");
+        return;
+    }
+
+    aTexture->mPngData = Array<ubyte>(_PngData, _PngData + _PngLength);
+    Delete(_PngData);
+}
+
+static DataNode<TexData>* ParseTextureData(GfxData* aGfxData, DataNode<TexData>* aNode) {
+    if (aNode->mData) return aNode;
+
+    // Check tokens Count
+    if (aNode->mTokens.Count() < 1) {
+        PrintError("  ERROR: %s: not enough data", aNode->mName.begin());
+        return aNode;
+    }
+
+    // #include"[texture].inc.c"
+    int i0 = aNode->mTokens[0].Find("#include");
+    if (i0 != -1) {
+        int i1 = aNode->mTokens[0].Find(".inc.c");
+        if (i1 == -1) {
+            PrintError("  ERROR: %s: missing .inc.c in String %s", aNode->mName.begin(), aNode->mTokens[0].begin());
+            return aNode;
+        }
+
+        // Filename
+        String _Filename  = aNode->mTokens[0].SubString(i0 + 9, i1 - i0 - 9);
+        aNode->mData      = LoadTextureFromFile(aGfxData, _Filename);
+        aNode->mLoadIndex = aGfxData->mLoadIndex++;
+        return aNode;
+    }
+
+    // double quoted String
+    int dq0 = aNode->mTokens[0].Find('\"');
+    if (dq0 != -1) {
+        int dq1 = aNode->mTokens[0].Find('\"', dq0 + 1);
+        if (dq1 == -1) {
+            PrintError("  ERROR: %s: missing second quote in String %s", aNode->mName.begin(), aNode->mTokens[0].begin());
+            return aNode;
+        }
+
+        // Filename
+        String _Filename  = aNode->mTokens[0].SubString(dq0 + 1, dq1 - dq0 - 1);
+        aNode->mData      = LoadTextureFromFile(aGfxData, _Filename);
+        aNode->mLoadIndex = aGfxData->mLoadIndex++;
+        return aNode;
+    }
+
+    // Stream of bytes
+    aNode->mData              = New<TexData>();
+    aNode->mData->mRawWidth   = -1; // Unknown for now, will be set later
+    aNode->mData->mRawHeight  = -1; // Unknown for now, will be set later
+    aNode->mData->mRawFormat  = -1; // Unknown for now, will be set later
+    aNode->mData->mRawSize    = -1; // Unknown for now, will be set later
+    aNode->mData->mRawData.Resize(aNode->mTokens.Count());
+    for (size_t j = 0; j != aNode->mTokens.Count(); ++j) {
+    aNode->mData->mRawData[j] = aNode->mTokens[j].ParseInt();
+    }
+    aNode->mLoadIndex         = aGfxData->mLoadIndex++;
+    return aNode;
+}
+
+//
+// Vertices
+//
+
+static DataNode<Vtx>* ParseVertexData(GfxData* aGfxData, DataNode<Vtx>* aNode) {
+    if (aNode->mData) return aNode;
+
+    // Vertex data
+    aNode->mSize = (uint) (aNode->mTokens.Count() / 10);
+    aNode->mData = New<Vtx>(aNode->mSize);
+    for (uint i = 0; i != aNode->mSize; ++i) {
+        float px = (float) aNode->mTokens[10 * i + 0].ParseFloat();
+        float py = (float) aNode->mTokens[10 * i + 1].ParseFloat();
+        float pz = (float) aNode->mTokens[10 * i + 2].ParseFloat();
+        ubyte fl = (ubyte) aNode->mTokens[10 * i + 3].ParseInt();
+        short tu = (short) aNode->mTokens[10 * i + 4].ParseInt();
+        short tv = (short) aNode->mTokens[10 * i + 5].ParseInt();
+        ubyte nx = (ubyte) aNode->mTokens[10 * i + 6].ParseInt();
+        ubyte ny = (ubyte) aNode->mTokens[10 * i + 7].ParseInt();
+        ubyte nz = (ubyte) aNode->mTokens[10 * i + 8].ParseInt();
+        ubyte a  = (ubyte) aNode->mTokens[10 * i + 9].ParseInt();
+        aNode->mData[i] = { { { px, py, pz }, fl, { tu, tv }, { nx, ny, nz, a } } };
+    }
+    aNode->mLoadIndex = aGfxData->mLoadIndex++;
+    return aNode;
+}
+
+//
+// Display lists
+//
+
+#define gfx_constant(x) if (_Arg == #x) { return (slong) (x); }
+static slong ParseGfxSymbolArg(GfxData* aGfxData, DataNode<Gfx>* aNode, size_t* pTokenIndex, const char *aPrefix) {
+    assert(aPrefix != NULL);
+    String _Token = (pTokenIndex != NULL ? aNode->mTokens[(*pTokenIndex)++] : "");
+    String _Arg("%s%s", aPrefix, _Token.begin());
+
+    // Offset
+    int _Offset = 0;
+    int _Plus = _Arg.Find('+');
+    if (_Plus != -1) {
+        _Offset = _Arg.SubString(_Plus + 1).ParseInt();
+        _Arg = _Arg.SubString(0, _Plus);
+    }
+
+    // Constants
+    gfx_constant(NULL);
+    gfx_constant(G_ON);
+    gfx_constant(G_OFF);
+
+    // Combine modes
+    gfx_constant(G_CCMUX_COMBINED);
+    gfx_constant(G_CCMUX_TEXEL0);
+    gfx_constant(G_CCMUX_TEXEL1);
+    gfx_constant(G_CCMUX_PRIMITIVE);
+    gfx_constant(G_CCMUX_SHADE);
+    gfx_constant(G_CCMUX_ENVIRONMENT);
+    gfx_constant(G_CCMUX_CENTER);
+    gfx_constant(G_CCMUX_SCALE);
+    gfx_constant(G_CCMUX_COMBINED_ALPHA);
+    gfx_constant(G_CCMUX_TEXEL0_ALPHA);
+    gfx_constant(G_CCMUX_TEXEL1_ALPHA);
+    gfx_constant(G_CCMUX_PRIMITIVE_ALPHA);
+    gfx_constant(G_CCMUX_SHADE_ALPHA);
+    gfx_constant(G_CCMUX_ENV_ALPHA);
+    gfx_constant(G_CCMUX_LOD_FRACTION);
+    gfx_constant(G_CCMUX_PRIM_LOD_FRAC);
+    gfx_constant(G_CCMUX_NOISE);
+    gfx_constant(G_CCMUX_K4);
+    gfx_constant(G_CCMUX_K5);
+    gfx_constant(G_CCMUX_1);
+    gfx_constant(G_CCMUX_0);
+    gfx_constant(G_ACMUX_COMBINED);
+    gfx_constant(G_ACMUX_TEXEL0);
+    gfx_constant(G_ACMUX_TEXEL1);
+    gfx_constant(G_ACMUX_PRIMITIVE);
+    gfx_constant(G_ACMUX_SHADE);
+    gfx_constant(G_ACMUX_ENVIRONMENT);
+    gfx_constant(G_ACMUX_LOD_FRACTION);
+    gfx_constant(G_ACMUX_PRIM_LOD_FRAC);
+    gfx_constant(G_ACMUX_1);
+    gfx_constant(G_ACMUX_0);
+
+    // Light constants
+    gfx_constant(NUMLIGHTS_0);
+    gfx_constant(NUMLIGHTS_1);
+    gfx_constant(NUMLIGHTS_2);
+    gfx_constant(NUMLIGHTS_3);
+    gfx_constant(NUMLIGHTS_4);
+    gfx_constant(NUMLIGHTS_5);
+    gfx_constant(NUMLIGHTS_6);
+    gfx_constant(NUMLIGHTS_7);
+
+    // Image formats
+    gfx_constant(G_IM_FMT_RGBA);
+    gfx_constant(G_IM_FMT_YUV);
+    gfx_constant(G_IM_FMT_CI);
+    gfx_constant(G_IM_FMT_IA);
+    gfx_constant(G_IM_FMT_I);
+    gfx_constant(G_IM_SIZ_4b);
+    gfx_constant(G_IM_SIZ_8b);
+    gfx_constant(G_IM_SIZ_16b);
+    gfx_constant(G_IM_SIZ_32b);
+    gfx_constant(G_IM_SIZ_DD);
+
+    // Image constants
+    gfx_constant(G_IM_SIZ_4b_BYTES);
+    gfx_constant(G_IM_SIZ_4b_TILE_BYTES);
+    gfx_constant(G_IM_SIZ_4b_LINE_BYTES);
+    gfx_constant(G_IM_SIZ_8b_BYTES);
+    gfx_constant(G_IM_SIZ_8b_TILE_BYTES);
+    gfx_constant(G_IM_SIZ_8b_LINE_BYTES);
+    gfx_constant(G_IM_SIZ_16b_BYTES);
+    gfx_constant(G_IM_SIZ_16b_TILE_BYTES);
+    gfx_constant(G_IM_SIZ_16b_LINE_BYTES);
+    gfx_constant(G_IM_SIZ_32b_BYTES);
+    gfx_constant(G_IM_SIZ_32b_TILE_BYTES);
+    gfx_constant(G_IM_SIZ_32b_LINE_BYTES);
+    gfx_constant(G_IM_SIZ_4b_LOAD_BLOCK);
+    gfx_constant(G_IM_SIZ_8b_LOAD_BLOCK);
+    gfx_constant(G_IM_SIZ_16b_LOAD_BLOCK);
+    gfx_constant(G_IM_SIZ_32b_LOAD_BLOCK);
+    gfx_constant(G_IM_SIZ_4b_SHIFT);
+    gfx_constant(G_IM_SIZ_8b_SHIFT);
+    gfx_constant(G_IM_SIZ_16b_SHIFT);
+    gfx_constant(G_IM_SIZ_32b_SHIFT);
+    gfx_constant(G_IM_SIZ_4b_INCR);
+    gfx_constant(G_IM_SIZ_8b_INCR);
+    gfx_constant(G_IM_SIZ_16b_INCR);
+    gfx_constant(G_IM_SIZ_32b_INCR);
+
+    // Tile formats
+    gfx_constant(G_TX_RENDERTILE);
+    gfx_constant(G_TX_LOADTILE);
+    gfx_constant(G_TX_NOMIRROR);
+    gfx_constant(G_TX_WRAP);
+    gfx_constant(G_TX_MIRROR);
+    gfx_constant(G_TX_CLAMP);
+    gfx_constant(G_TX_NOMASK);
+    gfx_constant(G_TX_NOLOD);
+    gfx_constant(G_TX_WRAP|G_TX_NOMIRROR);
+    gfx_constant(G_TX_WRAP|G_TX_MIRROR);
+    gfx_constant(G_TX_CLAMP|G_TX_NOMIRROR);
+    gfx_constant(G_TX_CLAMP|G_TX_MIRROR);
+
+    // Render modes
+    gfx_constant(G_RM_AA_ZB_OPA_SURF);
+    gfx_constant(G_RM_AA_ZB_OPA_SURF2);
+    gfx_constant(G_RM_AA_ZB_XLU_SURF);
+    gfx_constant(G_RM_AA_ZB_XLU_SURF2);
+    gfx_constant(G_RM_AA_ZB_OPA_DECAL);
+    gfx_constant(G_RM_AA_ZB_OPA_DECAL2);
+    gfx_constant(G_RM_AA_ZB_XLU_DECAL);
+    gfx_constant(G_RM_AA_ZB_XLU_DECAL2);
+    gfx_constant(G_RM_AA_ZB_OPA_INTER);
+    gfx_constant(G_RM_AA_ZB_OPA_INTER2);
+    gfx_constant(G_RM_AA_ZB_XLU_INTER);
+    gfx_constant(G_RM_AA_ZB_XLU_INTER2);
+    gfx_constant(G_RM_AA_ZB_XLU_LINE);
+    gfx_constant(G_RM_AA_ZB_XLU_LINE2);
+    gfx_constant(G_RM_AA_ZB_DEC_LINE);
+    gfx_constant(G_RM_AA_ZB_DEC_LINE2);
+    gfx_constant(G_RM_AA_ZB_TEX_EDGE);
+    gfx_constant(G_RM_AA_ZB_TEX_EDGE2);
+    gfx_constant(G_RM_AA_ZB_TEX_INTER);
+    gfx_constant(G_RM_AA_ZB_TEX_INTER2);
+    gfx_constant(G_RM_AA_ZB_SUB_SURF);
+    gfx_constant(G_RM_AA_ZB_SUB_SURF2);
+    gfx_constant(G_RM_AA_ZB_PCL_SURF);
+    gfx_constant(G_RM_AA_ZB_PCL_SURF2);
+    gfx_constant(G_RM_AA_ZB_OPA_TERR);
+    gfx_constant(G_RM_AA_ZB_OPA_TERR2);
+    gfx_constant(G_RM_AA_ZB_TEX_TERR);
+    gfx_constant(G_RM_AA_ZB_TEX_TERR2);
+    gfx_constant(G_RM_AA_ZB_SUB_TERR);
+    gfx_constant(G_RM_AA_ZB_SUB_TERR2);
+    gfx_constant(G_RM_RA_ZB_OPA_SURF);
+    gfx_constant(G_RM_RA_ZB_OPA_SURF2);
+    gfx_constant(G_RM_RA_ZB_OPA_DECAL);
+    gfx_constant(G_RM_RA_ZB_OPA_DECAL2);
+    gfx_constant(G_RM_RA_ZB_OPA_INTER);
+    gfx_constant(G_RM_RA_ZB_OPA_INTER2);
+    gfx_constant(G_RM_AA_OPA_SURF);
+    gfx_constant(G_RM_AA_OPA_SURF2);
+    gfx_constant(G_RM_AA_XLU_SURF);
+    gfx_constant(G_RM_AA_XLU_SURF2);
+    gfx_constant(G_RM_AA_XLU_LINE);
+    gfx_constant(G_RM_AA_XLU_LINE2);
+    gfx_constant(G_RM_AA_DEC_LINE);
+    gfx_constant(G_RM_AA_DEC_LINE2);
+    gfx_constant(G_RM_AA_TEX_EDGE);
+    gfx_constant(G_RM_AA_TEX_EDGE2);
+    gfx_constant(G_RM_AA_SUB_SURF);
+    gfx_constant(G_RM_AA_SUB_SURF2);
+    gfx_constant(G_RM_AA_PCL_SURF);
+    gfx_constant(G_RM_AA_PCL_SURF2);
+    gfx_constant(G_RM_AA_OPA_TERR);
+    gfx_constant(G_RM_AA_OPA_TERR2);
+    gfx_constant(G_RM_AA_TEX_TERR);
+    gfx_constant(G_RM_AA_TEX_TERR2);
+    gfx_constant(G_RM_AA_SUB_TERR);
+    gfx_constant(G_RM_AA_SUB_TERR2);
+    gfx_constant(G_RM_RA_OPA_SURF);
+    gfx_constant(G_RM_RA_OPA_SURF2);
+    gfx_constant(G_RM_ZB_OPA_SURF);
+    gfx_constant(G_RM_ZB_OPA_SURF2);
+    gfx_constant(G_RM_ZB_XLU_SURF);
+    gfx_constant(G_RM_ZB_XLU_SURF2);
+    gfx_constant(G_RM_ZB_OPA_DECAL);
+    gfx_constant(G_RM_ZB_OPA_DECAL2);
+    gfx_constant(G_RM_ZB_XLU_DECAL);
+    gfx_constant(G_RM_ZB_XLU_DECAL2);
+    gfx_constant(G_RM_ZB_CLD_SURF);
+    gfx_constant(G_RM_ZB_CLD_SURF2);
+    gfx_constant(G_RM_ZB_OVL_SURF);
+    gfx_constant(G_RM_ZB_OVL_SURF2);
+    gfx_constant(G_RM_ZB_PCL_SURF);
+    gfx_constant(G_RM_ZB_PCL_SURF2);
+    gfx_constant(G_RM_OPA_SURF);
+    gfx_constant(G_RM_OPA_SURF2);
+    gfx_constant(G_RM_XLU_SURF);
+    gfx_constant(G_RM_XLU_SURF2);
+    gfx_constant(G_RM_CLD_SURF);
+    gfx_constant(G_RM_CLD_SURF2);
+    gfx_constant(G_RM_TEX_EDGE);
+    gfx_constant(G_RM_TEX_EDGE2);
+    gfx_constant(G_RM_PCL_SURF);
+    gfx_constant(G_RM_PCL_SURF2);
+    gfx_constant(G_RM_ADD);
+    gfx_constant(G_RM_ADD2);
+    gfx_constant(G_RM_NOOP);
+    gfx_constant(G_RM_NOOP2);
+    gfx_constant(G_RM_VISCVG);
+    gfx_constant(G_RM_VISCVG2);
+    gfx_constant(G_RM_OPA_CI);
+    gfx_constant(G_RM_OPA_CI2);
+    gfx_constant(G_RM_CUSTOM_AA_ZB_XLU_SURF);
+    gfx_constant(G_RM_CUSTOM_AA_ZB_XLU_SURF2);
+    gfx_constant(G_RM_FOG_SHADE_A);
+    gfx_constant(G_RM_FOG_PRIM_A);
+    gfx_constant(G_RM_PASS);
+
+    // Geometry modes
+    gfx_constant(G_ZBUFFER);
+    gfx_constant(G_SHADE);
+    gfx_constant(G_TEXTURE_ENABLE);
+    gfx_constant(G_SHADING_SMOOTH);
+    gfx_constant(G_CULL_FRONT);
+    gfx_constant(G_CULL_BACK);
+    gfx_constant(G_CULL_BOTH);
+    gfx_constant(G_FOG);
+    gfx_constant(G_LIGHTING);
+    gfx_constant(G_TEXTURE_GEN);
+    gfx_constant(G_TEXTURE_GEN_LINEAR);
+    gfx_constant(G_LOD);
+    gfx_constant(G_CLIPPING);
+    gfx_constant(G_FOG|G_TEXTURE_GEN);
+    gfx_constant(G_LIGHTING|G_CULL_BACK);
+    gfx_constant(G_LIGHTING|G_SHADING_SMOOTH);
+    gfx_constant(G_CULL_BACK|G_SHADING_SMOOTH);
+    gfx_constant(G_LIGHTING|G_CULL_BACK|G_SHADING_SMOOTH);
+    gfx_constant(G_TEXTURE_GEN|G_SHADING_SMOOTH);
+    gfx_constant(G_TEXTURE_GEN|G_LIGHTING|G_CULL_BACK);
+    gfx_constant(G_TEXTURE_GEN|G_CULL_BACK|G_SHADING_SMOOTH);
+
+    // Alpha modes
+    gfx_constant(G_AC_NONE);
+    gfx_constant(G_AC_THRESHOLD);
+    gfx_constant(G_AC_DITHER);
+
+    // Other modes
+    gfx_constant(G_MDSFT_ALPHACOMPARE);
+    gfx_constant(G_MDSFT_ZSRCSEL);
+    gfx_constant(G_MDSFT_RENDERMODE);
+    gfx_constant(G_MDSFT_BLENDER);
+    gfx_constant(G_MDSFT_BLENDMASK);
+    gfx_constant(G_MDSFT_ALPHADITHER);
+    gfx_constant(G_MDSFT_RGBDITHER);
+    gfx_constant(G_MDSFT_COMBKEY);
+    gfx_constant(G_MDSFT_TEXTCONV);
+    gfx_constant(G_MDSFT_TEXTFILT);
+    gfx_constant(G_MDSFT_TEXTLUT);
+    gfx_constant(G_MDSFT_TEXTLOD);
+    gfx_constant(G_MDSFT_TEXTDETAIL);
+    gfx_constant(G_MDSFT_TEXTPERSP);
+    gfx_constant(G_MDSFT_CYCLETYPE);
+    gfx_constant(G_MDSFT_COLORDITHER);
+    gfx_constant(G_MDSFT_PIPELINE);
+    gfx_constant(G_PM_1PRIMITIVE);
+    gfx_constant(G_PM_NPRIMITIVE);
+    gfx_constant(G_CYC_1CYCLE);
+    gfx_constant(G_CYC_2CYCLE);
+    gfx_constant(G_CYC_COPY);
+    gfx_constant(G_CYC_FILL);
+    gfx_constant(G_TP_NONE);
+    gfx_constant(G_TP_PERSP);
+    gfx_constant(G_TD_CLAMP);
+    gfx_constant(G_TD_SHARPEN);
+    gfx_constant(G_TD_DETAIL);
+    gfx_constant(G_TL_TILE);
+    gfx_constant(G_TL_LOD);
+    gfx_constant(G_TT_NONE);
+    gfx_constant(G_TT_RGBA16);
+    gfx_constant(G_TT_IA16);
+    gfx_constant(G_TF_POINT);
+    gfx_constant(G_TF_AVERAGE);
+    gfx_constant(G_TF_BILERP);
+    gfx_constant(G_TC_CONV);
+    gfx_constant(G_TC_FILTCONV);
+    gfx_constant(G_TC_FILT);
+    gfx_constant(G_CK_NONE);
+    gfx_constant(G_CK_KEY);
+    gfx_constant(G_CD_MAGICSQ);
+    gfx_constant(G_CD_BAYER);
+    gfx_constant(G_CD_NOISE);
+    gfx_constant(G_CD_DISABLE);
+    gfx_constant(G_CD_ENABLE);
+    gfx_constant(G_AD_PATTERN);
+    gfx_constant(G_AD_NOTPATTERN);
+    gfx_constant(G_AD_NOISE);
+    gfx_constant(G_AD_DISABLE);
+    gfx_constant(G_AC_NONE);
+    gfx_constant(G_AC_THRESHOLD);
+    gfx_constant(G_AC_DITHER);
+    gfx_constant(G_ZS_PIXEL);
+    gfx_constant(G_ZS_PRIM);
+
+    // Common values
+    gfx_constant((4-1)<<G_TEXTURE_IMAGE_FRAC);
+    gfx_constant((8-1)<<G_TEXTURE_IMAGE_FRAC);
+    gfx_constant((16-1)<<G_TEXTURE_IMAGE_FRAC);
+    gfx_constant((32-1)<<G_TEXTURE_IMAGE_FRAC);
+    gfx_constant((64-1)<<G_TEXTURE_IMAGE_FRAC);
+    gfx_constant((128-1)<<G_TEXTURE_IMAGE_FRAC);
+    gfx_constant((256-1)<<G_TEXTURE_IMAGE_FRAC);
+    gfx_constant(CALC_DXT(4,G_IM_SIZ_4b_BYTES));
+    gfx_constant(CALC_DXT(8,G_IM_SIZ_4b_BYTES));
+    gfx_constant(CALC_DXT(16,G_IM_SIZ_4b_BYTES));
+    gfx_constant(CALC_DXT(32,G_IM_SIZ_4b_BYTES));
+    gfx_constant(CALC_DXT(64,G_IM_SIZ_4b_BYTES));
+    gfx_constant(CALC_DXT(128,G_IM_SIZ_4b_BYTES));
+    gfx_constant(CALC_DXT(256,G_IM_SIZ_4b_BYTES));
+    gfx_constant(CALC_DXT(4,G_IM_SIZ_8b_BYTES));
+    gfx_constant(CALC_DXT(8,G_IM_SIZ_8b_BYTES));
+    gfx_constant(CALC_DXT(16,G_IM_SIZ_8b_BYTES));
+    gfx_constant(CALC_DXT(32,G_IM_SIZ_8b_BYTES));
+    gfx_constant(CALC_DXT(64,G_IM_SIZ_8b_BYTES));
+    gfx_constant(CALC_DXT(128,G_IM_SIZ_8b_BYTES));
+    gfx_constant(CALC_DXT(256,G_IM_SIZ_8b_BYTES));
+    gfx_constant(CALC_DXT(4,G_IM_SIZ_16b_BYTES));
+    gfx_constant(CALC_DXT(8,G_IM_SIZ_16b_BYTES));
+    gfx_constant(CALC_DXT(16,G_IM_SIZ_16b_BYTES));
+    gfx_constant(CALC_DXT(32,G_IM_SIZ_16b_BYTES));
+    gfx_constant(CALC_DXT(64,G_IM_SIZ_16b_BYTES));
+    gfx_constant(CALC_DXT(128,G_IM_SIZ_16b_BYTES));
+    gfx_constant(CALC_DXT(256,G_IM_SIZ_16b_BYTES));
+    gfx_constant(CALC_DXT(4,G_IM_SIZ_32b_BYTES));
+    gfx_constant(CALC_DXT(8,G_IM_SIZ_32b_BYTES));
+    gfx_constant(CALC_DXT(16,G_IM_SIZ_32b_BYTES));
+    gfx_constant(CALC_DXT(32,G_IM_SIZ_32b_BYTES));
+    gfx_constant(CALC_DXT(64,G_IM_SIZ_32b_BYTES));
+    gfx_constant(CALC_DXT(128,G_IM_SIZ_32b_BYTES));
+    gfx_constant(CALC_DXT(256,G_IM_SIZ_32b_BYTES));
+
+    // Lights
+    for (auto& _Node : aGfxData->mLights) {
+
+        // Light pointer
+        if (_Arg == _Node->mName) {
+            return (slong) ParseLightData(aGfxData, _Node)->mData;
+        }
+
+        // Ambient pointer
+        String _Ambient("&%s.a", _Node->mName.begin());
+        if (_Arg == _Ambient) {
+            return (slong) &(ParseLightData(aGfxData, _Node)->mData->a);
+        }
+
+        // Diffuse pointer
+        String _Diffuse("&%s.l", _Node->mName.begin());
+        if (_Arg == _Diffuse) {
+            return (slong) &(ParseLightData(aGfxData, _Node)->mData->l[0]);
+        }
+    }
+
+    // Textures
+    for (auto& _Node : aGfxData->mTextures) {
+        if (_Arg == _Node->mName) {
+            return (slong) ParseTextureData(aGfxData, _Node);
+        }
+    }
+
+    // Vertex arrays
+    for (auto& _Node : aGfxData->mVertices) {
+        if (_Arg == _Node->mName) {
+            return (slong) (ParseVertexData(aGfxData, _Node)->mData + _Offset);
+        }
+    }
+
+    // Display lists
+    for (auto& _Node : aGfxData->mDisplayLists) {
+        if (_Arg == _Node->mName) {
+            return (slong) ParseDisplayListData(aGfxData, _Node);
+        }
+    }
+
+    // Integers
+    int x;
+    if ((_Arg[1] == 'x' && sscanf(_Arg.begin(), "%x", &x) == 1) || (sscanf(_Arg.begin(), "%d", &x) == 1)) {
+        return (slong) x;
+    }
+
+    // Unknown
+    PrintError("  ERROR: Unknown gfx arg: %s", _Arg.begin());
+    return 0;
+}
+
+#define gfx_symbol_0(symb)                                                                             \
+    if (_Symbol == #symb) {                                                                       \
+        Gfx _Gfx[] = { symb() };                                                                        \
+        memcpy(aHead, _Gfx, sizeof(_Gfx));                                                               \
+        aHead += (sizeof(_Gfx) / sizeof(_Gfx[0]));                                                       \
+        return;                                                                                        \
+    }
+
+#define gfx_symbol_1(symb, ptr)                                                                        \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        if (ptr) { aGfxData->mPointerList.Add(aHead); }                                         \
+        Gfx _Gfx[] = { symb(_Arg0) };                                                                    \
+        memcpy(aHead, _Gfx, sizeof(_Gfx));                                                               \
+        aHead += (sizeof(_Gfx) / sizeof(_Gfx[0]));                                                       \
+        return;                                                                                        \
+    }
+
+#define gfx_symbol_2(symb, ptr)                                                                        \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        if (ptr) { aGfxData->mPointerList.Add(aHead); }                                         \
+        Gfx _Gfx[] = { symb(_Arg0, _Arg1) };                                                              \
+        memcpy(aHead, _Gfx, sizeof(_Gfx));                                                               \
+        aHead += (sizeof(_Gfx) / sizeof(_Gfx[0]));                                                       \
+        return;                                                                                        \
+    }
+
+#define gfx_symbol_3(symb, ptr)                                                                        \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        if (ptr) { aGfxData->mPointerList.Add(aHead); }                                         \
+        Gfx _Gfx[] = { symb(_Arg0, _Arg1, _Arg2) };                                                        \
+        memcpy(aHead, _Gfx, sizeof(_Gfx));                                                               \
+        aHead += (sizeof(_Gfx) / sizeof(_Gfx[0]));                                                       \
+        return;                                                                                        \
+    }
+
+#define gfx_symbol_4(symb)                                                                             \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        Gfx _Gfx[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3) };                                                  \
+        memcpy(aHead, _Gfx, sizeof(_Gfx));                                                               \
+        aHead += (sizeof(_Gfx) / sizeof(_Gfx[0]));                                                       \
+        return;                                                                                        \
+    }
+
+#define gfx_symbol_5(symb)                                                                             \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        Gfx _Gfx[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4) };                                            \
+        memcpy(aHead, _Gfx, sizeof(_Gfx));                                                               \
+        aHead += (sizeof(_Gfx) / sizeof(_Gfx[0]));                                                       \
+        return;                                                                                        \
+    }
+
+#define gfx_symbol_6(symb)                                                                             \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg5 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        Gfx _Gfx[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5) };                                      \
+        memcpy(aHead, _Gfx, sizeof(_Gfx));                                                               \
+        aHead += (sizeof(_Gfx) / sizeof(_Gfx[0]));                                                       \
+        return;                                                                                        \
+    }
+
+#define gfx_symbol_7(symb)                                                                             \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg5 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg6 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        Gfx _Gfx[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) };                                \
+        memcpy(aHead, _Gfx, sizeof(_Gfx));                                                               \
+        aHead += (sizeof(_Gfx) / sizeof(_Gfx[0]));                                                       \
+        return;                                                                                        \
+    }
+
+#define gfx_symbol_8(symb)                                                                             \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg5 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg6 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        slong _Arg7 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");                                \
+        Gfx _Gfx[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) };                          \
+        memcpy(aHead, _Gfx, sizeof(_Gfx));                                                               \
+        aHead += (sizeof(_Gfx) / sizeof(_Gfx[0]));                                                       \
+        return;                                                                                        \
+    }
+
+#define gfx_arg_with_suffix(argname, suffix)                                                           \
+    const String& argname##_token = aNode->mTokens[aTokenIndex];                                    \
+    String _Token##suffix = String("%s%s", argname##_token.begin(), #suffix);                                   \
+    slong argname = ParseGfxSymbolArg(aGfxData, aNode, NULL, _Token##suffix.begin());                         \
+
+#define STR_VALUE_2(...) #__VA_ARGS__
+#define STR_VALUE(...) STR_VALUE_2(__VA_ARGS__)
+#define gfx_set_combine_mode_arg(x) if (_Arg == #x) { return String("%s", STR_VALUE(x)); }
+static String ConvertSetCombineModeArgToString(GfxData *aGfxData, const String& _Arg) {
+    gfx_set_combine_mode_arg(G_CC_PRIMITIVE);
+    gfx_set_combine_mode_arg(G_CC_SHADE);
+    gfx_set_combine_mode_arg(G_CC_MODULATEI);
+    gfx_set_combine_mode_arg(G_CC_MODULATEIDECALA);
+    gfx_set_combine_mode_arg(G_CC_MODULATEIFADE);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGB);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGBDECALA);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGBFADE);
+    gfx_set_combine_mode_arg(G_CC_MODULATEIA);
+    gfx_set_combine_mode_arg(G_CC_MODULATEIFADEA);
+    gfx_set_combine_mode_arg(G_CC_MODULATEFADE);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGBA);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGBFADEA);
+    gfx_set_combine_mode_arg(G_CC_MODULATEI_PRIM);
+    gfx_set_combine_mode_arg(G_CC_MODULATEIA_PRIM);
+    gfx_set_combine_mode_arg(G_CC_MODULATEIDECALA_PRIM);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGB_PRIM);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGBA_PRIM);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGBDECALA_PRIM);
+    gfx_set_combine_mode_arg(G_CC_FADE);
+    gfx_set_combine_mode_arg(G_CC_FADEA);
+    gfx_set_combine_mode_arg(G_CC_DECALRGB);
+    gfx_set_combine_mode_arg(G_CC_DECALRGBA);
+    gfx_set_combine_mode_arg(G_CC_DECALFADE);
+    gfx_set_combine_mode_arg(G_CC_DECALFADEA);
+    gfx_set_combine_mode_arg(G_CC_BLENDI);
+    gfx_set_combine_mode_arg(G_CC_BLENDIA);
+    gfx_set_combine_mode_arg(G_CC_BLENDIDECALA);
+    gfx_set_combine_mode_arg(G_CC_BLENDRGBA);
+    gfx_set_combine_mode_arg(G_CC_BLENDRGBDECALA);
+    gfx_set_combine_mode_arg(G_CC_BLENDRGBFADEA);
+    gfx_set_combine_mode_arg(G_CC_ADDRGB);
+    gfx_set_combine_mode_arg(G_CC_ADDRGBDECALA);
+    gfx_set_combine_mode_arg(G_CC_ADDRGBFADE);
+    gfx_set_combine_mode_arg(G_CC_REFLECTRGB);
+    gfx_set_combine_mode_arg(G_CC_REFLECTRGBDECALA);
+    gfx_set_combine_mode_arg(G_CC_HILITERGB);
+    gfx_set_combine_mode_arg(G_CC_HILITERGBA);
+    gfx_set_combine_mode_arg(G_CC_HILITERGBDECALA);
+    gfx_set_combine_mode_arg(G_CC_SHADEDECALA);
+    gfx_set_combine_mode_arg(G_CC_SHADEFADEA);
+    gfx_set_combine_mode_arg(G_CC_BLENDPE);
+    gfx_set_combine_mode_arg(G_CC_BLENDPEDECALA);
+    gfx_set_combine_mode_arg(_G_CC_BLENDPE);
+    gfx_set_combine_mode_arg(_G_CC_BLENDPEDECALA);
+    gfx_set_combine_mode_arg(_G_CC_TWOCOLORTEX);
+    gfx_set_combine_mode_arg(_G_CC_SPARSEST);
+    gfx_set_combine_mode_arg(G_CC_TEMPLERP);
+    gfx_set_combine_mode_arg(G_CC_TRILERP);
+    gfx_set_combine_mode_arg(G_CC_INTERFERENCE);
+    gfx_set_combine_mode_arg(G_CC_1CYUV2RGB);
+    gfx_set_combine_mode_arg(G_CC_YUV2RGB);
+    gfx_set_combine_mode_arg(G_CC_PASS2);
+    gfx_set_combine_mode_arg(G_CC_MODULATEI2);
+    gfx_set_combine_mode_arg(G_CC_MODULATEIA2);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGB2);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGBA2);
+    gfx_set_combine_mode_arg(G_CC_MODULATEI_PRIM2);
+    gfx_set_combine_mode_arg(G_CC_MODULATEIA_PRIM2);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGB_PRIM2);
+    gfx_set_combine_mode_arg(G_CC_MODULATERGBA_PRIM2);
+    gfx_set_combine_mode_arg(G_CC_DECALRGB2);
+    gfx_set_combine_mode_arg(G_CC_BLENDI2);
+    gfx_set_combine_mode_arg(G_CC_BLENDIA2);
+    gfx_set_combine_mode_arg(G_CC_CHROMA_KEY2);
+    gfx_set_combine_mode_arg(G_CC_HILITERGB2);
+    gfx_set_combine_mode_arg(G_CC_HILITERGBA2);
+    gfx_set_combine_mode_arg(G_CC_HILITERGBDECALA2);
+    gfx_set_combine_mode_arg(G_CC_HILITERGBPASSA2);
+    PrintError("  ERROR: Unknown gfx gsDPSetCombineMode arg: %s", _Arg.begin());
+    return "";
+}
+
+static Array<slong> ParseGfxSetCombineMode(GfxData* aGfxData, DataNode<Gfx>* aNode, size_t* pTokenIndex) {
+    String _Buffer = ConvertSetCombineModeArgToString(aGfxData, aNode->mTokens[(*pTokenIndex)++]);
+    Array<slong> _Args;
+    String _Token;
+    for (size_t i = 0, n = _Buffer.Length(); i <= n; ++i) {
+        if (i == n || _Buffer[i] == ' ' || _Buffer[i] == '\t' || _Buffer[i] == ',') {
+            if (_Token.Length() != 0) {
+                String _Arg("%s%s", (_Args.Count() < 4 ? "G_CCMUX_" : "G_ACMUX_"), _Token.begin());
+                _Args.Add(ParseGfxSymbolArg(aGfxData, aNode, NULL, _Arg.begin()));
+                _Token.Clear();
+            }
+        } else {
+            _Token.Add(_Buffer[i]);
+        }
+    }
+    if (_Args.Count() < 8) {
+        PrintError("  ERROR: gsDPSetCombineMode %s: Not enough arguments", _Buffer.begin());
+    }
+    return _Args;
+}
+
+static void UpdateTextureInfo(GfxData* aGfxData, slong *aTexPtr, int aFormat, int aSize, int aWidth, int aHeight) {
+
+    // Update current texture pointers
+    if (aTexPtr && (*aTexPtr)) {
+        aGfxData->mGfxContext.mCurrentPalette = aGfxData->mGfxContext.mCurrentTexture;
+        aGfxData->mGfxContext.mCurrentTexture = (DataNode<TexData>*) (*aTexPtr);
+    }
+
+    // Update texture info if not loaded from a file
+    if (aGfxData->mGfxContext.mCurrentTexture && aGfxData->mGfxContext.mCurrentTexture->mData && aGfxData->mGfxContext.mCurrentTexture->mData->mPngData.Empty()) {
+        if (aFormat != -1) aGfxData->mGfxContext.mCurrentTexture->mData->mRawFormat = aFormat;
+        if (aSize   != -1) aGfxData->mGfxContext.mCurrentTexture->mData->mRawSize   = aSize;
+        if (aWidth  != -1) aGfxData->mGfxContext.mCurrentTexture->mData->mRawWidth  = aWidth;
+        if (aHeight != -1) aGfxData->mGfxContext.mCurrentTexture->mData->mRawHeight = aHeight;
+    }
+}
+
+static void ParseGfxSymbol(GfxData* aGfxData, DataNode<Gfx>* aNode, Gfx*& aHead, size_t& aTokenIndex) {
+    const String& _Symbol = aNode->mTokens[aTokenIndex++];
+
+    // Simple symbols
+    gfx_symbol_0(gsDPFullSync);
+    gfx_symbol_0(gsDPTileSync);
+    gfx_symbol_0(gsDPPipeSync);
+    gfx_symbol_0(gsDPLoadSync);
+    gfx_symbol_0(gsDPNoOp);
+    gfx_symbol_1(gsDPNoOpTag, false);
+    gfx_symbol_1(gsDPSetCycleType, false);
+    gfx_symbol_2(gsSPLight, true);
+    gfx_symbol_3(gsSPVertex, true);
+    gfx_symbol_4(gsSP1Triangle);
+    gfx_symbol_8(gsSP2Triangles);
+    gfx_symbol_1(gsSPNumLights, false);
+    gfx_symbol_1(gsDPSetDepthSource, false);
+    gfx_symbol_1(gsDPSetTextureLUT, false);
+    gfx_symbol_2(gsDPLoadTLUTCmd, false);
+    gfx_symbol_5(gsDPLoadBlock);
+    gfx_symbol_2(gsDPSetRenderMode, false);
+    gfx_symbol_2(gsSPGeometryMode, false);
+    gfx_symbol_6(gsDPSetPrimColor);
+    gfx_symbol_4(gsDPSetEnvColor);
+    gfx_symbol_4(gsDPSetFogColor);
+    gfx_symbol_2(gsSPFogPosition, false);
+    gfx_symbol_1(gsDPSetAlphaCompare, false);
+
+    // Special symbols
+    if (_Symbol == "gsSPTexture") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        gSPTexture(aHead++, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4);
+        aGfxData->mGfxContext.mSpTexture = gsSPTexture(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4);
+        return;
+    }
+    if (_Symbol == "gsSPSetGeometryMode") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        gSPSetGeometryMode(aHead++, _Arg0);
+        aGfxData->mGfxContext.mMetalBits.words.w1 |= (_Arg0 & METAL_BITS);
+        return;
+    }
+    if (_Symbol == "gsSPClearGeometryMode") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        gSPClearGeometryMode(aHead++, _Arg0);
+        aGfxData->mGfxContext.mMetalBits.words.w1 &= ~(_Arg0 & METAL_BITS);
+        return;
+    }
+    if (_Symbol == "gsSPDisplayList") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        aGfxData->mPointerList.Add(aHead);
+        gSPDisplayList(aHead++, _Arg0);
+        return;
+    }
+    if (_Symbol == "gsSPBranchList") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        aGfxData->mPointerList.Add(aHead);
+        gSPBranchList(aHead++, _Arg0);
+        return;
+    }
+    if (_Symbol == "gsSPEndDisplayList") {
+        DynOS_Gfx_PushDynCmd(aGfxData, aNode, aHead, GFXDYNCMD_CAPPY_EYES);
+        gSPEndDisplayList(aHead++);
+
+        // Convert raw texture to PNG if all raw members are set
+        if (aGfxData->mGfxContext.mCurrentTexture                    != NULL &&
+            aGfxData->mGfxContext.mCurrentTexture->mData             != NULL &&
+            aGfxData->mGfxContext.mCurrentTexture->mData->mPngData.Empty()   &&
+            aGfxData->mGfxContext.mCurrentTexture->mData->mRawFormat != -1   &&
+            aGfxData->mGfxContext.mCurrentTexture->mData->mRawSize   != -1   &&
+            aGfxData->mGfxContext.mCurrentTexture->mData->mRawWidth  != -1   &&
+            aGfxData->mGfxContext.mCurrentTexture->mData->mRawHeight != -1) {
+            ConvertTextureDataToPng(aGfxData, aGfxData->mGfxContext.mCurrentTexture->mData);
+        }
+
+        // End the display list parsing after hitting gsSPEndDisplayList
+        aTokenIndex = 0x7FFFFFFF;
+        return;
+    }
+
+    // Complex symbols
+    if (_Symbol == "gsSPSetLights1") {
+        Lights1 *_Light = (Lights1 *) ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        gSPNumLights(aHead++, NUMLIGHTS_1);
+        aGfxData->mPointerList.Add(aHead);
+        gSPLight(aHead++, &_Light->l[0], 1);
+        aGfxData->mPointerList.Add(aHead);
+        gSPLight(aHead++, &_Light->a, 2);
+        return;
+    }
+    if (_Symbol == "gsDPSetCombineMode") {
+        Array<slong> _Args0 = ParseGfxSetCombineMode(aGfxData, aNode, &aTokenIndex);
+        Array<slong> _Args1 = ParseGfxSetCombineMode(aGfxData, aNode, &aTokenIndex);
+        Gfx _Gfx = {{
+            _SHIFTL(G_SETCOMBINE, 24, 8) | _SHIFTL(GCCc0w0(_Args0[0x0], _Args0[0x2], _Args0[0x4], _Args0[0x6]) | GCCc1w0(_Args1[0x0], _Args1[0x2]), 0, 24),
+            (uint) (GCCc0w1(_Args0[0x1], _Args0[0x3], _Args0[0x5], _Args0[0x7]) | GCCc1w1(_Args1[0x1], _Args1[0x4], _Args1[0x6], _Args1[0x3], _Args1[0x5], _Args1[0x7]))
+        }};
+        *(aHead++) = _Gfx;
+        aGfxData->mGfxContext.mCombineMode = _Gfx;
+        return;
+    }
+    if (_Symbol == "gsDPSetCombineLERP") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_CCMUX_");
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_CCMUX_");
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_CCMUX_");
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_CCMUX_");
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_ACMUX_");
+        slong _Arg5 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_ACMUX_");
+        slong _Arg6 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_ACMUX_");
+        slong _Arg7 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_ACMUX_");
+        slong _Arg8 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_CCMUX_");
+        slong _Arg9 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_CCMUX_");
+        slong _ArgA = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_CCMUX_");
+        slong _ArgB = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_CCMUX_");
+        slong _ArgC = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_ACMUX_");
+        slong _ArgD = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_ACMUX_");
+        slong _ArgE = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_ACMUX_");
+        slong _ArgF = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "G_ACMUX_");
+        Gfx _Gfx = {{
+            _SHIFTL(G_SETCOMBINE, 24, 8) | _SHIFTL(GCCc0w0(_Arg0, _Arg2, _Arg4, _Arg6) | GCCc1w0(_Arg8, _ArgA), 0, 24),
+            (uint) (GCCc0w1(_Arg1, _Arg3, _Arg5, _Arg7) | GCCc1w1(_Arg9, _ArgC, _ArgE, _ArgB, _ArgD, _ArgF))
+        }};
+        *(aHead++) = _Gfx;
+        aGfxData->mGfxContext.mCombineMode = _Gfx;
+        return;
+    }
+
+    // TexData symbols
+    if (_Symbol == "gsDPSetTextureImage") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        UpdateTextureInfo(aGfxData, &_Arg3, (int) _Arg0, (int) _Arg1, -1, -1);
+        aGfxData->mPointerList.Add(aHead);
+        gDPSetTextureImage(aHead++, _Arg0, _Arg1, _Arg2, _Arg3);
+        return;
+    }
+    if (_Symbol == "gsDPSetTile") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg5 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg6 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg7 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg8 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg9 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _ArgA = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _ArgB = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        UpdateTextureInfo(aGfxData, NULL, (int) _Arg0, (int) _Arg1, -1, -1);
+        gDPSetTile(aHead++, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _ArgA, _ArgB);
+        if (_Arg4 == G_TX_LOADTILE)   aGfxData->mGfxContext.mTxLoadTile   = gsDPSetTile(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _ArgA, _ArgB);
+        if (_Arg4 == G_TX_RENDERTILE) aGfxData->mGfxContext.mTxRenderTile = gsDPSetTile(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _ArgA, _ArgB);
+        return;
+    }
+    if (_Symbol == "gsDPLoadTile") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        UpdateTextureInfo(aGfxData, NULL, -1, -1, (int) (_Arg3 >> G_TEXTURE_IMAGE_FRAC) + 1, (int) (_Arg4 >> G_TEXTURE_IMAGE_FRAC) + 1);
+        gDPLoadTile(aHead++, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4);
+        return;
+    }
+    if (_Symbol == "gsDPSetTileSize") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        UpdateTextureInfo(aGfxData, NULL, -1, -1, (int) (_Arg3 >> G_TEXTURE_IMAGE_FRAC) + 1, (int) (_Arg4 >> G_TEXTURE_IMAGE_FRAC) + 1);
+        gDPSetTileSize(aHead++, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4);
+        aGfxData->mGfxContext.mSetTileSize = gsDPSetTileSize(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4);
+        return;
+    }
+    if (_Symbol == "gsDPLoadTextureBlock") {
+        slong _Arg0 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg1 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        gfx_arg_with_suffix(arg2_0, _LOAD_BLOCK);
+        gfx_arg_with_suffix(arg2_1, _INCR);
+        gfx_arg_with_suffix(arg2_2, _SHIFT);
+        gfx_arg_with_suffix(arg2_3, _BYTES);
+        gfx_arg_with_suffix(arg2_4, _LINE_BYTES);
+        slong _Arg2 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg3 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg4 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg5 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg6 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg7 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg8 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _Arg9 = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _ArgA = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        slong _ArgB = ParseGfxSymbolArg(aGfxData, aNode, &aTokenIndex, "");
+        UpdateTextureInfo(aGfxData, &_Arg0, (int) _Arg1, (int) _Arg2, (int) _Arg3, (int) _Arg4);
+
+        aGfxData->mPointerList.Add(aHead);
+        gDPSetTextureImage(aHead++, _Arg1, arg2_0, 1, _Arg0);
+        gDPSetTile(aHead++, _Arg1, arg2_0, 0, 0, G_TX_LOADTILE, 0, _Arg7, _Arg9, _ArgB, _Arg6, _Arg8, _ArgA);
+        gDPLoadSync(aHead++);
+        gDPLoadBlock(aHead++, G_TX_LOADTILE, 0, 0, (((_Arg3) * (_Arg4) + arg2_1) >> arg2_2) - 1, CALC_DXT(_Arg3, arg2_3));
+        gDPPipeSync(aHead++);
+        gDPSetTile(aHead++, _Arg1, _Arg2, ((((_Arg3) * arg2_4) + 7) >> 3), 0, G_TX_RENDERTILE, _Arg5, _Arg7, _Arg9, _ArgB, _Arg6, _Arg8, _ArgA);
+        gDPSetTileSize(aHead++, G_TX_RENDERTILE, 0, 0, ((_Arg3) - 1) << G_TEXTURE_IMAGE_FRAC, ((_Arg4) - 1) << G_TEXTURE_IMAGE_FRAC);
+
+        aGfxData->mGfxContext.mTxLoadTile   = gsDPSetTile(_Arg1, arg2_0, 0, 0, G_TX_LOADTILE, 0, _Arg7, _Arg9, _ArgB, _Arg6, _Arg8, _ArgA);
+        aGfxData->mGfxContext.mTxRenderTile = gsDPSetTile(_Arg1, _Arg2, ((((_Arg3)*arg2_4) + 7) >> 3), 0, G_TX_RENDERTILE, _Arg5, _Arg7, _Arg9, _ArgB, _Arg6, _Arg8, _ArgA);
+        aGfxData->mGfxContext.mSetTileSize  = gsDPSetTileSize(G_TX_RENDERTILE, 0, 0, ((_Arg3)-1) << G_TEXTURE_IMAGE_FRAC, ((_Arg4)-1) << G_TEXTURE_IMAGE_FRAC);
+        return;
+    }
+
+    // Unknown
+    PrintError("  ERROR: Unknown gfx symbol: %s", _Symbol.begin());
+}
+
+static DataNode<Gfx>* ParseDisplayListData(GfxData* aGfxData, DataNode<Gfx>* aNode) {
+    if (aNode->mData) return aNode;
+
+    // Cappy eyes
+    if (DynOS_Gfx_IsCappyEyesDisplayList(aGfxData, aNode->mName)) {
+        static size_t sUniqueId = 0;
+        DataNode<Gfx>* _NewNode = New<DataNode<Gfx>>();
+        _NewNode->mName = String("%s.%llu", aNode->mName.begin(), sUniqueId++);
+        _NewNode->mTokens = aNode->mTokens;
+        aGfxData->mDisplayLists.Add(_NewNode);
+        aNode = _NewNode;
+    }
+
+    // Display list data
+    aNode->mData = New<Gfx>(aNode->mTokens.Count() * DISPLAY_LIST_SIZE_PER_TOKEN);
+    Gfx* _Head = aNode->mData;
+    for (size_t _TokenIndex = 0; _TokenIndex < aNode->mTokens.Count();) { // Don't increment _TokenIndex here!
+        ParseGfxSymbol(aGfxData, aNode, _Head, _TokenIndex);
+    }
+    aNode->mSize = (uint) (_Head - aNode->mData);
+    aNode->mLoadIndex = aGfxData->mLoadIndex++;
+    return aNode;
+}
+
+//
+// Geo layouts
+//
+
+#define geo_constant(x) if (_Arg == #x) { return (slong) (x); }
+static slong ParseGeoSymbolArg(GfxData* aGfxData, DataNode<GeoLayout>* aNode, size_t& aTokenIndex) {
+    const String& _Arg = aNode->mTokens[aTokenIndex++];
+
+    // Geo functions
+    void *_GeoFunctionPtr = DynOS_Geo_GetFunctionPointerFromName(_Arg);
+    if (_GeoFunctionPtr != NULL) {
+        return (slong) _GeoFunctionPtr;
+    }
+
+    // Layer constants
+    geo_constant(LAYER_FORCE);
+    geo_constant(LAYER_OPAQUE);
+    geo_constant(LAYER_OPAQUE_DECAL);
+    geo_constant(LAYER_OPAQUE_INTER);
+    geo_constant(LAYER_ALPHA);
+    geo_constant(LAYER_TRANSPARENT);
+    geo_constant(LAYER_TRANSPARENT_DECAL);
+    geo_constant(LAYER_TRANSPARENT_INTER);
+
+    // Background constants
+    geo_constant(BACKGROUND_OCEAN_SKY);
+    geo_constant(BACKGROUND_FLAMING_SKY);
+    geo_constant(BACKGROUND_UNDERWATER_CITY);
+    geo_constant(BACKGROUND_BELOW_CLOUDS);
+    geo_constant(BACKGROUND_SNOW_MOUNTAINS);
+    geo_constant(BACKGROUND_DESERT);
+    geo_constant(BACKGROUND_HAUNTED);
+    geo_constant(BACKGROUND_GREEN_SKY);
+    geo_constant(BACKGROUND_ABOVE_CLOUDS);
+    geo_constant(BACKGROUND_PURPLE_SKY);
+
+    // Shadow constants
+    geo_constant(SHADOW_CIRCLE_9_VERTS);
+    geo_constant(SHADOW_CIRCLE_4_VERTS);
+    geo_constant(SHADOW_CIRCLE_4_VERTS_FLAT_UNUSED);
+    geo_constant(SHADOW_SQUARE_PERMANENT);
+    geo_constant(SHADOW_SQUARE_SCALABLE);
+    geo_constant(SHADOW_SQUARE_TOGGLABLE);
+    geo_constant(SHADOW_RECTANGLE_HARDCODED_OFFSET);
+    geo_constant(SHADOW_CIRCLE_PLAYER);
+
+    // Other constants
+    geo_constant(NULL);
+    geo_constant(SCREEN_WIDTH);
+    geo_constant(SCREEN_HEIGHT);
+    geo_constant(SCREEN_WIDTH/2);
+    geo_constant(SCREEN_HEIGHT/2);
+
+    // Display lists
+    for (auto& _Node : aGfxData->mDisplayLists) {
+        if (_Arg == _Node->mName) {
+            return (slong) ParseDisplayListData(aGfxData, _Node);
+        }
+    }
+
+    // Geo layouts
+    for (auto& _Node : aGfxData->mGeoLayouts) {
+        if (_Arg == _Node->mName) {
+            return (slong) ParseGeoLayoutData(aGfxData, _Node, false)->mData;
+        }
+    }
+
+    // Integers
+    int x;
+    if ((_Arg[1] == 'x' && sscanf(_Arg.begin(), "%x", &x) == 1) || (sscanf(_Arg.begin(), "%d", &x) == 1)) {
+        return (slong) x;
+    }
+
+    // Unknown
+    PrintError("  ERROR: Unknown geo arg: %s", _Arg.begin());
+    return 0;
+}
+
+#define geo_symbol_0(symb)                                                                             \
+    if (_Symbol == #symb) {                                                                       \
+        GeoLayout _Gl[] = { symb() };                                                                   \
+        memcpy(aHead, _Gl, sizeof(_Gl));                                                                 \
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));                                                         \
+        return;                                                                                        \
+    }
+
+#define geo_symbol_1(symb, n)                                                                          \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        if (n != 0) { aGfxData->mPointerList.Add(aHead + n); }                            \
+        GeoLayout _Gl[] = { symb(_Arg0) };                                                               \
+        memcpy(aHead, _Gl, sizeof(_Gl));                                                                 \
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));                                                         \
+        return;                                                                                        \
+    }
+
+#define geo_symbol_2(symb, n)                                                                          \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg1 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        if (n != 0) { aGfxData->mPointerList.Add(aHead + n); }                            \
+        GeoLayout _Gl[] = { symb(_Arg0, _Arg1) };                                                         \
+        memcpy(aHead, _Gl, sizeof(_Gl));                                                                 \
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));                                                         \
+        return;                                                                                        \
+    }
+
+#define geo_symbol_3(symb, n)                                                                          \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg1 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg2 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        if (n != 0) { aGfxData->mPointerList.Add(aHead + n); }                            \
+        GeoLayout _Gl[] = { symb(_Arg0, _Arg1, _Arg2) };                                                   \
+        memcpy(aHead, _Gl, sizeof(_Gl));                                                                 \
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));                                                         \
+        return;                                                                                        \
+    }
+
+#define geo_symbol_4(symb, n)                                                                          \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg1 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg2 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg3 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        if (n != 0) { aGfxData->mPointerList.Add(aHead + n); }                            \
+        GeoLayout _Gl[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3) };                                             \
+        memcpy(aHead, _Gl, sizeof(_Gl));                                                                 \
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));                                                         \
+        return;                                                                                        \
+    }
+
+#define geo_symbol_5(symb, n)                                                                          \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg1 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg2 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg3 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg4 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        if (n != 0) { aGfxData->mPointerList.Add(aHead + n); }                            \
+        GeoLayout _Gl[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4) };                                       \
+        memcpy(aHead, _Gl, sizeof(_Gl));                                                                 \
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));                                                         \
+        return;                                                                                        \
+    }
+
+#define geo_symbol_6(symb, n)                                                                          \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg1 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg2 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg3 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg4 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg5 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        if (n != 0) { aGfxData->mPointerList.Add(aHead + n); }                            \
+        GeoLayout _Gl[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5) };                                 \
+        memcpy(aHead, _Gl, sizeof(_Gl));                                                                 \
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));                                                         \
+        return;                                                                                        \
+    }
+
+#define geo_symbol_7(symb, n)                                                                          \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg1 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg2 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg3 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg4 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg5 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg6 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        if (n != 0) { aGfxData->mPointerList.Add(aHead + n); }                            \
+        GeoLayout _Gl[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) };                           \
+        memcpy(aHead, _Gl, sizeof(_Gl));                                                                 \
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));                                                         \
+        return;                                                                                        \
+    }
+
+#define geo_symbol_8(symb, n)                                                                          \
+    if (_Symbol == #symb) {                                                                       \
+        slong _Arg0 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg1 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg2 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg3 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg4 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg5 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg6 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        slong _Arg7 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);                                    \
+        if (n != 0) { aGfxData->mPointerList.Add(aHead + n); }                            \
+        GeoLayout _Gl[] = { symb(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) };                     \
+        memcpy(aHead, _Gl, sizeof(_Gl));                                                                 \
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));                                                         \
+        return;                                                                                        \
+    }
+
+static void ParseGeoSymbol(GfxData* aGfxData, DataNode<GeoLayout>* aNode, GeoLayout*& aHead, size_t& aTokenIndex, Array<size_t>& aSwitchNodes) {
+    const String& _Symbol = aNode->mTokens[aTokenIndex++];
+
+    // Restore context after each command if inside a switch
+    if (!aSwitchNodes.Empty() && !aGfxData->mGeoNodeStack.Empty()) {
+        aGfxData->mGfxContext = aGfxData->mGeoNodeStack[aGfxData->mGeoNodeStack.Count() - 1];
+    }
+
+    geo_symbol_1(GEO_BRANCH_AND_LINK, 1);
+    geo_symbol_0(GEO_END);
+    geo_symbol_2(GEO_BRANCH, 1);
+    geo_symbol_0(GEO_RETURN);
+    geo_symbol_5(GEO_NODE_SCREEN_AREA, 0);
+    geo_symbol_1(GEO_NODE_ORTHO, 0);
+    geo_symbol_3(GEO_CAMERA_FRUSTUM, 0);
+    geo_symbol_4(GEO_CAMERA_FRUSTUM_WITH_FUNC, 2);
+    geo_symbol_0(GEO_NODE_START);
+    geo_symbol_1(GEO_ZBUFFER, 0);
+    geo_symbol_2(GEO_RENDER_RANGE, 0);
+    geo_symbol_8(GEO_CAMERA, 4);
+    geo_symbol_7(GEO_TRANSLATE_ROTATE, 0);
+    geo_symbol_8(GEO_TRANSLATE_ROTATE_WITH_DL, 4);
+    geo_symbol_4(GEO_TRANSLATE, 0);
+    geo_symbol_5(GEO_TRANSLATE_WITH_DL, 2);
+    geo_symbol_4(GEO_ROTATE, 0);
+    geo_symbol_5(GEO_ROTATE_WITH_DL, 2);
+    geo_symbol_2(GEO_ROTATE_Y, 0);
+    geo_symbol_3(GEO_ROTATE_Y_WITH_DL, 1);
+    geo_symbol_4(GEO_TRANSLATE_NODE, 0);
+    geo_symbol_5(GEO_TRANSLATE_NODE_WITH_DL, 2);
+    geo_symbol_4(GEO_ROTATION_NODE, 0);
+    geo_symbol_5(GEO_ROTATION_NODE_WITH_DL, 2);
+    geo_symbol_5(GEO_ANIMATED_PART, 2);
+    geo_symbol_4(GEO_BILLBOARD_WITH_PARAMS, 0);
+    geo_symbol_5(GEO_BILLBOARD_WITH_PARAMS_AND_DL, 2);
+    geo_symbol_0(GEO_BILLBOARD);
+    geo_symbol_2(GEO_DISPLAY_LIST, 1);
+    geo_symbol_3(GEO_SHADOW, 0);
+    geo_symbol_0(GEO_RENDER_OBJ);
+    geo_symbol_2(GEO_ASM, 1);
+    geo_symbol_2(GEO_BACKGROUND, 1);
+    geo_symbol_1(GEO_BACKGROUND_COLOR, 0);
+    geo_symbol_0(GEO_NOP_1A);
+    geo_symbol_5(GEO_HELD_OBJECT, 2);
+    geo_symbol_2(GEO_SCALE, 0);
+    geo_symbol_3(GEO_SCALE_WITH_DL, 2);
+    geo_symbol_0(GEO_NOP_1E);
+    geo_symbol_0(GEO_NOP_1F);
+    geo_symbol_1(GEO_CULLING_RADIUS, 0);
+
+    // Switch node
+    if (_Symbol == "GEO_SWITCH_CASE") {
+
+        // Start a switch
+        aSwitchNodes.Add(0);
+
+        slong _Arg0 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);
+        slong _Arg1 = ParseGeoSymbolArg(aGfxData, aNode, aTokenIndex);
+        aGfxData->mPointerList.Add(aHead + 1);
+        GeoLayout _Gl[] = { GEO_SWITCH_CASE(_Arg0, _Arg1) };
+        memcpy(aHead, _Gl, sizeof(_Gl));
+        aHead += (sizeof(_Gl) / sizeof(_Gl[0]));
+        return;
+    }
+
+    // Open node
+    if (_Symbol == "GEO_OPEN_NODE") {
+
+        // We're inside a switch
+        if (!aSwitchNodes.Empty()) {
+            aSwitchNodes[aSwitchNodes.Count() - 1]++;
+        }
+
+        // Push context
+        aGfxData->mGeoNodeStack.Add(aGfxData->mGfxContext);
+
+        *(aHead++) = GEO_OPEN_NODE();
+        return;
+    }
+
+    // Close node
+    if (_Symbol == "GEO_CLOSE_NODE") {
+
+        // Are we still inside a switch?
+        if (!aSwitchNodes.Empty()) {
+            aSwitchNodes[aSwitchNodes.Count() - 1]--;
+
+            // We're not anymore
+            if (aSwitchNodes[aSwitchNodes.Count() - 1] == 0) {
+                aSwitchNodes.Pop();
+            }
+        }
+
+        // Pop context
+        if (!aGfxData->mGeoNodeStack.Empty()) {
+            aGfxData->mGfxContext = aGfxData->mGeoNodeStack[aGfxData->mGeoNodeStack.Count() - 1];
+            aGfxData->mGeoNodeStack.Pop();
+        }
+
+        *(aHead++) = GEO_CLOSE_NODE();
+        return;
+    }
+
+    // Unknown
+    PrintError("  ERROR: Unknown geo symbol: %s", _Symbol.begin());
+}
+
+static DataNode<GeoLayout>* ParseGeoLayoutData(GfxData* aGfxData, DataNode<GeoLayout>* aNode, bool aDisplayPercent) {
+    if (aNode->mData) return aNode;
+
+    // Geo layout data
+    aNode->mData = New<GeoLayout>(aNode->mTokens.Count() * GEO_LAYOUT_SIZE_PER_TOKEN);
+    GeoLayout* _Head = aNode->mData;
+    Array<size_t> _SwitchNodes;
+    for (size_t _TokenIndex = 0; _TokenIndex < aNode->mTokens.Count();) { // Don't increment _TokenIndex here!
+        ParseGeoSymbol(aGfxData, aNode, _Head, _TokenIndex, _SwitchNodes);
+        if (aDisplayPercent && aGfxData->mErrorCount == 0) { PrintNoNewLine("%3d%%\b\b\b\b", (int) (_TokenIndex * 100) / aNode->mTokens.Count()); }
+    }
+    if (aDisplayPercent && aGfxData->mErrorCount == 0) { Print("100%%"); }
+    aNode->mSize = (uint)(_Head - aNode->mData);
+    aNode->mLoadIndex = aGfxData->mLoadIndex++;
+    return aNode;
+}
+
+//
+// Animation files
+//
+
+static void ScanAnimationDataFile(GfxData *aGfxData, const SysPath &aFilename) {
+    FILE *_File = fopen(aFilename.c_str(), "rb");
+    if (!_File) {
+        PrintError("  ERROR: Unable to open file \"%s\"", aFilename.c_str());
+    }
+
+    // Load file into a buffer while removing all comments
+    char *_FileBuffer = LoadFileBuffer(_File, NULL);
+    fclose(_File);
+
+    // Parse animation data
+    ubyte _DataType = DATA_TYPE_NONE;
+    String _DataName;
+    bool _IsData = false;
+    Array<String> _Data;
+    Array<String> _Tokens = Split(_FileBuffer, " []()=&,;\t\r\n\b");
+    for (const auto &_Token : _Tokens) {
+
+        // Data type
+        if (_DataType == DATA_TYPE_NONE) {
+            if (_Token == "s16" || _Token == "u16" || _Token == "short") {
+                _DataType = DATA_TYPE_ANIMATION_VALUE;
+            } else if (_Token == "Animation") {
+                _DataType = DATA_TYPE_ANIMATION;
+            }
+        }
+
+        // Data name
+        else if (_DataName.Empty()) {
+            _DataName = _Token;
+            if (_DataType == DATA_TYPE_ANIMATION_VALUE && (_DataName.Find("index") != -1 || _DataName.Find("indices") != -1)) {
+                _DataType = DATA_TYPE_ANIMATION_INDEX;
+            }
+        }
+
+        // Is data?
+        else if (!_IsData) {
+            if (_Token == "{") {
+                _IsData = true;
+            }
+        }
+
+        // Data
+        else {
+            if (_Token == "}") {
+                switch (_DataType) {
+                    case DATA_TYPE_ANIMATION_VALUE: {
+                        AnimBuffer<short> *_AnimValues = New<AnimBuffer<short>>();
+                        _AnimValues->first = _DataName;
+                        for (const auto &_Value : _Data) {
+                            _AnimValues->second.Add(_Value.ParseInt());
+                        }
+                        aGfxData->mAnimValues.Add(_AnimValues);
+                    } break;
+
+                    case DATA_TYPE_ANIMATION_INDEX: {
+                        AnimBuffer<ushort> *_AnimIndices = New<AnimBuffer<ushort>>();
+                        _AnimIndices->first = _DataName;
+                        for (const auto &_Index : _Data) {
+                            _AnimIndices->second.Add(_Index.ParseInt());
+                        }
+                        aGfxData->mAnimIndices.Add(_AnimIndices);
+                    } break;
+
+                    case DATA_TYPE_ANIMATION: {
+                        if (_Data.Count() < 10) {
+                            PrintError("  ERROR: %s: Not enough data", _DataName.begin());
+                            break;
+                        }
+
+                        DataNode<AnimData> *_Node = New<DataNode<AnimData>>();
+                        _Node->mName = _DataName;
+                        _Node->mData = New<AnimData>();
+                        _Node->mData->mFlags = (short) _Data[0].ParseInt();
+                        _Node->mData->mUnk02 = (short) _Data[1].ParseInt();
+                        _Node->mData->mUnk04 = (short) _Data[2].ParseInt();
+                        _Node->mData->mUnk06 = (short) _Data[3].ParseInt();
+                        _Node->mData->mUnk08 = (short) _Data[4].ParseInt();
+                        _Node->mData->mUnk0A.first = _Data[6]; // 5 is "ANIMINDEX_NUMPARTS"
+                        _Node->mData->mValues.first = _Data[7];
+                        _Node->mData->mIndex.first = _Data[8];
+                        _Node->mData->mLength = (uint) _Data[9].ParseInt();
+                        aGfxData->mAnimations.Add(_Node);
+                    } break;
+                }
+                _DataType = DATA_TYPE_NONE;
+                _DataName.Clear();
+                _IsData = false;
+                _Data.Clear();
+            } else {
+                _Data.Add(_Token);
+            }
+        }
+    }
+    Delete(_FileBuffer);
+}
+
+static void ScanAnimationTableFile(GfxData *aGfxData, const SysPath &aFilename) {
+    FILE *_File = fopen(aFilename.c_str(), "rb");
+    if (!_File) {
+        PrintError("  ERROR: Unable to open file \"%s\"", aFilename.c_str());
+    }
+
+    // Load file into a buffer while removing all comments
+    char *_FileBuffer = LoadFileBuffer(_File, NULL);
+    fclose(_File);
+
+    // Retrieve animation names
+    bool _IsAnimName = false;
+    Array<String> _Tokens = Split(_FileBuffer, " =&,;\t\r\n\b");
+    for (const auto &_Token : _Tokens) {
+        if (_Token == "{") {
+            _IsAnimName = true;
+        } else if (_Token == "}") {
+            _IsAnimName = false;
+        } else if (_IsAnimName) {
+            aGfxData->mAnimationTable.Add({ _Token, NULL });
+        }
+    }
+    Delete(_FileBuffer);
+}
+
+static void ScanAnimationFolder(GfxData *aGfxData, const SysPath &aAnimsFolder) {
+    DIR *_AnimsDir = opendir(aAnimsFolder.c_str());
+    if (!_AnimsDir) return;
+
+    struct dirent *_AnimsEnt = NULL;
+    while ((_AnimsEnt = readdir(_AnimsDir)) != NULL) {
+
+        // Skip
+        if (SysPath(_AnimsEnt->d_name) == ".") continue;
+        if (SysPath(_AnimsEnt->d_name) == "..") continue;
+        if (SysPath(_AnimsEnt->d_name) == "data.inc.c") continue;
+
+        // Animation file
+        SysPath _AnimsFilename = fstring("%s/%s", aAnimsFolder.c_str(), _AnimsEnt->d_name);
+        if (fs_sys_file_exists(_AnimsFilename.c_str())) {
+
+            // Table file
+            if (SysPath(_AnimsEnt->d_name) == "table.inc.c") {
+                ScanAnimationTableFile(aGfxData, _AnimsFilename);
+            }
+
+            // Data file
+            else {
+                ScanAnimationDataFile(aGfxData, _AnimsFilename);
+            }
+        }
+    }
+    closedir(_AnimsDir);
+}
+
+//
+// Read & Generate
+//
+
+// Free data pointers, but keep nodes and tokens intact
+// Delete nodes generated from GfxDynCmds
+template <typename T>
+static void ClearGfxDataNodes(DataNodes<T> &aDataNodes) {
+    for (int i = aDataNodes.Count(); i != 0; --i) {
+        Delete(aDataNodes[i - 1]->mData);
+        if (aDataNodes[i - 1]->mName.Find(GFX_DYN_CMD_ID) != -1) {
+            Delete(aDataNodes[i - 1]);
+            aDataNodes.Remove(i - 1);
+        }
+    }
+}
+
+static DataNode<GeoLayout> *GetGeoLayout(GfxData *aGfxData, const String& aGeoRoot) {
+    for (DataNode<GeoLayout> *_Node : aGfxData->mGeoLayouts) {
+        if (_Node->mName == aGeoRoot) {
+            return _Node;
+        }
+    }
+    return NULL;
+}
+
+static String GetActorFolder(const Array<Pair<size_t, String>> &aActorsFolders, size_t aModelIdentifier) {
+    for (const auto &_Pair : aActorsFolders) {
+        if (_Pair.first == aModelIdentifier) {
+            return _Pair.second;
+        }
+    }
+    return String();
+}
+
+void DynOS_Gfx_GeneratePack(const SysPath &aPackFolder) {
+    Print("---------- Pack folder: \"%s\" ----------", aPackFolder.c_str());
+    Array<Pair<size_t, String>> _ActorsFolders;
+    GfxData *_GfxData = New<GfxData>();
+
+    // Read all the model.inc.c files and geo.inc.c files from the subfolders of the pack folder
+    // Animations are processed separately
+    DIR *aPackDir = opendir(aPackFolder.c_str());
+    if (aPackDir) {
+        struct dirent *_PackEnt = NULL;
+        while ((_PackEnt = readdir(aPackDir)) != NULL) {
+
+            // Skip . and ..
+            if (SysPath(_PackEnt->d_name) == ".") continue;
+            if (SysPath(_PackEnt->d_name) == "..") continue;
+
+            // For each subfolder, read tokens from model.inc.c and geo.inc.c
+            SysPath _Folder = fstring("%s/%s", aPackFolder.c_str(), _PackEnt->d_name);
+            if (fs_sys_dir_exists(_Folder.c_str())) {
+                _GfxData->mModelIdentifier = 0;
+                ScanModelFile(_GfxData, fstring("%s/model.inc.c", _Folder.c_str()));
+                ScanModelFile(_GfxData, fstring("%s/geo.inc.c", _Folder.c_str()));
+                if (_GfxData->mModelIdentifier != 0) {
+                    _ActorsFolders.Add({ _GfxData->mModelIdentifier, String(_PackEnt->d_name) });
+                }
+            }
+        }
+        closedir(aPackDir);
+    }
+
+    // Generate a binary file for each actor found in the GfxData
+    for (int i = 0; i != DynOS_Geo_GetActorCount(); ++i) {
+        String _GeoRootName = DynOS_Geo_GetActorName(i);
+        DataNode<GeoLayout> *_GeoRoot = GetGeoLayout(_GfxData, _GeoRootName);
+        if (_GeoRoot != NULL) {
+
+            // If there is an existing binary file for this layout, skip and go to the next actor
+            SysPath _BinFilename = fstring("%s/%s.bin", aPackFolder.c_str(), _GeoRootName.begin());
+            if (fs_sys_file_exists(_BinFilename.c_str())) {
+                continue;
+            }
+
+            // Init
+            _GfxData->mLoadIndex                  = 0;
+            _GfxData->mErrorCount                 = 0;
+            _GfxData->mModelIdentifier            = _GeoRoot->mModelIdentifier;
+            _GfxData->mPackFolder                 = aPackFolder;
+            _GfxData->mPointerList                = { NULL }; // The NULL pointer is needed, so we add it here
+            _GfxData->mGfxContext.mCurrentTexture = NULL;
+            _GfxData->mGfxContext.mCurrentPalette = NULL;
+            _GfxData->mGfxContext.mMetalBits      = { 0, 0 };
+            _GfxData->mGfxContext.mCombineMode    = { 0, 0 };
+            _GfxData->mGfxContext.mSpTexture      = { 0, 0 };
+            _GfxData->mGfxContext.mTxLoadTile     = { 0, 0 };
+            _GfxData->mGfxContext.mTxRenderTile   = { 0, 0 };
+            _GfxData->mGfxContext.mSetTileSize    = { 0, 0 };
+            _GfxData->mGeoNodeStack.Clear();
+            _GfxData->mGfxDynCmds.Clear();
+
+            // Parse data
+            PrintNoNewLine("%s.bin: Model identifier: %X - Processing... ", _GeoRootName.begin(), _GfxData->mModelIdentifier);
+            ParseGeoLayoutData(_GfxData, _GeoRoot, true);
+
+            // Init animation data
+            for (auto &_AnimBuffer : _GfxData->mAnimValues) Delete(_AnimBuffer);
+            for (auto &_AnimBuffer : _GfxData->mAnimIndices) Delete(_AnimBuffer);
+            for (auto &_AnimNode : _GfxData->mAnimations) Delete(_AnimNode);
+            _GfxData->mAnimValues.Clear();
+            _GfxData->mAnimIndices.Clear();
+            _GfxData->mAnimations.Clear();
+            _GfxData->mAnimationTable.Clear();
+
+            // Scan anims folder for animation data
+            String _ActorFolder = GetActorFolder(_ActorsFolders, _GfxData->mModelIdentifier);
+            SysPath _AnimsFolder = fstring("%s/%s/anims", aPackFolder.c_str(), _ActorFolder.begin());
+            ScanAnimationFolder(_GfxData, _AnimsFolder);
+
+            // Create table for mario_geo animations or luigi_geo animations
+            if ((_GeoRootName == "mario_geo" || _GeoRootName == "luigi_geo") && !_GfxData->mAnimations.Empty()) {
+                _GfxData->mAnimationTable.Resize(256);
+                for (int i = 0; i != 256; ++i) {
+                    String _AnimName("anim_%02X", i);
+                    if (_GfxData->mAnimations.FindIf([&_AnimName](const DataNode<AnimData> *aNode) { return aNode->mName == _AnimName; }) != -1) {
+                        _GfxData->mAnimationTable[i] = { _AnimName, NULL };
+                    } else {
+                        _GfxData->mAnimationTable[i] = { "NULL", NULL };
+                    }
+                }
+            }
+
+            // Write if no error
+            if (_GfxData->mErrorCount == 0) {
+                DynOS_Gfx_WriteBinary(_BinFilename, _GfxData);
+            } else {
+                Print("  %u error(s): Unable to parse data", _GfxData->mErrorCount);
+            }
+
+            // Clear data pointers
+            ClearGfxDataNodes(_GfxData->mLights);
+            ClearGfxDataNodes(_GfxData->mTextures);
+            ClearGfxDataNodes(_GfxData->mVertices);
+            ClearGfxDataNodes(_GfxData->mDisplayLists);
+            ClearGfxDataNodes(_GfxData->mGeoLayouts);
+        }
+    }
+
+    DynOS_Gfx_Free(_GfxData);
+}
+
+#pragma GCC diagnostic pop
diff --git a/data/dynos_gfx_texture.cpp b/data/dynos_gfx_texture.cpp
new file mode 100644
index 0000000..20e027d
--- /dev/null
+++ b/data/dynos_gfx_texture.cpp
@@ -0,0 +1,458 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "pc/gfx/gfx_rendering_api.h"
+}
+
+//
+// Conversion
+//
+
+#define SCALE_5_8(VAL_) (((VAL_) * 0xFF) / 0x1F)
+#define SCALE_8_5(VAL_) ((((VAL_) + 4) * 0x1F) / 0xFF)
+#define SCALE_4_8(VAL_) ((VAL_) * 0x11)
+#define SCALE_8_4(VAL_) ((VAL_) / 0x11)
+#define SCALE_3_8(VAL_) ((VAL_) * 0x24)
+#define SCALE_8_3(VAL_) ((VAL_) / 0x24)
+
+ubyte *RGBA16_RGBA32(const ubyte *aData, size_t aLength) {
+    ubyte *_Buffer = New<ubyte>(aLength * 2);
+    ubyte *pBuffer = _Buffer;
+    for (size_t i = 0; i != aLength; i += 2) {
+        ushort _Col  = (aData[i + 0] << 8) | aData[i + 1];
+        ubyte  _Red  = (_Col >> 11) & 0x1F;
+        ubyte  _Grn  = (_Col >>  6) & 0x1F;
+        ubyte  _Blu  = (_Col >>  1) & 0x1F;
+        ubyte  _Alp  = (_Col >>  0) & 0x01;
+        *(pBuffer++) = (SCALE_5_8(_Red));
+        *(pBuffer++) = (SCALE_5_8(_Grn));
+        *(pBuffer++) = (SCALE_5_8(_Blu));
+        *(pBuffer++) = (0xFF  *  (_Alp));
+    }
+    return _Buffer;
+}
+
+ubyte *RGBA32_RGBA32(const ubyte *aData, size_t aLength) {
+    ubyte *_Buffer = New<ubyte>(aLength * 1);
+    memcpy(_Buffer, aData, aLength);
+    return _Buffer;
+}
+
+ubyte *IA4_RGBA32(const ubyte *aData, size_t aLength) {
+    ubyte *_Buffer = New<ubyte>(aLength * 8);
+    ubyte *pBuffer = _Buffer;
+    for (size_t i = 0; i != aLength; ++i) {
+        ubyte _Half0 = (aData[i] >> 4) & 0xF;
+        *(pBuffer++) = (SCALE_3_8(_Half0 >> 1));
+        *(pBuffer++) = (SCALE_3_8(_Half0 >> 1));
+        *(pBuffer++) = (SCALE_3_8(_Half0 >> 1));
+        *(pBuffer++) = (0xFF  *  (_Half0 &  1));
+
+        ubyte _Half1 = (aData[i] >> 0) & 0xF;
+        *(pBuffer++) = (SCALE_3_8(_Half1 >> 1));
+        *(pBuffer++) = (SCALE_3_8(_Half1 >> 1));
+        *(pBuffer++) = (SCALE_3_8(_Half1 >> 1));
+        *(pBuffer++) = (0xFF  *  (_Half1 &  1));
+    }
+    return _Buffer;
+}
+
+ubyte *IA8_RGBA32(const ubyte *aData, size_t aLength) {
+    ubyte *_Buffer = New<ubyte>(aLength * 4);
+    ubyte *pBuffer = _Buffer;
+    for (size_t i = 0; i != aLength; ++i) {
+        ubyte _Col   = (aData[i] >> 4) & 0xF;
+        ubyte _Alp   = (aData[i] >> 0) & 0xF;
+        *(pBuffer++) = (SCALE_4_8(_Col));
+        *(pBuffer++) = (SCALE_4_8(_Col));
+        *(pBuffer++) = (SCALE_4_8(_Col));
+        *(pBuffer++) = (SCALE_4_8(_Alp));
+    }
+    return _Buffer;
+}
+
+ubyte *IA16_RGBA32(const ubyte *aData, size_t aLength) {
+    ubyte *_Buffer = New<ubyte>(aLength * 2);
+    ubyte *pBuffer = _Buffer;
+    for (size_t i = 0; i != aLength; i += 2) {
+        ubyte _Col   = aData[i + 0];
+        ubyte _Alp   = aData[i + 1];
+        *(pBuffer++) = (_Col);
+        *(pBuffer++) = (_Col);
+        *(pBuffer++) = (_Col);
+        *(pBuffer++) = (_Alp);
+    }
+    return _Buffer;
+}
+
+ubyte *CI4_RGBA32(const ubyte *aData, size_t aLength, const ubyte *aPalette) {
+    ubyte *_Buffer = New<ubyte>(aLength * 8);
+    ubyte *pBuffer = _Buffer;
+    for (size_t i = 0; i != aLength; ++i) {
+        ubyte  _Idx0 = (aData[i] >> 4) & 0xF;
+        ushort _Col0 = (aPalette[_Idx0 * 2 + 0] << 8) | aPalette[_Idx0 * 2 + 1];
+        ubyte  _Red0 = (_Col0 >> 11) & 0x1F;
+        ubyte  _Grn0 = (_Col0 >>  6) & 0x1F;
+        ubyte  _Blu0 = (_Col0 >>  1) & 0x1F;
+        ubyte  _Alp0 = (_Col0 >>  0) & 0x01;
+        *(pBuffer++) = (SCALE_5_8(_Red0));
+        *(pBuffer++) = (SCALE_5_8(_Grn0));
+        *(pBuffer++) = (SCALE_5_8(_Blu0));
+        *(pBuffer++) = (0xFF  *  (_Alp0));
+
+        ubyte  _Idx1 = (aData[i] >> 0) & 0xF;
+        ushort _Col1 = (aPalette[_Idx1 * 2 + 0] << 8) | aPalette[_Idx1 * 2 + 1];
+        ubyte  _Red1 = (_Col1 >> 11) & 0x1F;
+        ubyte  _Grn1 = (_Col1 >>  6) & 0x1F;
+        ubyte  _Blu1 = (_Col1 >>  1) & 0x1F;
+        ubyte  _Alp1 = (_Col1 >>  0) & 0x01;
+        *(pBuffer++) = (SCALE_5_8(_Red1));
+        *(pBuffer++) = (SCALE_5_8(_Grn1));
+        *(pBuffer++) = (SCALE_5_8(_Blu1));
+        *(pBuffer++) = (0xFF  *  (_Alp1));
+    }
+    return _Buffer;
+}
+
+ubyte *CI8_RGBA32(const ubyte *aData, size_t aLength, const ubyte *aPalette) {
+    ubyte *_Buffer = New<ubyte>(aLength * 4);
+    ubyte *pBuffer = _Buffer;
+    for (size_t i = 0; i != aLength; ++i) {
+        ubyte  _Idx  = aData[i];
+        ushort _Col  = (aPalette[_Idx * 2 + 0] << 8) | aPalette[_Idx * 2 + 1];
+        ubyte  _Red  = (_Col >> 11) & 0x1F;
+        ubyte  _Grn  = (_Col >>  6) & 0x1F;
+        ubyte  _Blu  = (_Col >>  1) & 0x1F;
+        ubyte  _Alp  = (_Col >>  0) & 0x01;
+        *(pBuffer++) = (SCALE_5_8(_Red));
+        *(pBuffer++) = (SCALE_5_8(_Grn));
+        *(pBuffer++) = (SCALE_5_8(_Blu));
+        *(pBuffer++) = (0xFF  *  (_Alp));
+    }
+    return _Buffer;
+}
+
+ubyte *I4_RGBA32(const ubyte *aData, size_t aLength) {
+    ubyte *_Buffer = New<ubyte>(aLength * 8);
+    ubyte *pBuffer = _Buffer;
+    for (size_t i = 0; i != aLength; ++i) {
+        ubyte _Half0 = (aData[i] >> 4) & 0xF;
+        *(pBuffer++) = (SCALE_4_8(_Half0));
+        *(pBuffer++) = (SCALE_4_8(_Half0));
+        *(pBuffer++) = (SCALE_4_8(_Half0));
+        *(pBuffer++) = (255);
+
+        ubyte _Half1 = (aData[i] >> 0) & 0xF;
+        *(pBuffer++) = (SCALE_4_8(_Half1));
+        *(pBuffer++) = (SCALE_4_8(_Half1));
+        *(pBuffer++) = (SCALE_4_8(_Half1));
+        *(pBuffer++) = (255);
+    }
+    return _Buffer;
+}
+
+ubyte *I8_RGBA32(const ubyte *aData, size_t aLength) {
+    ubyte *_Buffer = New<ubyte>(aLength * 4);
+    ubyte *pBuffer = _Buffer;
+    for (size_t i = 0; i != aLength; ++i) {
+        *(pBuffer++) = (aData[i]);
+        *(pBuffer++) = (aData[i]);
+        *(pBuffer++) = (aData[i]);
+        *(pBuffer++) = (255);
+    }
+    return _Buffer;
+}
+
+ubyte *ConvertToRGBA32(const ubyte *aData, size_t aLength, int aFormat, int aSize, const ubyte *aPalette) {
+    switch   ((aFormat       << 8) | aSize       ) {
+        case ((G_IM_FMT_RGBA << 8) | G_IM_SIZ_16b): return RGBA16_RGBA32(aData, aLength);
+        case ((G_IM_FMT_RGBA << 8) | G_IM_SIZ_32b): return RGBA32_RGBA32(aData, aLength);
+        case ((G_IM_FMT_IA   << 8) | G_IM_SIZ_4b ): return IA4_RGBA32   (aData, aLength);
+        case ((G_IM_FMT_IA   << 8) | G_IM_SIZ_8b ): return IA8_RGBA32   (aData, aLength);
+        case ((G_IM_FMT_IA   << 8) | G_IM_SIZ_16b): return IA16_RGBA32  (aData, aLength);
+        case ((G_IM_FMT_CI   << 8) | G_IM_SIZ_4b ): return CI4_RGBA32   (aData, aLength, aPalette);
+        case ((G_IM_FMT_CI   << 8) | G_IM_SIZ_8b ): return CI8_RGBA32   (aData, aLength, aPalette);
+        case ((G_IM_FMT_I    << 8) | G_IM_SIZ_4b ): return I4_RGBA32    (aData, aLength);
+        case ((G_IM_FMT_I    << 8) | G_IM_SIZ_8b ): return I8_RGBA32    (aData, aLength);
+    }
+    return NULL;
+}
+
+//
+// Texture load
+//
+
+static DataNodes<TexData> sLoadedTextureNodes;
+DataNode<TexData> *DynOS_Gfx_GetTexture(const String &aTextureName) {
+    for (auto &_Node : sLoadedTextureNodes) {
+        if (_Node->mName == aTextureName) {
+            return _Node;
+        }
+    }
+    return NULL;
+}
+
+bool DynOS_Gfx_IsLoadedTexturePointer(void *aPtr) {
+    for (auto &_Node : sLoadedTextureNodes) {
+        if ((void *) _Node == aPtr) {
+            return true;
+        }
+    }
+    return false;
+}
+
+bool DynOS_Gfx_IsTexturePointer(void *aPtr) {
+
+    // Actors textures
+    Array<ActorGfx> &pActorGfxList = DynOS_Gfx_GetActorList();
+    for (auto& _ActorGfx : pActorGfxList) {
+        if (_ActorGfx.mGfxData) {
+            for (auto &_Node : _ActorGfx.mGfxData->mTextures) {
+                if ((void *) _Node == aPtr) {
+                    return true;
+                }
+            }
+        }
+    }
+
+    // Loaded textures
+    return DynOS_Gfx_IsLoadedTexturePointer(aPtr);
+}
+
+DataNode<TexData> *DynOS_Gfx_LoadTextureRAW(const ubyte *aRGBA32Buffer, int aWidth, int aHeight, const String &aTextureName) {
+
+    // Check if the texture is already loaded
+    DataNode<TexData> *_Node = DynOS_Gfx_GetTexture(aTextureName);
+    if (_Node) {
+        return _Node;
+    }
+
+    // NULL check
+    if (!aRGBA32Buffer || aWidth <= 0 || aHeight <= 0 || aTextureName.Empty()) {
+        return NULL;
+    }
+
+    // Create a new _Node
+    _Node                    = New<DataNode<TexData>>();
+    _Node->mName             = aTextureName;
+    _Node->mData             = New<TexData>();
+    _Node->mData->mRawData   = Array<ubyte>(aRGBA32Buffer, aRGBA32Buffer + (aWidth * aHeight * 4));
+    _Node->mData->mRawWidth  = aWidth;
+    _Node->mData->mRawHeight = aHeight;
+    _Node->mData->mRawFormat = G_IM_FMT_RGBA;
+    _Node->mData->mRawSize   = G_IM_SIZ_32b;
+    _Node->mData->mUploaded  = false;
+    _Node->mData->mBind      = NULL;
+
+    // Append
+    sLoadedTextureNodes.Add(_Node);
+    return _Node;
+}
+
+DataNode<TexData> *DynOS_Gfx_LoadTexturePNG(const ubyte *aPngData, uint aPngLength, const String &aTextureName) {
+
+    // Check if the texture is already loaded
+    DataNode<TexData> *_Node = DynOS_Gfx_GetTexture(aTextureName);
+    if (_Node) {
+        return _Node;
+    }
+
+    // NULL check
+    if (!aPngData || !aPngLength || aTextureName.Empty()) {
+        return NULL;
+    }
+
+    // Load png
+    int _RawWidth, _RawHeight;
+    ubyte *_RawData = stbi_load_from_memory(aPngData, aPngLength, &_RawWidth, &_RawHeight, NULL, 4);
+    if (!_RawData) {
+        return NULL;
+    }
+
+    // Create a new _Node
+    _Node                    = New<DataNode<TexData>>();
+    _Node->mName             = aTextureName;
+    _Node->mData             = New<TexData>();
+    _Node->mData->mRawData   = Array<ubyte>(_RawData, _RawData + (_RawWidth * _RawHeight * 4));
+    _Node->mData->mRawWidth  = _RawWidth;
+    _Node->mData->mRawHeight = _RawHeight;
+    _Node->mData->mRawFormat = G_IM_FMT_RGBA;
+    _Node->mData->mRawSize   = G_IM_SIZ_32b;
+    _Node->mData->mUploaded  = false;
+    _Node->mData->mBind      = NULL;
+    Delete(_RawData);
+
+    // Append
+    sLoadedTextureNodes.Add(_Node);
+    return _Node;
+}
+
+DataNode<TexData> *DynOS_Gfx_LoadTextureFile(const SysPath &aFilename, const String &aTextureName) {
+
+    // Check if the texture is already loaded
+    DataNode<TexData> *_Node = DynOS_Gfx_GetTexture(aTextureName);
+    if (_Node) {
+        return _Node;
+    }
+
+    // Open file
+    FILE *_File = fopen(aFilename.c_str(), "rb");
+    if (!_File) {
+        return NULL;
+    }
+
+    // Load from PNG
+    fseek(_File, 0, SEEK_END);
+    uint _PngLength = ftell(_File); rewind(_File);
+    ubyte *_PngData = New<ubyte>(_PngLength);
+    fread(_PngData, sizeof(ubyte), _PngLength, _File);
+    fclose(_File);
+
+    _Node = DynOS_Gfx_LoadTexturePNG(_PngData, _PngLength, aTextureName);
+    free(_PngData);
+    return _Node;
+}
+
+// _Node MUST be a Loaded Texture _Node pointer
+// bind MUST be a DynOS Texture _Node pointer
+void DynOS_Gfx_BindTexture(DataNode<TexData> *aNode, void *aBind) {
+    if (DynOS_Gfx_IsLoadedTexturePointer(aNode) &&
+        DynOS_Gfx_IsTexturePointer(aBind)) {
+        aNode->mData->mBind = aBind;
+    }
+}
+
+void DynOS_Gfx_UnloadTexture(DataNode<TexData> *aNode) {
+
+    // Unload all textures bound to aNode
+    // Restart the loop everytime a texture is unloaded to avoid desyncs
+    for (bool _Unload = true; _Unload;) {
+        _Unload = false;
+        for (auto& _Node : sLoadedTextureNodes) {
+            if (_Node->mData->mBind == (void *) aNode) {
+                DynOS_Gfx_UnloadTexture(_Node);
+                _Unload = true;
+                break;
+            }
+        }
+    }
+
+    // Free the texture node
+    int _TextureNodeIndex = sLoadedTextureNodes.Find(aNode);
+    if (_TextureNodeIndex != -1) {
+        sLoadedTextureNodes.Remove(_TextureNodeIndex);
+    }
+    Delete(aNode->mData);
+    Delete(aNode);
+}
+
+//
+// Upload
+//
+
+typedef struct GfxRenderingAPI GRAPI;
+static void DynOS_Gfx_UploadTexture(DataNode<TexData> *aNode, GRAPI *aGfxRApi, int aTile, int aTexId) {
+    aGfxRApi->select_texture(aTile, aTexId);
+    aGfxRApi->upload_texture(aNode->mData->mRawData.begin(), aNode->mData->mRawWidth, aNode->mData->mRawHeight);
+    aNode->mData->mUploaded = true;
+}
+
+//
+// Cache
+//
+
+struct THN {
+    struct THN *mNext;
+    const void *mAddr; // Contains the pointer to the DataNode<TexData> struct, NOT the actual texture data
+    ubyte mFmt, mSiz;
+    int mTexId;
+    ubyte mCms, mCmt;
+    bool mLInf;
+};
+
+static bool DynOS_Gfx_CacheTexture(THN **aOutput, DataNode<TexData> *aNode, int aTile, GRAPI *aGfxRApi, THN **aHashMap, THN *aPool, uint *aPoolPos, uint aPoolSize) {
+
+    // Find texture in cache
+    ulong _Hash = ((uintptr_t) aNode) & ((aPoolSize * 2) - 1);
+    THN **_Node = &(aHashMap[_Hash]);
+    while ((*_Node) != NULL && ((*_Node) - aPool) < (*aPoolPos)) {
+        if ((*_Node)->mAddr == (const void *) aNode) {
+            aGfxRApi->select_texture(aTile, (*_Node)->mTexId);
+            if (!aNode->mData->mUploaded) {
+                DynOS_Gfx_UploadTexture(aNode, aGfxRApi, aTile, (*_Node)->mTexId);
+            }
+            (*aOutput) = (*_Node);
+            return true;
+        }
+        _Node = &(*_Node)->mNext;
+    }
+
+    // If cache is full, clear cache
+    if ((*aPoolPos) == aPoolSize) {
+        (*aPoolPos) = 0;
+        _Node = &aHashMap[_Hash];
+    }
+
+    // Add new texture to cache
+    (*_Node) = &aPool[(*aPoolPos)++];
+    if (!(*_Node)->mAddr) {
+        (*_Node)->mTexId = aGfxRApi->new_texture();
+    }
+    aGfxRApi->select_texture(aTile, (*_Node)->mTexId);
+    aGfxRApi->set_sampler_parameters(aTile, false, 0, 0);
+    (*_Node)->mCms  = 0;
+    (*_Node)->mCmt  = 0;
+    (*_Node)->mLInf = false;
+    (*_Node)->mNext = NULL;
+    (*_Node)->mAddr = aNode;
+    (*_Node)->mFmt  = G_IM_FMT_RGBA;
+    (*_Node)->mSiz  = G_IM_SIZ_32b;
+    (*aOutput)      = (*_Node);
+    return false;
+}
+
+//
+// Import
+//
+
+static bool DynOS_Gfx_ImportTexture_Typed(THN **aOutput, void *aPtr, int aTile, GRAPI *aGfxRApi, THN **aHashMap, THN *aPool, uint *aPoolPos, uint aPoolSize) {
+
+    // Actors textures
+    Array<ActorGfx> &pActorGfxList = DynOS_Gfx_GetActorList();
+    for (auto& _ActorGfx : pActorGfxList) {
+        if (_ActorGfx.mGfxData) {
+            for (auto &_Node : _ActorGfx.mGfxData->mTextures) {
+                if ((void *) _Node == aPtr) {
+                    if (!DynOS_Gfx_CacheTexture(aOutput, _Node, aTile, aGfxRApi, aHashMap, aPool, aPoolPos, aPoolSize)) {
+                        DynOS_Gfx_UploadTexture(_Node, aGfxRApi, aTile, (*aOutput)->mTexId);
+                    }
+                    return true;
+                }
+            }
+        }
+    }
+
+    // Loaded textures
+    for (auto &_Node : sLoadedTextureNodes) {
+        if ((void *) _Node == aPtr) {
+            if (!DynOS_Gfx_CacheTexture(aOutput, _Node, aTile, aGfxRApi, aHashMap, aPool, aPoolPos, aPoolSize)) {
+                DynOS_Gfx_UploadTexture(_Node, aGfxRApi, aTile, (*aOutput)->mTexId);
+            }
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool DynOS_Gfx_ImportTexture(void **aOutput, void *aPtr, int aTile, void *aGfxRApi, void **aHashMap, void *aPool, uint *aPoolPos, uint aPoolSize) {
+    return DynOS_Gfx_ImportTexture_Typed(
+        (THN **)  aOutput,
+        (void *)  aPtr,
+        (int)     aTile,
+        (GRAPI *) aGfxRApi,
+        (THN **)  aHashMap,
+        (THN *)   aPool,
+        (uint *)  aPoolPos,
+        (uint)    aPoolSize
+    );
+}
diff --git a/data/dynos_gfx_update.cpp b/data/dynos_gfx_update.cpp
new file mode 100644
index 0000000..1c7e4d9
--- /dev/null
+++ b/data/dynos_gfx_update.cpp
@@ -0,0 +1,224 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "object_fields.h"
+#include "game/level_update.h"
+#include "game/object_list_processor.h"
+}
+
+//
+// Free data
+// Must be unloaded the next frame to prevent a crash
+//
+
+static Array<GfxData *> sGfxDataFreeList;
+static Array<GraphNode *> sGraphNodeFreeList;
+static void DynOS_Gfx_FreeUnloaded() {
+    for (auto &_GfxData : sGfxDataFreeList) DynOS_Gfx_Free(_GfxData);
+    for (auto &_GraphNode : sGraphNodeFreeList) Delete(_GraphNode);
+    sGfxDataFreeList.Clear();
+    sGraphNodeFreeList.Clear();
+}
+
+//
+// Update animations
+//
+
+// Retrieve the current Mario's animation index
+static int RetrieveCurrentMarioAnimationIndex() {
+    struct MarioAnimDmaRelatedThing *_AnimDmaTable = gMarioState->animation->animDmaTable;
+    for (int i = 0; i != (int) _AnimDmaTable->count; ++i) {
+        void *_AnimAddr = _AnimDmaTable->srcAddr + _AnimDmaTable->anim[i].offset;
+        if (_AnimAddr == gMarioState->animation->currentAnimAddr) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+// Retrieve the current animation index
+// As we don't know the length of the table, let's hope that we'll always find the animation...
+static int RetrieveCurrentAnimationIndex(struct Object *aObject) {
+    if (!aObject->oAnimations || !aObject->header.gfx.unk38.curAnim) {
+        return -1;
+    }
+    for (int i = 0; aObject->oAnimations[i] != NULL; ++i) {
+        if (aObject->oAnimations[i] == aObject->header.gfx.unk38.curAnim) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+// Must be called twice, before and after geo_set_animation_globals
+void DynOS_Gfx_UpdateAnimation(void *aPtr) {
+    static Animation *pDefaultAnimation = NULL;
+    static Animation  sGfxDataAnimation;
+
+    // Does the object has a model?
+    struct Object *_Object = (struct Object *) aPtr;
+    if (!_Object->header.gfx.sharedChild) {
+        return;
+    }
+
+    // Swap the current animation with the one from the Gfx data
+    if (!pDefaultAnimation) {
+        pDefaultAnimation = _Object->header.gfx.unk38.curAnim;
+
+        // Actor index
+        int _ActorIndex = DynOS_Geo_GetActorIndex(_Object->header.gfx.sharedChild->georef);
+        if (_ActorIndex == -1) {
+            return;
+        }
+
+        // Gfx data
+        GfxData *_GfxData = DynOS_Gfx_GetActorList()[_ActorIndex].mGfxData;
+        if (!_GfxData) {
+            return;
+        }
+
+        // Animation table
+        if (_GfxData->mAnimationTable.Empty()) {
+            return;
+        }
+
+        // Animation index
+        int _AnimIndex = (_Object == gMarioObject ? RetrieveCurrentMarioAnimationIndex() : RetrieveCurrentAnimationIndex(_Object));
+        if (_AnimIndex == -1) {
+            return;
+        }
+
+        // Animation data
+        const AnimData *_AnimData = (const AnimData *) _GfxData->mAnimationTable[_AnimIndex].second;
+        if (_AnimData) {
+            sGfxDataAnimation.flags  = _AnimData->mFlags;
+            sGfxDataAnimation.unk02  = _AnimData->mUnk02;
+            sGfxDataAnimation.unk04  = _AnimData->mUnk04;
+            sGfxDataAnimation.unk06  = _AnimData->mUnk06;
+            sGfxDataAnimation.unk08  = _AnimData->mUnk08;
+            sGfxDataAnimation.unk0A  = _AnimData->mUnk0A.second;
+            sGfxDataAnimation.values = _AnimData->mValues.second.begin();
+            sGfxDataAnimation.index  = _AnimData->mIndex.second.begin();
+            sGfxDataAnimation.length = _AnimData->mLength;
+            _Object->header.gfx.unk38.curAnim = &sGfxDataAnimation;
+        }
+
+    // Restore the default animation
+    } else {
+        _Object->header.gfx.unk38.curAnim = pDefaultAnimation;
+        pDefaultAnimation = NULL;
+    }
+}
+
+//
+// Update Gfx dynamic commands
+//
+
+static void DynOS_Gfx_UpdateDynCmd(GfxDynCmd *aCmd) {
+    switch (aCmd->mType) {
+        case GFXDYNCMD_CAPPY_EYES:
+            if (DynOS_Opt_GetValue("omm_cappy") != 0) {
+                gDPNoOp(aCmd->mData + aCmd->mOffset);
+            } else {
+                gSPEndDisplayList(aCmd->mData + aCmd->mOffset);
+            }
+            break;
+    }
+}
+
+static void DynOS_Gfx_UpdateDynCmds(int aActorIndex) {
+    GfxData *_GfxData = DynOS_Gfx_GetActorList()[aActorIndex].mGfxData;
+    if (_GfxData) {
+        for (auto& _Cmd : _GfxData->mGfxDynCmds) {
+            DynOS_Gfx_UpdateDynCmd(&_Cmd);
+        }
+    }
+}
+
+//
+// Update models
+//
+
+static void DynOS_Gfx_UpdateModelData(struct Object *aObject, int aActorIndex) {
+    ActorGfx *_ActorGfx = &DynOS_Gfx_GetActorList()[aActorIndex];
+    const Array<SysPath> &pPacks = DynOS_Gfx_GetPackList();
+    for (int i = 0; i != pPacks.Count(); ++i) {
+
+        // Pack
+        bool _Enabled = DynOS_Opt_GetValue(String("dynos_pack_%d", i));
+
+        // If enabled and no pack is selected
+        // load the pack's model and replace the default actor's model
+        if (_Enabled && _ActorGfx->mPackIndex == -1) {
+
+            // Load Gfx data from binary
+            SysPath _Filename = fstring("%s/%s.bin", pPacks[i].begin(), DynOS_Geo_GetActorName(aActorIndex));
+            GfxData *_GfxData = DynOS_Gfx_LoadFromBinary(_Filename);
+            if (_GfxData == NULL) {
+                continue;
+            }
+
+            // Mark previous model data as unload
+            if (_ActorGfx->mGfxData) sGfxDataFreeList.Add(_ActorGfx->mGfxData);
+            if (_ActorGfx->mGraphNode) sGraphNodeFreeList.Add(_ActorGfx->mGraphNode);
+
+            // Load graph node and animations
+            _ActorGfx->mPackIndex = i;
+            _ActorGfx->mGfxData   = _GfxData;
+            _ActorGfx->mGraphNode = (GraphNode *) DynOS_Geo_GetGraphNode((*(_GfxData->mGeoLayouts.end() - 1))->mData, false);
+            _ActorGfx->mGraphNode->georef = DynOS_Geo_GetActorLayout(aActorIndex);
+            break;
+        }
+
+        // If disabled and this pack is the one selected
+        // unload the pack's model and replace the actor's model by the default one
+        else if (!_Enabled && _ActorGfx->mPackIndex == i) {
+
+            // Mark previous model data as unload
+            if (_ActorGfx->mGfxData) sGfxDataFreeList.Add(_ActorGfx->mGfxData);
+            if (_ActorGfx->mGraphNode) sGraphNodeFreeList.Add(_ActorGfx->mGraphNode);
+
+            // Default
+            _ActorGfx->mPackIndex = -1;
+            _ActorGfx->mGfxData   = NULL;
+            _ActorGfx->mGraphNode = (GraphNode *) DynOS_Geo_GetGraphNode(DynOS_Geo_GetActorLayout(aActorIndex), false);
+        }
+    }
+
+    // Update object
+    aObject->header.gfx.sharedChild = _ActorGfx->mGraphNode;
+}
+
+void DynOS_Gfx_Update() {
+
+    // Don't update until the object lists are loaded
+    if (!gObjectLists) {
+        return;
+    }
+
+    // Free unloaded things
+    DynOS_Gfx_FreeUnloaded();
+
+    // Update per object
+    for (int _List = 0; _List != NUM_OBJ_LISTS; ++_List) {
+        struct Object *_Head = (struct Object *) &gObjectLists[_List];
+        for (struct Object *_Object = (struct Object *) _Head->header.next; _Object != _Head; _Object = (struct Object *) _Object->header.next) {
+
+            // Does the object has a model?
+            if (!_Object->header.gfx.sharedChild) {
+                continue;
+            }
+
+            // Actor index
+            int _ActorIndex = DynOS_Geo_GetActorIndex(_Object->header.gfx.sharedChild->georef);
+            if (_ActorIndex == -1) {
+                continue;
+            }
+
+            // Replace the object's model and animations
+            DynOS_Gfx_UpdateModelData(_Object, _ActorIndex);
+
+            // Update display lists dynamic commands
+            DynOS_Gfx_UpdateDynCmds(_ActorIndex);
+        }
+    }
+}
diff --git a/data/dynos_gfx_write.cpp b/data/dynos_gfx_write.cpp
new file mode 100644
index 0000000..3fa8875
--- /dev/null
+++ b/data/dynos_gfx_write.cpp
@@ -0,0 +1,345 @@
+#include "dynos.cpp.h"
+
+//
+// Pointers
+//
+
+typedef Pair<String, uint> PointerData;
+static PointerData GetDataFromPointer(const void* aPtr, GfxData* aGfxData) {
+
+    // Lights
+    for (auto& _Node : aGfxData->mLights) {
+        if (&_Node->mData->l[0] == aPtr) { // Light *, not Lights1 *
+            return { _Node->mName, 1 };
+        }
+        if (&_Node->mData->a == aPtr) { // Ambient *, not Lights1 *
+            return { _Node->mName, 2 };
+        }
+    }
+
+    // Textures
+    for (auto& _Node : aGfxData->mTextures) {
+        if (_Node == aPtr) {
+            return { _Node->mName, 0 };
+        }
+    }
+
+    // Display lists
+    for (auto& _Node : aGfxData->mDisplayLists) {
+        if (_Node == aPtr) {
+            return { _Node->mName, 0 };
+        }
+    }
+
+    // Geo layouts
+    for (auto& _Node : aGfxData->mGeoLayouts) {
+        if (_Node->mData == aPtr) {
+            return { _Node->mName, 0 };
+        }
+    }
+
+    // Vertices
+    String _VtxArrayName = "";
+    uintptr_t _VtxArrayStart = 0;
+    for (auto& _Node : aGfxData->mVertices) {
+        if (_Node->mData == aPtr) {
+            return { _Node->mName, 0 };
+        }
+        if ((uintptr_t)_Node->mData <= (uintptr_t)aPtr &&
+            (uintptr_t)_Node->mData >= _VtxArrayStart) {
+            _VtxArrayName = _Node->mName;
+            _VtxArrayStart = (uintptr_t)_Node->mData;
+        }
+    }
+    return { _VtxArrayName, (uint)((const Vtx*)aPtr - (const Vtx*)_VtxArrayStart) };
+}
+
+static void WritePointer(FILE* aFile, const void* aPtr, GfxData* aGfxData) {
+
+    // NULL
+    if (!aPtr) {
+        WriteBytes<uint>(aFile, 0);
+        return;
+    }
+
+    // Geo function
+    int _GeoFunctionIndex = DynOS_Geo_GetFunctionIndex(aPtr);
+    if (_GeoFunctionIndex != -1) {
+        WriteBytes<uint>(aFile, FUNCTION_CODE);
+        WriteBytes<int>(aFile, _GeoFunctionIndex);
+        return;
+    }
+
+    // Pointer
+    PointerData _PtrData = GetDataFromPointer(aPtr, aGfxData);
+    WriteBytes<uint>(aFile, POINTER_CODE);
+    _PtrData.first.Write(aFile);
+    WriteBytes<uint>(aFile, _PtrData.second);
+}
+
+//
+// Lights
+//
+
+static void WriteLightData(FILE* aFile, GfxData* aGfxData, DataNode<Lights1> *aNode) {
+    if (!aNode->mData) return;
+
+    // Header
+    WriteBytes<ubyte>(aFile, DATA_TYPE_LIGHT);
+    aNode->mName.Write(aFile);
+
+    // Data
+    WriteBytes<Lights1>(aFile, *aNode->mData);
+}
+
+//
+// Textures
+//
+
+static void WriteTextureData(FILE* aFile, GfxData* aGfxData, DataNode<TexData> *aNode) {
+    if (!aNode->mData) return;
+
+    // Header
+    WriteBytes<ubyte>(aFile, DATA_TYPE_TEXTURE);
+    aNode->mName.Write(aFile);
+
+    // Data
+    aNode->mData->mPngData.Write(aFile);
+}
+
+//
+// Vertices
+//
+
+static void WriteVertexData(FILE* aFile, GfxData* aGfxData, DataNode<Vtx> *aNode) {
+    if (!aNode->mData) return;
+
+    // Header
+    WriteBytes<ubyte>(aFile, DATA_TYPE_VERTEX);
+    aNode->mName.Write(aFile);
+
+    // Data
+    WriteBytes<uint>(aFile, aNode->mSize);
+    for (uint i = 0; i != aNode->mSize; ++i) {
+        WriteBytes<short>(aFile, aNode->mData[i].n.ob[0]);
+        WriteBytes<short>(aFile, aNode->mData[i].n.ob[1]);
+        WriteBytes<short>(aFile, aNode->mData[i].n.ob[2]);
+        WriteBytes<short>(aFile, aNode->mData[i].n.flag);
+        WriteBytes<short>(aFile, aNode->mData[i].n.tc[0]);
+        WriteBytes<short>(aFile, aNode->mData[i].n.tc[1]);
+        WriteBytes<byte> (aFile, aNode->mData[i].n.n[0]);
+        WriteBytes<byte> (aFile, aNode->mData[i].n.n[1]);
+        WriteBytes<byte> (aFile, aNode->mData[i].n.n[2]);
+        WriteBytes<ubyte>(aFile, aNode->mData[i].n.a);
+    }
+}
+
+//
+// Display lists
+//
+
+static void WriteDisplayListData(FILE *aFile, GfxData *aGfxData, DataNode<Gfx> *aNode) {
+    if (!aNode->mData) return;
+
+    // Header
+    WriteBytes<ubyte>(aFile, DATA_TYPE_DISPLAY_LIST);
+    aNode->mName.Write(aFile);
+
+    // Data
+    WriteBytes<uint>(aFile, aNode->mSize);
+    for (uint i = 0; i != aNode->mSize; ++i) {
+        Gfx *_Head = &aNode->mData[i];
+        if (aGfxData->mPointerList.Find((void *) _Head) != -1) {
+            WriteBytes<uint>(aFile, _Head->words.w0);
+            WritePointer(aFile, (const void *) _Head->words.w1, aGfxData);
+        } else {
+            WriteBytes<uint>(aFile, _Head->words.w0);
+            WriteBytes<uint>(aFile, _Head->words.w1);
+        }
+    }
+}
+
+//
+// Geo layouts
+//
+
+static void WriteGeoLayoutData(FILE *aFile, GfxData *aGfxData, DataNode<GeoLayout> *aNode) {
+    if (!aNode->mData) return;
+
+    // Header
+    WriteBytes<ubyte>(aFile, DATA_TYPE_GEO_LAYOUT);
+    aNode->mName.Write(aFile);
+
+    // Data
+    WriteBytes<uint>(aFile, aNode->mSize);
+    for (uint i = 0; i != aNode->mSize; ++i) {
+        GeoLayout *_Head = &aNode->mData[i];
+        if (aGfxData->mPointerList.Find((void *) _Head) != -1) {
+            WritePointer(aFile, (const void *) (*_Head), aGfxData);
+        } else {
+            WriteBytes<uint>(aFile, *((uint *) _Head));
+        }
+    }
+}
+
+//
+// Dynamic commands
+//
+
+static String GetDisplayListNameFromData(GfxData* aGfxData, const Gfx* aData) {
+    for (auto& _Node : aGfxData->mDisplayLists) {
+        if (_Node->mData == aData) {
+            return _Node->mName;
+        }
+    }
+    return "";
+}
+
+static void WriteGfxDynCmds(FILE* aFile, GfxData* aGfxData) {
+    for (auto& _Cmd : aGfxData->mGfxDynCmds) {
+
+        // Header
+        WriteBytes<ubyte>(aFile, DATA_TYPE_GFXDYNCMD);
+
+        // Data
+        String _DisplayListName = GetDisplayListNameFromData(aGfxData, _Cmd.mData);
+        _DisplayListName.Write(aFile);
+        WriteBytes<uint>(aFile, _Cmd.mOffset);
+        WriteBytes<ubyte>(aFile, _Cmd.mType);
+    }
+}
+
+//
+// Animation data
+//
+
+static void WriteAnimationData(FILE* aFile, GfxData* aGfxData) {
+    for (auto& _Node : aGfxData->mAnimations) {
+
+        // Value buffer
+        int _ValueBufferIdx = aGfxData->mAnimValues.FindIf([&_Node](const AnimBuffer<short> *aAnimBuffer) { return aAnimBuffer->first == _Node->mData->mValues.first; });
+        if (_ValueBufferIdx == -1) {
+            continue;
+        }
+
+        // Index buffer
+        int _IndexBufferIdx = aGfxData->mAnimIndices.FindIf([&_Node](const AnimBuffer<ushort> *aAnimBuffer) { return aAnimBuffer->first == _Node->mData->mIndex.first; });
+        if (_IndexBufferIdx == -1) {
+            continue;
+        }
+
+        // Unk0A buffer
+        int _Unk0ABufferIdx = aGfxData->mAnimIndices.FindIf([&_Node](const AnimBuffer<ushort> *aAnimBuffer) { return aAnimBuffer->first == _Node->mData->mUnk0A.first; });
+        if (_Unk0ABufferIdx == -1) {
+            continue;
+        }
+
+        // Header
+        WriteBytes<ubyte>(aFile, DATA_TYPE_ANIMATION);
+        _Node->mName.Write(aFile);
+
+        // Data
+        WriteBytes<short>(aFile, _Node->mData->mFlags);
+        WriteBytes<short>(aFile, _Node->mData->mUnk02);
+        WriteBytes<short>(aFile, _Node->mData->mUnk04);
+        WriteBytes<short>(aFile, _Node->mData->mUnk06);
+        WriteBytes<short>(aFile, _Node->mData->mUnk08);
+        WriteBytes<short>(aFile, (aGfxData->mAnimIndices[_Unk0ABufferIdx]->second.Count() / 6) - 1);
+        WriteBytes<uint>(aFile, _Node->mData->mLength);
+        aGfxData->mAnimValues[_ValueBufferIdx]->second.Write(aFile);
+        aGfxData->mAnimIndices[_IndexBufferIdx]->second.Write(aFile);
+    }
+}
+
+//
+// Animation table
+//
+
+static void WriteAnimationTable(FILE* aFile, GfxData* aGfxData) {
+    for (auto& _AnimName : aGfxData->mAnimationTable) {
+
+        // Header
+        WriteBytes<ubyte>(aFile, DATA_TYPE_ANIMATION_TABLE);
+
+        // Data
+        _AnimName.first.Write(aFile);
+    }
+}
+
+//
+// Write
+//
+
+bool DynOS_Gfx_WriteBinary(const SysPath &aOutputFilename, GfxData *aGfxData) {
+    FILE *_File = fopen(aOutputFilename.c_str(), "wb");
+    if (!_File) {
+        PrintError("  ERROR: Unable to create file \"%s\"", aOutputFilename.c_str());
+        return false;
+    }
+
+    for (size_t i = 0; i != aGfxData->mLoadIndex; ++i) {
+        for (auto &_Node : aGfxData->mLights) {
+            if (_Node->mLoadIndex == i) {
+                WriteLightData(_File, aGfxData, _Node);
+            }
+        }
+        for (auto &_Node : aGfxData->mTextures) {
+            if (_Node->mLoadIndex == i) {
+                WriteTextureData(_File, aGfxData, _Node);
+            }
+        }
+        for (auto &_Node : aGfxData->mVertices) {
+            if (_Node->mLoadIndex == i) {
+                WriteVertexData(_File, aGfxData, _Node);
+            }
+        }
+        for (auto &_Node : aGfxData->mDisplayLists) {
+            if (_Node->mLoadIndex == i) {
+                WriteDisplayListData(_File, aGfxData, _Node);
+            }
+        }
+        for (auto &_Node : aGfxData->mGeoLayouts) {
+            if (_Node->mLoadIndex == i) {
+                WriteGeoLayoutData(_File, aGfxData, _Node);
+            }
+        }
+    }
+    WriteGfxDynCmds(_File, aGfxData);
+    WriteAnimationData(_File, aGfxData);
+    WriteAnimationTable(_File, aGfxData);
+    fclose(_File);
+    return true;
+}
+
+//
+// Free
+//
+
+void DynOS_Gfx_Free(GfxData* aGfxData) {
+    if (aGfxData) {
+        for (auto& _Node : aGfxData->mLights) {
+            Delete(_Node->mData);
+            Delete(_Node);
+        }
+        for (auto& _Node : aGfxData->mTextures) {
+            DynOS_Gfx_UnloadTexture(_Node);
+        }
+        for (auto& _Node : aGfxData->mVertices) {
+            Delete(_Node->mData);
+            Delete(_Node);
+        }
+        for (auto& _Node : aGfxData->mDisplayLists) {
+            Delete(_Node->mData);
+            Delete(_Node);
+        }
+        for (auto& _Node : aGfxData->mGeoLayouts) {
+            Delete(_Node->mData);
+            Delete(_Node);
+        }
+        for (auto& _Node : aGfxData->mAnimations) {
+            Delete(_Node->mData);
+            Delete(_Node);
+        }
+        Delete(aGfxData);
+    }
+}
diff --git a/data/dynos_main.cpp b/data/dynos_main.cpp
new file mode 100644
index 0000000..2859407
--- /dev/null
+++ b/data/dynos_main.cpp
@@ -0,0 +1,366 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "sm64.h"
+#include "seq_ids.h"
+#include "course_table.h"
+#include "audio/external.h"
+#include "engine/level_script.h"
+#include "game/ingame_menu.h"
+#include "game/level_update.h"
+#include "game/mario.h"
+#include "game/mario_step.h"
+#include "game/object_list_processor.h"
+#include "game/options_menu.h"
+#include "game/sound_init.h"
+extern char  gDialogBoxState;
+extern short gMenuMode;
+extern short gCutsceneTimer;
+extern void  set_play_mode(short);
+}
+
+static int  sDynosWarpLevelNum    = -1;
+static int  sDynosWarpActNum      = -1;
+static bool sDynosWarpToCastle    = false;
+static bool sDynosLevelExit       = false;
+static uint sDynosLevelExitAction = 0;
+
+//
+// Warps
+//
+
+bool DynOS_WarpToLevel(int aLevel, int aAct) {
+    if (DynOS_Level_GetCourse(aLevel) == COURSE_NONE) return false;
+    sDynosWarpLevelNum = aLevel;
+    sDynosWarpActNum   = aAct;
+    sDynosWarpToCastle = false;
+    return true;
+}
+
+bool DynOS_RestartLevel() {
+    int aLevel = gCurrLevelNum;
+    if (aLevel == LEVEL_BOWSER_1) aLevel = LEVEL_BITDW;
+    if (aLevel == LEVEL_BOWSER_2) aLevel = LEVEL_BITFS;
+    if (aLevel == LEVEL_BOWSER_3) aLevel = LEVEL_BITS;
+    return DynOS_WarpToLevel(aLevel, gCurrActNum);
+}
+
+bool DynOS_ExitLevel(int aDelay) {
+    int courseNum = DynOS_Level_GetCourse(gCurrLevelNum);
+    if (courseNum == COURSE_NONE) {
+        return false;
+    }
+
+    // Close the pause menu if it was open
+    optmenu_toggle();
+    level_set_transition(0, NULL);
+    gDialogBoxState = 0;
+    gMenuMode = -1;
+
+    // Trigger a special death warp
+    gMarioState->invincTimer = -1;
+    sDelayedWarpArg = 0;
+    sDelayedWarpOp = WARP_OP_DEATH;
+    sDelayedWarpTimer = MAX(1, aDelay);
+    sSourceWarpNodeId = 0xF1;
+    play_transition(WARP_TRANSITION_FADE_INTO_MARIO, sDelayedWarpTimer, 0x00, 0x00, 0x00);
+    set_play_mode(0);
+    sDynosLevelExit = true;
+    return true;
+}
+
+bool DynOS_WarpToCastle(int aLevel) {
+    if (DynOS_Level_GetCourse(aLevel) == COURSE_NONE) return false;
+    sDynosWarpLevelNum = aLevel;
+    sDynosWarpActNum   = 0;
+    sDynosWarpToCastle = true;
+    return true;
+}
+
+bool DynOS_ReturnToMainMenu() {
+
+    // Close the pause menu if it was open
+    optmenu_toggle();
+    level_set_transition(0, NULL);
+    gDialogBoxState = 0;
+    gMenuMode = -1;
+
+    // Warp to the main menu
+    fade_into_special_warp(-2, 0);
+    return true;
+}
+
+//
+// Routines
+//
+
+struct DynosRoutineParams {
+    DynosRoutine mRoutine;
+    void *mData;
+};
+
+static Array<DynosRoutineParams> &DynOS_GetRoutines(ubyte aType) {
+    static Array<DynosRoutineParams> sDynosRoutines[3];
+    return sDynosRoutines[aType];
+}
+
+static void DynOS_ExecuteRoutines(ubyte aType) {
+    Array<DynosRoutineParams> &_Routines = DynOS_GetRoutines(aType);
+    for (auto& _Routine : _Routines) {
+        _Routine.mRoutine(_Routine.mData);
+    }
+}
+
+void DynOS_AddRoutine(ubyte aType, DynosRoutine aRoutine, void *aData) {
+    Array<DynosRoutineParams> &_Routines = DynOS_GetRoutines(aType);
+    for (auto &_Routine : _Routines) {
+        if (_Routine.mRoutine == aRoutine) {
+            _Routine.mData = aData;
+            return;
+        }
+    }
+    _Routines.Add({ aRoutine, aData });
+}
+
+//
+// Warp
+//
+
+static void DynOS_PerformWarp() {
+    if (sDynosWarpLevelNum == -1 || sDynosWarpActNum == -1) {
+        return;
+    }
+
+    // Close the pause menu if it was open
+    optmenu_toggle();
+    level_set_transition(0, NULL);
+    gDialogBoxState = 0;
+    gMenuMode = -1;
+
+    // Cancel out every music/sound/sequence
+    set_sound_disabled(FALSE);
+    sequence_player_unlower(SEQ_PLAYER_LEVEL, 0);
+    for (ushort seqid = 0; seqid != SEQ_COUNT; ++seqid) {
+    stop_background_music(seqid);
+    }
+    play_shell_music();
+    stop_shell_music();
+    stop_cap_music();
+    func_80321080(0);
+
+    // Free everything from the current level
+    clear_objects();
+    clear_area_graph_nodes();
+    clear_areas();
+    main_pool_pop_state();
+
+    // Reset Mario's state
+    gMarioState->healCounter = 0;
+    gMarioState->hurtCounter = 0;
+    gMarioState->numCoins = 0;
+    gMarioState->input = 0;
+    gMarioState->controller->buttonPressed = 0;
+    gHudDisplay.coins = 0;
+
+    // Set up new level values
+    gCurrLevelNum = sDynosWarpLevelNum;
+    gCurrCourseNum = DynOS_Level_GetCourse(gCurrLevelNum);
+    gSavedCourseNum = gCurrCourseNum;
+    gCurrActNum = (gCurrCourseNum <= COURSE_STAGES_MAX ? sDynosWarpActNum : 0);
+    gDialogCourseActNum = gCurrActNum;
+    gCurrAreaIndex = 1;
+
+    // Load the new level and restart the background music
+    level_script_execute((struct LevelCommand *) DynOS_Level_GetScript(gCurrLevelNum));
+    play_music(SEQ_PLAYER_LEVEL, gAreas[1].musicParam2, 0);
+    if (gCurrLevelNum == LEVEL_BOWSER_1) { // Bowser 1 sound fix
+        sound_banks_enable(0, 0xFFFF);
+    }
+
+    // Perform the actual warp
+    if (sDynosWarpToCastle) {
+        DynOS_ExitLevel(1);
+        sDynosWarpToCastle = false;
+    } else {
+        sWarpDest.type = 2;
+        sWarpDest.levelNum = gCurrLevelNum;
+        sWarpDest.areaIdx = 1;
+        sWarpDest.nodeId = 0x0A;
+        sWarpDest.arg = 0;
+    }
+
+    // Reset warp values
+    sDynosWarpLevelNum = -1;
+    sDynosWarpActNum   = -1;
+}
+
+//
+// Exit
+//
+
+bool DynOS_IsLevelExit() {
+    if (sDynosLevelExit && (
+        gMarioState->action == ACT_FALLING_DEATH_EXIT ||
+        gMarioState->action == ACT_SPECIAL_DEATH_EXIT ||
+        gMarioState->action == ACT_DEATH_EXIT)) {
+
+        // Set action
+        if (sDynosLevelExitAction == 0) {
+            sDynosLevelExitAction = gMarioState->action;
+        }
+
+        // Set constants
+        ushort _ExitTimer;
+        uint _ExitAnim;
+        float _ExitVel;
+        switch (sDynosLevelExitAction) {
+            case ACT_DEATH_EXIT:
+                _ExitTimer = 15;
+                _ExitAnim = MARIO_ANIM_GENERAL_FALL;
+                _ExitVel = -32.f;
+                break;
+
+            case ACT_FALLING_DEATH_EXIT:
+                _ExitTimer = 0;
+                _ExitAnim = MARIO_ANIM_GENERAL_FALL;
+                _ExitVel = 0.f;
+                break;
+
+            case ACT_SPECIAL_DEATH_EXIT:
+                play_sound_if_no_flag(gMarioState, SOUND_MARIO_YAHOO, MARIO_MARIO_SOUND_PLAYED);
+                _ExitTimer = 12;
+                _ExitAnim = MARIO_ANIM_SINGLE_JUMP;
+                _ExitVel = -24.f;
+                break;
+
+            case ACT_EXIT_LAND_SAVE_DIALOG:
+                _ExitTimer = 0;
+                _ExitAnim = MARIO_ANIM_GENERAL_LAND;
+                _ExitVel = 0.f;
+                break;
+        }
+
+        // Hide Mario before starting
+        if (gMarioState->actionTimer++ < _ExitTimer) {
+            gMarioState->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
+            return true;
+        }
+
+        // Launch Mario in the air until he lands
+        if (sDynosLevelExitAction != ACT_EXIT_LAND_SAVE_DIALOG) {
+            mario_set_forward_vel(gMarioState, _ExitVel);
+            set_mario_animation(gMarioState, _ExitAnim);
+            if (perform_air_step(gMarioState, 0) == AIR_STEP_LANDED) {
+                sDynosLevelExitAction = ACT_EXIT_LAND_SAVE_DIALOG;
+            }
+        }
+
+        // Play the land animation, then return the hand to the player
+        else {
+            stationary_ground_step(gMarioState);
+            play_mario_landing_sound_once(gMarioState, SOUND_ACTION_TERRAIN_LANDING);
+            set_mario_animation(gMarioState, _ExitAnim);
+            if (is_anim_past_end(gMarioState)) {
+                gMarioState->faceAngle[1] += 0x8000;
+                set_mario_action(gMarioState, ACT_IDLE, 0);
+                gCutsceneTimer = CUTSCENE_STOP;
+                gMarioState->area->camera->cutscene = 0;
+                sDynosLevelExitAction = 0;
+                sDynosLevelExit = false;
+            }
+        }
+
+        // Update Mario's graphics
+        gMarioState->marioObj->header.gfx.node.flags |= GRAPH_RENDER_ACTIVE;
+        gMarioState->marioObj->header.gfx.angle[1] += 0x8000;
+        return true;
+    }
+    return false;
+}
+
+//
+// Init
+//
+
+__attribute__((constructor))
+void DynOS_Init() {
+    DynOS_Opt_Init();
+}
+
+//
+// Update
+//
+
+static bool DynOS_IsLevelEntry() {
+    if (!gMarioState) {
+        return false;
+    }
+
+    // Action, Arg, Timer
+    static const int sLevelEntryTable[LEVEL_COUNT - 1][3] = {
+        { -1,                         -1, -1 }, // LEVEL_UNKNOWN_1
+        { -1,                         -1, -1 }, // LEVEL_UNKNOWN_2
+        { -1,                         -1, -1 }, // LEVEL_UNKNOWN_3
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_BBH
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_CCM
+        { -1,                         -1, -1 }, // LEVEL_CASTLE
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_HMC
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_SSL
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_BOB
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_SL
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_WDW
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_JRB
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_THI
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_TTC
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_RR
+        { -1,                         -1, -1 }, // LEVEL_CASTLE_GROUNDS
+        { ACT_SPAWN_NO_SPIN_AIRBORNE, -1, -1 }, // LEVEL_BITDW
+        { ACT_SPAWN_NO_SPIN_AIRBORNE, -1, -1 }, // LEVEL_VCUTM
+        { ACT_SPAWN_NO_SPIN_AIRBORNE, -1, -1 }, // LEVEL_BITFS
+        { ACT_WATER_IDLE,              1,  0 }, // LEVEL_SA
+        { ACT_SPAWN_NO_SPIN_AIRBORNE, -1, -1 }, // LEVEL_BITS
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_LLL
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_DDD
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_WF
+        { -1,                         -1, -1 }, // LEVEL_ENDING
+        { -1,                         -1, -1 }, // LEVEL_CASTLE_COURTYARD
+        { ACT_SPAWN_NO_SPIN_AIRBORNE, -1, -1 }, // LEVEL_PSS
+        { ACT_SPAWN_NO_SPIN_AIRBORNE, -1, -1 }, // LEVEL_COTMC
+        { ACT_FLYING,                  2,  0 }, // LEVEL_TOTWC
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_BOWSER_1
+        { ACT_SPAWN_NO_SPIN_AIRBORNE, -1, -1 }, // LEVEL_WMOTR
+        { -1,                         -1, -1 }, // LEVEL_UNKNOWN_32
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_BOWSER_2
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_BOWSER_3
+        { -1,                         -1, -1 }, // LEVEL_UNKNOWN_35
+        { ACT_SPAWN_SPIN_AIRBORNE,    -1, -1 }, // LEVEL_TTM
+        { -1,                         -1, -1 }, // LEVEL_UNKNOWN_37
+        { -1,                         -1, -1 }, // LEVEL_UNKNOWN_38
+    };
+
+    int _Action = sLevelEntryTable[gCurrLevelNum - 1][0];
+    int _ActionArg = sLevelEntryTable[gCurrLevelNum - 1][1];
+    int _ActionTimer = sLevelEntryTable[gCurrLevelNum - 1][2];
+    bool _LevelEntry =
+        (_Action      != -1 && gMarioState->action        == (uint) _Action) &&
+        (_ActionArg   == -1 || gMarioState->actionArg     == (uint) _ActionArg) &&
+        (_ActionTimer == -1 || gMarioState->actionTimer++ == (uint) _ActionTimer);
+
+    static bool sWasLevelEntry = false;
+    bool _Result = (_LevelEntry && !sWasLevelEntry);
+    sWasLevelEntry = _LevelEntry;
+    return _Result;
+}
+
+void DynOS_UpdateOpt(void *aPad) {
+    DynOS_PerformWarp();
+    DynOS_Opt_Update((OSContPad *) aPad);
+    DynOS_ExecuteRoutines(DYNOS_ROUTINE_OPT_UPDATE);
+    if (DynOS_IsLevelEntry()) {
+        DynOS_ExecuteRoutines(DYNOS_ROUTINE_LEVEL_START);
+    }
+}
+
+void DynOS_UpdateGfx() {
+    DynOS_Gfx_Update();
+    DynOS_ExecuteRoutines(DYNOS_ROUTINE_GFX_UPDATE);
+}
diff --git a/data/dynos_misc.cpp b/data/dynos_misc.cpp
new file mode 100644
index 0000000..1b416d0
--- /dev/null
+++ b/data/dynos_misc.cpp
@@ -0,0 +1,730 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "course_table.h"
+#include "object_fields.h"
+#include "game/object_helpers.h"
+#include "game/segment2.h"
+#include "game/level_geo.h"
+#include "game/moving_texture.h"
+#include "game/paintings.h"
+#include "game/geo_misc.h"
+#include "game/mario_misc.h"
+#include "game/mario_actions_cutscene.h"
+#include "game/screen_transition.h"
+#include "game/object_list_processor.h"
+#include "game/behavior_actions.h"
+#include "game/rendering_graph_node.h"
+#include "actors/common0.h"
+#include "actors/common1.h"
+#include "actors/group0.h"
+#include "actors/group1.h"
+#include "actors/group2.h"
+#include "actors/group3.h"
+#include "actors/group4.h"
+#include "actors/group5.h"
+#include "actors/group6.h"
+#include "actors/group7.h"
+#include "actors/group8.h"
+#include "actors/group9.h"
+#include "actors/group10.h"
+#include "actors/group11.h"
+#include "actors/group12.h"
+#include "actors/group13.h"
+#include "actors/group14.h"
+#include "actors/group15.h"
+#include "actors/group16.h"
+#include "actors/group17.h"
+}
+
+//
+// String
+//
+
+static const struct { const char *mStr; ubyte mChar64; int mWidth; } sSm64CharMap[] = {
+    { "0",   0x00, 7 }, { "1",  0x01,  7 }, { "2",   0x02, 7 }, { "3",   0x03, 7 }, { "4",   0x04,  7 }, { "5",   0x05,  7 },
+    { "6",   0x06, 7 }, { "7",  0x07,  7 }, { "8",   0x08, 7 }, { "9",   0x09, 7 }, { "A",   0x0A,  6 }, { "B",   0x0B,  6 },
+    { "C",   0x0C, 6 }, { "D",  0x0D,  6 }, { "E",   0x0E, 6 }, { "F",   0x0F, 6 }, { "G",   0x10,  6 }, { "H",   0x11,  6 },
+    { "I",   0x12, 5 }, { "J",  0x13,  6 }, { "K",   0x14, 6 }, { "L",   0x15, 5 }, { "M",   0x16,  8 }, { "N",   0x17,  8 },
+    { "O",   0x18, 6 }, { "P",  0x19,  6 }, { "Q",   0x1A, 6 }, { "R",   0x1B, 6 }, { "S",   0x1C,  6 }, { "T",   0x1D,  5 },
+    { "U",   0x1E, 6 }, { "V",  0x1F,  6 }, { "W",   0x20, 8 }, { "X",   0x21, 7 }, { "Y",   0x22,  6 }, { "Z",   0x23,  6 },
+    { "a",   0x24, 6 }, { "b",  0x25,  5 }, { "c",   0x26, 5 }, { "d",   0x27, 6 }, { "e",   0x28,  5 }, { "f",   0x29,  5 },
+    { "g",   0x2A, 6 }, { "h",  0x2B,  5 }, { "i",   0x2C, 4 }, { "j",   0x2D, 5 }, { "k",   0x2E,  5 }, { "l",   0x2F,  3 },
+    { "m",   0x30, 7 }, { "n",  0x31,  5 }, { "o",   0x32, 5 }, { "p",   0x33, 5 }, { "q",   0x34,  6 }, { "r",   0x35,  5 },
+    { "s",   0x36, 5 }, { "t",  0x37,  5 }, { "u",   0x38, 5 }, { "v",   0x39, 5 }, { "w",   0x3A,  7 }, { "x",   0x3B,  7 },
+    { "y",   0x3C, 5 }, { "z",  0x3D,  5 }, { "\'",  0x3E, 4 }, { ".",   0x3F, 4 }, { "^",   0x50,  8 }, { "|",   0x51,  8 },
+    { "<",   0x52, 8 }, { ">",  0x53,  8 }, { "[A]", 0x54, 7 }, { "[B]", 0x55, 7 }, { "[C]", 0x56,  6 }, { "[Z]", 0x57,  7 },
+    { "[R]", 0x58, 7 }, { ",",  0x6F,  4 }, { " ",   0x9E, 5 }, { "-",   0x9F, 6 }, { "/",   0xD0, 10 }, { "[%]", 0xE0,  7 },
+    { "(",   0xE1, 5 }, { ")(", 0xE2, 10 }, { ")",   0xE3, 5 }, { "+",   0xE4, 9 }, { "&",   0xE5,  8 }, { ":",   0xE6,  4 },
+    { "!",   0xF2, 5 }, { "%",  0xF3,  7 }, { "?",   0xF4, 7 }, { "~",   0xF7, 8 }, { "$",   0xF9,  8 }, { "@",   0xFA, 10 },
+    { "*",   0xFB, 6 }, { "",  0xFD, 10 }, { "\n",  0xFE, 0 },
+};
+
+static const char *DynOS_String_AddChar64(ubyte *aStr64, const char *pStr, int &aIndex) {
+    for (const auto &c : sSm64CharMap) {
+        if (strstr(pStr, c.mStr) == pStr) {
+            aStr64[aIndex++] = c.mChar64;
+            return pStr + strlen(c.mStr);
+        }
+    }
+
+    // Put a space by default
+    aStr64[aIndex++] = 0x9E;
+    return pStr + 1;
+}
+
+ubyte *DynOS_String_Convert(const char *aString, bool aHeapAlloc) {
+
+    // Allocation
+    static ubyte sStringBuffer[8][2048];
+    static uint sStringBufferIndex = 0;
+    ubyte *_Str64;
+    if (aHeapAlloc) {
+        _Str64 = New<ubyte>(2048);
+    } else {
+        _Str64 = sStringBuffer[sStringBufferIndex];
+        sStringBufferIndex = (sStringBufferIndex + 1) % 8;
+    }
+
+    // Conversion
+    memset(_Str64, 0xFF, 2048);
+    const char *pStr = aString;
+    for (int i = 0; *pStr != 0 && i < 2047;) {
+        pStr = DynOS_String_AddChar64(_Str64, pStr, i);
+    }
+    return _Str64;
+}
+
+ubyte *DynOS_String_Decapitalize(ubyte *aStr64) {
+    bool _WasSpace = true;
+    for (ubyte *pStr64 = aStr64; *pStr64 != 0xFF; pStr64++) {
+        if (*pStr64 >= 10 && *pStr64 <= 35) {
+            if (_WasSpace) _WasSpace = false;
+            else *pStr64 += 26;
+        } else if (*pStr64 >= 63) {
+            _WasSpace = true;
+        }
+    }
+    return aStr64;
+}
+
+int DynOS_String_Length(const ubyte *aStr64) {
+    int _Length = 0;
+    for (; aStr64 && *aStr64 != 255; aStr64++, _Length++);
+    return _Length;
+}
+
+int DynOS_String_WidthChar64(ubyte aChar64) {
+    for (const auto &c : sSm64CharMap) {
+        if (c.mChar64 == aChar64) {
+            return c.mWidth;
+        }
+    }
+    return 0;
+}
+
+int DynOS_String_Width(const ubyte *aStr64) {
+    int _Width = 0;
+    for (; *aStr64 != 0xFF; aStr64++) {
+        _Width += DynOS_String_WidthChar64(*aStr64);
+    }
+    return _Width;
+}
+
+//
+// Geo
+//
+
+static void *geo_rotate_3d_coin(int callContext, void *node, UNUSED void *c) {
+    if (callContext == GEO_CONTEXT_RENDER) {
+        struct Object *obj = (struct Object *) gCurGraphNodeObject;
+        struct GraphNodeRotation *rotNode = (struct GraphNodeRotation *) ((struct GraphNode *) node)->next;
+        rotNode->rotation[0] = 0;
+        rotNode->rotation[1] = obj->oAnimState;
+        rotNode->rotation[2] = 0;
+        obj->oAnimState += 0x0800;
+    }
+    return NULL;
+}
+
+//
+// Actors
+//
+
+static const Array<Pair<const char *, void *>> &__Actors() {
+#define define_actor(geo) { #geo, (void *) geo }
+static const Array<Pair<const char *, void *>> sActors = {
+    define_actor(amp_geo),
+
+    define_actor(birds_geo),
+    define_actor(blargg_geo),
+    define_actor(blue_coin_switch_geo),
+    define_actor(black_bobomb_geo),
+    define_actor(bobomb_buddy_geo),
+    define_actor(boo_geo),
+    define_actor(boo_castle_geo),
+    define_actor(bookend_geo),
+    define_actor(bookend_part_geo),
+    define_actor(bowling_ball_geo),
+    define_actor(bowling_ball_track_geo),
+    define_actor(bowser_geo),
+    define_actor(bowser2_geo),
+    define_actor(bowser_bomb_geo),
+    define_actor(bowser_flames_geo),
+    define_actor(bowser_impact_smoke_geo),
+    define_actor(bowser_1_yellow_sphere_geo),
+    define_actor(invisible_bowser_accessory_geo),
+    define_actor(bowser_key_geo),
+    define_actor(bowser_key_cutscene_geo),
+    define_actor(breakable_box_geo),
+    define_actor(breakable_box_small_geo),
+    define_actor(bub_geo),
+    define_actor(bubba_geo),
+    define_actor(bubble_geo),
+    define_actor(bullet_bill_geo),
+    define_actor(bully_geo),
+    define_actor(bully_boss_geo),
+    define_actor(burn_smoke_geo),
+    define_actor(butterfly_geo),
+
+    define_actor(cannon_barrel_geo),
+    define_actor(cannon_base_geo),
+    define_actor(cap_switch_geo),
+    define_actor(cartoon_star_geo),
+    define_actor(chain_chomp_geo),
+    define_actor(checkerboard_platform_geo),
+    define_actor(chilly_chief_geo),
+    define_actor(chilly_chief_big_geo),
+    define_actor(chuckya_geo),
+    define_actor(clam_shell_geo),
+    define_actor(yellow_coin_geo),
+    define_actor(yellow_coin_no_shadow_geo),
+    define_actor(blue_coin_geo),
+    define_actor(blue_coin_no_shadow_geo),
+    define_actor(red_coin_geo),
+    define_actor(red_coin_no_shadow_geo),
+
+    define_actor(dirt_animation_geo),
+    define_actor(dorrie_geo),
+    define_actor(cabin_door_geo),
+    define_actor(castle_door_geo),
+    define_actor(castle_door_0_star_geo),
+    define_actor(castle_door_1_star_geo),
+    define_actor(castle_door_3_stars_geo),
+    define_actor(haunted_door_geo),
+    define_actor(hazy_maze_door_geo),
+    define_actor(metal_door_geo),
+    define_actor(key_door_geo),
+    define_actor(wooden_door_geo),
+
+    define_actor(enemy_lakitu_geo),
+    define_actor(exclamation_box_geo),
+    define_actor(exclamation_box_outline_geo),
+    define_actor(explosion_geo),
+    define_actor(eyerok_left_hand_geo),
+    define_actor(eyerok_right_hand_geo),
+
+    define_actor(fish_geo),
+    define_actor(cyan_fish_geo),
+    define_actor(flyguy_geo),
+    define_actor(red_flame_geo),
+    define_actor(red_flame_shadow_geo),
+    define_actor(blue_flame_geo),
+    define_actor(fwoosh_geo),
+
+    define_actor(goomba_geo),
+
+    define_actor(haunted_cage_geo),
+    define_actor(haunted_chair_geo),
+    define_actor(heart_geo),
+    define_actor(heave_ho_geo),
+    define_actor(hoot_geo),
+
+    define_actor(king_bobomb_geo),
+    define_actor(klepto_geo),
+    define_actor(koopa_with_shell_geo),
+    define_actor(koopa_without_shell_geo),
+    define_actor(koopa_flag_geo),
+    define_actor(koopa_shell_geo),
+
+    define_actor(lakitu_geo),
+#ifdef RENDER_96
+    define_actor(luigi_geo),
+    define_actor(luigis_cap_geo),
+    define_actor(luigis_metal_cap_geo),
+    define_actor(luigis_wing_cap_geo),
+    define_actor(luigis_winged_metal_cap_geo),
+#endif
+
+    define_actor(mad_piano_geo),
+    define_actor(manta_seg5_geo_05008D14),
+    define_actor(mario_geo),
+    define_actor(marios_cap_geo),
+    define_actor(marios_metal_cap_geo),
+    define_actor(marios_wing_cap_geo),
+    define_actor(marios_winged_metal_cap_geo),
+    define_actor(metal_box_geo),
+    define_actor(metallic_ball_geo),
+    define_actor(mips_geo),
+    define_actor(mist_geo),
+    define_actor(moneybag_geo),
+    define_actor(monty_mole_geo),
+    define_actor(mr_blizzard_geo),
+    define_actor(mr_i_geo),
+    define_actor(mr_i_iris_geo),
+    define_actor(mushroom_1up_geo),
+
+    define_actor(number_geo),
+
+    define_actor(peach_geo),
+    define_actor(penguin_geo),
+    define_actor(piranha_plant_geo),
+    define_actor(pokey_head_geo),
+    define_actor(pokey_body_part_geo),
+    define_actor(purple_marble_geo),
+    define_actor(purple_switch_geo),
+
+    define_actor(scuttlebug_geo),
+    define_actor(seaweed_geo),
+    define_actor(skeeter_geo),
+    define_actor(small_key_geo),
+    define_actor(small_water_splash_geo),
+    define_actor(smoke_geo),
+    define_actor(snufit_geo),
+    define_actor(sparkles_geo),
+    define_actor(sparkles_animation_geo),
+    define_actor(spindrift_geo),
+    define_actor(spiny_geo),
+    define_actor(spiny_ball_geo),
+    define_actor(star_geo),
+    define_actor(transparent_star_geo),
+    define_actor(sushi_geo),
+    define_actor(swoop_geo),
+
+    define_actor(thwomp_geo),
+    define_actor(toad_geo),
+    define_actor(treasure_chest_base_geo),
+    define_actor(treasure_chest_lid_geo),
+    define_actor(bubbly_tree_geo),
+    define_actor(spiky_tree_geo),
+    define_actor(snow_tree_geo),
+    define_actor(palm_tree_geo),
+    define_actor(leaves_geo),
+    define_actor(tweester_geo),
+
+    define_actor(ukiki_geo),
+    define_actor(unagi_geo),
+
+    define_actor(warp_pipe_geo),
+    define_actor(water_bomb_geo),
+    define_actor(water_bomb_shadow_geo),
+    define_actor(water_ring_geo),
+    define_actor(water_splash_geo),
+    define_actor(idle_water_wave_geo),
+    define_actor(wave_trail_geo),
+    define_actor(white_particle_geo),
+    define_actor(white_puff_geo),
+    define_actor(whomp_geo),
+    define_actor(wiggler_head_geo),
+    define_actor(wiggler_body_geo),
+    define_actor(wooden_post_geo),
+    define_actor(wooden_signpost_geo),
+
+    define_actor(yellow_sphere_geo),
+    define_actor(yoshi_geo),
+    define_actor(yoshi_egg_geo),
+};
+#undef define_actor
+return sActors;
+}
+
+int DynOS_Geo_GetActorCount() {
+    return __Actors().Count();
+}
+
+const char *DynOS_Geo_GetActorName(int aIndex) {
+    return __Actors()[aIndex].first;
+}
+
+void *DynOS_Geo_GetActorLayout(int aIndex) {
+    return __Actors()[aIndex].second;
+}
+
+int DynOS_Geo_GetActorIndex(const void *aGeoLayout) {
+    for (const auto &_Actor : __Actors()) {
+        if (_Actor.second == aGeoLayout) {
+            return (int) (&_Actor - __Actors().begin());
+        }
+    }
+    return -1;
+}
+
+//
+// Geo Functions
+//
+
+static const Array<Pair<const char *, void *>> &__GeoFunctions() {
+#define define_geo_function(name) { #name, (void *) name }
+static const Array<Pair<const char *, void *>> sGeoFunctions = {
+    define_geo_function(geo_mirror_mario_set_alpha),
+    define_geo_function(geo_switch_mario_stand_run),
+    define_geo_function(geo_switch_mario_eyes),
+    define_geo_function(geo_mario_tilt_torso),
+    define_geo_function(geo_mario_head_rotation),
+    define_geo_function(geo_switch_mario_hand),
+    define_geo_function(geo_mario_hand_foot_scaler),
+    define_geo_function(geo_switch_mario_cap_effect),
+    define_geo_function(geo_switch_mario_cap_on_off),
+    define_geo_function(geo_mario_rotate_wing_cap_wings),
+    define_geo_function(geo_switch_mario_hand_grab_pos),
+    define_geo_function(geo_render_mirror_mario),
+    define_geo_function(geo_mirror_mario_backface_culling),
+    define_geo_function(geo_update_projectile_pos_from_parent),
+    define_geo_function(geo_update_layer_transparency),
+    define_geo_function(geo_switch_anim_state),
+    define_geo_function(geo_switch_area),
+    define_geo_function(geo_camera_main),
+    define_geo_function(geo_camera_fov),
+    define_geo_function(geo_envfx_main),
+    define_geo_function(geo_skybox_main),
+    define_geo_function(geo_wdw_set_initial_water_level),
+    define_geo_function(geo_movtex_pause_control),
+    define_geo_function(geo_movtex_draw_water_regions),
+    define_geo_function(geo_movtex_draw_nocolor),
+    define_geo_function(geo_movtex_draw_colored),
+    define_geo_function(geo_movtex_draw_colored_no_update),
+    define_geo_function(geo_movtex_draw_colored_2_no_update),
+    define_geo_function(geo_movtex_update_horizontal),
+    define_geo_function(geo_movtex_draw_colored_no_update),
+    define_geo_function(geo_painting_draw),
+    define_geo_function(geo_painting_update),
+    define_geo_function(geo_exec_inside_castle_light),
+    define_geo_function(geo_exec_flying_carpet_timer_update),
+    define_geo_function(geo_exec_flying_carpet_create),
+    define_geo_function(geo_exec_cake_end_screen),
+    define_geo_function(geo_cannon_circle_base),
+    define_geo_function(geo_move_mario_part_from_parent),
+    define_geo_function(geo_bits_bowser_coloring),
+    define_geo_function(geo_update_body_rot_from_parent),
+    define_geo_function(geo_switch_bowser_eyes),
+    define_geo_function(geo_switch_tuxie_mother_eyes),
+    define_geo_function(geo_update_held_mario_pos),
+    define_geo_function(geo_snufit_move_mask),
+    define_geo_function(geo_snufit_scale_body),
+    define_geo_function(geo_scale_bowser_key),
+    { "geo_rotate_coin", (void *) geo_rotate_3d_coin },
+    define_geo_function(geo_offset_klepto_held_object),
+    define_geo_function(geo_switch_peach_eyes),
+};
+#undef define_geo_function
+return sGeoFunctions;
+}
+
+void *DynOS_Geo_GetFunctionPointerFromName(const String &aName) {
+    for (const auto &_GeoFunction : __GeoFunctions()) {
+        if (aName == _GeoFunction.first) {
+            return _GeoFunction.second;
+        }
+    };
+    return NULL;
+}
+
+void *DynOS_Geo_GetFunctionPointerFromIndex(int aIndex) {
+    return __GeoFunctions()[aIndex].second;
+}
+
+int DynOS_Geo_GetFunctionIndex(const void *aPtr) {
+    for (const auto &_GeoFunction : __GeoFunctions()) {
+        if (_GeoFunction.second == aPtr) {
+            return (int) (&_GeoFunction - __GeoFunctions().begin());
+        }
+    }
+    return -1;
+}
+
+static void _RelocateGraphNodePointers(struct GraphNode *aHead, size_t aOffset) {
+    struct GraphNode *_Node = aHead;
+    do {
+        if (_Node->prev) {
+            _Node->prev = (struct GraphNode *) ((size_t) _Node->prev + aOffset);
+        }
+        if (_Node->next) {
+            _Node->next = (struct GraphNode *) ((size_t) _Node->next + aOffset);
+        }
+        if (_Node->parent) {
+            _Node->parent = (struct GraphNode *) ((size_t) _Node->parent + aOffset);
+        }
+        if (_Node->children) {
+            _Node->children = (struct GraphNode *) ((size_t) _Node->children + aOffset);
+            _RelocateGraphNodePointers(_Node->children, aOffset);
+        }
+        _Node = _Node->next;
+    } while (_Node != aHead);
+}
+
+void *DynOS_Geo_GetGraphNode(const void *aGeoLayout, bool aKeepInMemory) {
+    static Array<Pair<void *, void *>> sLoadedGraphNodes;
+    if (aKeepInMemory) {
+        int _LoadedGraphNodeIndex = sLoadedGraphNodes.FindIf([&aGeoLayout](const Pair<void *, void *> &aLoadedGraphNode) { return aLoadedGraphNode.first == aGeoLayout; });
+        if (_LoadedGraphNodeIndex != -1) {
+            return sLoadedGraphNodes[_LoadedGraphNodeIndex].second;
+        }
+    }
+
+    // Process the geo layout on a large _Pool of memory (16 MB)
+    struct AllocOnlyPool *_Pool = (struct AllocOnlyPool *) calloc(1, 0x1000000);
+    _Pool->totalSpace = 0x1000000       - sizeof(struct AllocOnlyPool);
+    _Pool->usedSpace  = 0;
+    _Pool->startPtr   = (ubyte *) _Pool + sizeof(struct AllocOnlyPool);
+    _Pool->freePtr    = (ubyte *) _Pool + sizeof(struct AllocOnlyPool);
+    void *_Processed  = process_geo_layout(_Pool, (void *) aGeoLayout);
+
+    // Copy the graph node data to the minimum amount of memory needed
+    if (_Processed && _Pool->usedSpace != 0) {
+        struct GraphNode *_Node = (struct GraphNode *) calloc(1, _Pool->usedSpace);
+        memcpy(_Node, _Pool->startPtr, _Pool->usedSpace);
+
+        // Relocate all graph pointers
+        size_t _Offset = (size_t) _Node - (size_t) _Pool->startPtr;
+        _RelocateGraphNodePointers(_Node, _Offset);
+
+        // Add it to loaded graph nodes
+        if (aKeepInMemory) {
+            sLoadedGraphNodes.Add({ (void *) aGeoLayout, (void *) _Node });
+        }
+        free(_Pool);
+        return _Node;
+    }
+    free(_Pool);
+    return NULL;
+}
+
+void *DynOS_Geo_SpawnObject(const void *aGeoLayout, void *aParent, const void *aBehavior) {
+    struct Object *_Object = spawn_object((struct Object *) aParent, 0, (const BehaviorScript *) aBehavior);
+    _Object->header.gfx.sharedChild = (struct GraphNode *) DynOS_Geo_GetGraphNode(aGeoLayout, true);
+    return _Object;
+}
+
+//
+// Level
+//
+
+struct LevelCourseScript {
+    int mLevel;
+    int mCourse;
+    void *mScript;
+};
+
+#define STUB_LEVEL(_0, _1, _2, _3, _4, _5, _6, _7, _8)
+#define DEFINE_LEVEL(_0, _1, _2, _name, _4, _5, _6, _7, _8, _9, _10) extern const LevelScript level_##_name##_entry[];
+#include "levels/level_defines.h"
+#undef DEFINE_LEVEL
+#undef STUB_LEVEL
+#define STUB_LEVEL(_0, _1, _2, _3, _4, _5, _6, _7, _8)
+#define DEFINE_LEVEL(_0, _level, _course, _name, _4, _5, _6, _7, _8, _9, _10) { (int) _level, (int) _course, (void *) level_##_name##_entry },
+static const struct LevelCourseScript sLevelCourseScript[] = {
+#include "levels/level_defines.h"
+};
+#undef DEFINE_LEVEL
+#undef STUB_LEVEL
+
+static const ubyte sEmpty[]        = { 255 };
+static const ubyte sCastle[]       = { 12, 10, 28, 29, 21, 14, 255 };
+static const ubyte sBowser1[]      = { 11, 24, 32, 28, 14, 27, 158, 1, 255 };
+static const ubyte sBowser2[]      = { 11, 24, 32, 28, 14, 27, 158, 2, 255 };
+static const ubyte sBowser3[]      = { 11, 24, 32, 28, 14, 27, 158, 3, 255 };
+static const ubyte s100CoinsStar[] = { 1, 0, 0, 158, 12, 24, 18, 23, 28, 158, 28, 29, 10, 27, 255 };
+
+static int _GetCourse(int aLevel) {
+    for (const auto &lcs : sLevelCourseScript) {
+        if (lcs.mLevel == aLevel) {
+            return lcs.mCourse;
+        }
+    }
+    return COURSE_NONE;
+}
+
+static void *_GetScript(int aLevel) {
+    for (const auto &lcs : sLevelCourseScript) {
+        if (lcs.mLevel == aLevel) {
+            return lcs.mScript;
+        }
+    }
+    return NULL;
+}
+
+static void _SetLevelName(ubyte *aBuffer, int aLevel) {
+    if (aLevel == LEVEL_BOWSER_1)   { memcpy(aBuffer, sBowser1, DynOS_String_Length(sBowser1)); return; }
+    if (aLevel == LEVEL_BOWSER_2)   { memcpy(aBuffer, sBowser2, DynOS_String_Length(sBowser2)); return; }
+    if (aLevel == LEVEL_BOWSER_3)   { memcpy(aBuffer, sBowser3, DynOS_String_Length(sBowser3)); return; }
+
+    int _Course = _GetCourse(aLevel);
+    if (_Course < COURSE_BOB)       { memcpy(aBuffer, sCastle,  DynOS_String_Length(sCastle));  return; }
+    if (_Course >= COURSE_CAKE_END) { memcpy(aBuffer, sCastle,  DynOS_String_Length(sCastle));  return; }
+
+    const ubyte *courseName = ((const ubyte **) seg2_course_name_table)[_Course - COURSE_BOB] + 3;
+    memcpy(aBuffer, courseName, DynOS_String_Length(courseName));
+}
+
+static void _SetActName(ubyte *aBuffer, int aLevel, int aAct) {
+    int _Course = _GetCourse(aLevel);
+    if (_Course > COURSE_STAGES_MAX) { memcpy(aBuffer, sEmpty,        DynOS_String_Length(sEmpty));        return; }
+    if (aAct >= 7)                   { memcpy(aBuffer, s100CoinsStar, DynOS_String_Length(s100CoinsStar)); return; }
+
+    const ubyte *actName = ((const ubyte **) seg2_act_name_table)[(_Course - COURSE_BOB) * 6 + (aAct - 1)];
+    memcpy(aBuffer, actName, DynOS_String_Length(actName));
+}
+
+static void _PrefixNumber(ubyte *aBuffer, int aNumber) {
+    memmove(aBuffer + 5, aBuffer, DynOS_String_Length(aBuffer));
+    aBuffer[0] = ((aNumber / 10) == 0 ? 158 : (aNumber / 10));
+    aBuffer[1] = (aNumber % 10);
+    aBuffer[2] = 158;
+    aBuffer[3] = 159;
+    aBuffer[4] = 158;
+}
+
+//
+// Data
+//
+
+static int sLevelCount[2]    = { 0, 0 };
+static int *sLevelList[2][2] = { { NULL, NULL }, { NULL, NULL } };
+static int *sLevelCourses    = NULL;
+static void **sLevelScripts  = NULL;
+
+// Runs only once
+static void DynOS_Level_Init() {
+    static bool sInited = false;
+    if (!sInited) {
+
+        // Level count
+        sLevelCount[0] = sizeof(sLevelCourseScript) / sizeof(sLevelCourseScript[0]);
+
+        // Level count (no Castle)
+        sLevelCount[1] = 0;
+        for (const auto& lcs : sLevelCourseScript) {
+            if (lcs.mCourse >= COURSE_BOB && lcs.mCourse < COURSE_CAKE_END) {
+                sLevelCount[1]++;
+            }
+        }
+
+        // Lists allocation
+        sLevelList[0][0] = New<int>(sLevelCount[0]);
+        sLevelList[0][1] = New<int>(sLevelCount[0]);
+        sLevelList[1][0] = New<int>(sLevelCount[1]);
+        sLevelList[1][1] = New<int>(sLevelCount[1]);
+        sLevelCourses    = New<int>(LEVEL_COUNT);
+        sLevelScripts    = New<void *>(LEVEL_COUNT);
+
+        // Level list
+        for (int i = 0; i != sLevelCount[0]; ++i) {
+            sLevelList[0][0][i] = sLevelCourseScript[i].mLevel;
+        }
+
+        // Level list ordered by course id
+        for (int i = 0, k = 0; i < COURSE_END; ++i) {
+            for (int j = 0; j < sLevelCount[0]; ++j) {
+                if (sLevelCourseScript[j].mCourse == i) {
+                    sLevelList[0][1][k++] = sLevelCourseScript[j].mLevel;
+                }
+            }
+        }
+
+        // Level list (no Castle)
+        for (int i = 0, k = 0; i != sLevelCount[0]; ++i) {
+            if (sLevelCourseScript[i].mCourse >= COURSE_BOB && sLevelCourseScript[i].mCourse < COURSE_CAKE_END) {
+                sLevelList[1][0][k++] = sLevelCourseScript[i].mLevel;
+            }
+        }
+
+        // Level list ordered by course id (no Castle)
+        for (int i = COURSE_BOB, k = 0; i < COURSE_CAKE_END; ++i) {
+            for (int j = 0; j < sLevelCount[0]; ++j) {
+                if (sLevelCourseScript[j].mCourse == i) {
+                    sLevelList[1][1][k++] = sLevelCourseScript[j].mLevel;
+                }
+            }
+        }
+
+        // Level courses
+        for (int i = 0; i != LEVEL_COUNT; ++i) {
+            sLevelCourses[i] = _GetCourse(i);
+        }
+
+        // Level scripts
+        for (int i = 0; i != LEVEL_COUNT; ++i) {
+            sLevelScripts[i] = _GetScript(i);
+        }
+
+        // Done
+        sInited = true;
+    }
+}
+
+int DynOS_Level_GetCount(bool aNoCastle) {
+    DynOS_Level_Init();
+    return sLevelCount[aNoCastle];
+}
+
+int *DynOS_Level_GetList(bool aNoCastle, bool aOrdered) {
+    DynOS_Level_Init();
+    return sLevelList[aNoCastle][aOrdered];
+}
+
+int DynOS_Level_GetCourse(int aLevel) {
+    DynOS_Level_Init();
+    return sLevelCourses[aLevel];
+}
+
+void *DynOS_Level_GetScript(int aLevel) {
+    DynOS_Level_Init();
+    return sLevelScripts[aLevel];
+}
+
+ubyte *DynOS_Level_GetName(int aLevel, bool aDecaps, bool aAddCourseNumber) {
+    DynOS_Level_Init();
+    static ubyte sBuffer[256];
+    memset(sBuffer, 0xFF, 256);
+
+    // Level name
+    _SetLevelName(sBuffer, aLevel);
+
+    // Decaps
+    if (aDecaps) {
+        DynOS_String_Decapitalize(sBuffer);
+    }
+
+    // Course number
+    if (aAddCourseNumber) {
+        int _Course = _GetCourse(aLevel);
+        if (_Course >= COURSE_BOB && _Course <= COURSE_STAGES_MAX) {
+            _PrefixNumber(sBuffer, _Course);
+        }
+    }
+
+    return sBuffer;
+}
+
+ubyte *DynOS_Level_GetActName(int aLevel, int aAct, bool aDecaps, bool aAddStarNumber) {
+    DynOS_Level_Init();
+    static ubyte sBuffer[256];
+    memset(sBuffer, 0xFF, 256);
+
+    // Star name
+    _SetActName(sBuffer, aLevel, aAct);
+
+    // Decaps
+    if (aDecaps) {
+        DynOS_String_Decapitalize(sBuffer);
+    }
+
+    // Star number
+    if (aAddStarNumber) {
+        int _Course = _GetCourse(aLevel);
+        if (_Course >= COURSE_BOB && _Course <= COURSE_STAGES_MAX) {
+            _PrefixNumber(sBuffer, aAct);
+        }
+    }
+
+    return sBuffer;
+}
diff --git a/data/dynos_opt.cpp b/data/dynos_opt.cpp
new file mode 100644
index 0000000..6d2dc7c
--- /dev/null
+++ b/data/dynos_opt.cpp
@@ -0,0 +1,736 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "audio_defines.h"
+#include "audio/external.h"
+#include "game/game_init.h"
+#include "pc/controller/controller_keyboard.h"
+}
+
+//
+// Data
+//
+
+static DynosOption *sPrevOpt     = NULL;
+static DynosOption *sDynosMenu   = NULL;
+static DynosOption *sOptionsMenu = NULL;
+static DynosOption *sCurrentMenu = NULL;
+static DynosOption *sCurrentOpt  = NULL;
+extern int sBindingState;
+
+//
+// Action list
+//
+
+typedef bool (*DynosActionFunction)(const char *);
+struct DynosAction : NoCopy {
+    String mFuncName;
+    DynosActionFunction mAction;
+};
+
+static Array<DynosAction *> &DynOS_Opt_GetActionList() {
+    static Array<DynosAction *> sDynosActions;
+    return sDynosActions;
+}
+
+static DynosActionFunction DynOS_Opt_GetAction(const String& aFuncName) {
+    Array<DynosAction *> &pDynosActions = DynOS_Opt_GetActionList();
+    for (auto &_DynosAction : pDynosActions) {
+        if (_DynosAction->mFuncName == aFuncName) {
+            return _DynosAction->mAction;
+        }
+    }
+    return NULL;
+}
+
+void DynOS_Opt_AddAction(const String& aFuncName, bool (*aFuncPtr)(const char *), bool aOverwrite) {
+    Array<DynosAction *> &pDynosActions = DynOS_Opt_GetActionList();
+    for (auto &_DynosAction : pDynosActions) {
+        if (_DynosAction->mFuncName == aFuncName) {
+            if (aOverwrite) {
+                _DynosAction->mAction = aFuncPtr;
+            }
+            return;
+        }
+    }
+    DynosAction *_DynosAction = New<DynosAction>();
+    _DynosAction->mFuncName = aFuncName;
+    _DynosAction->mAction = aFuncPtr;
+    pDynosActions.Add(_DynosAction);
+}
+
+//
+// Constructors
+//
+
+static DynosOption *DynOS_Opt_NewOption(const String &aName, const String &aConfigName, const String &aLabel, const String &aTitle) {
+    DynosOption *_Opt = New<DynosOption>();
+    _Opt->mName       = aName;
+    _Opt->mConfigName = aConfigName;
+    _Opt->mLabel      = { aLabel, NULL };
+    _Opt->mTitle      = { aTitle, NULL };
+    _Opt->mDynos      = true;
+    if (sPrevOpt == NULL) { // The very first option
+        _Opt->mPrev   = NULL;
+        _Opt->mNext   = NULL;
+        _Opt->mParent = NULL;
+        sDynosMenu    = _Opt;
+    } else {
+    if (sPrevOpt->mType == DOPT_SUBMENU && sPrevOpt->mSubMenu.mEmpty) { // First option of a sub-menu
+        _Opt->mPrev   = NULL;
+        _Opt->mNext   = NULL;
+        _Opt->mParent = sPrevOpt;
+        sPrevOpt->mSubMenu.mChild = _Opt;
+        sPrevOpt->mSubMenu.mEmpty = false;
+    } else {
+        _Opt->mPrev   = sPrevOpt;
+        _Opt->mNext   = NULL;
+        _Opt->mParent = sPrevOpt->mParent;
+        sPrevOpt->mNext = _Opt;
+    }
+    }
+    sPrevOpt = _Opt;
+    return _Opt;
+}
+
+static void DynOS_Opt_EndSubMenu() {
+    if (sPrevOpt) {
+        if (sPrevOpt->mType == DOPT_SUBMENU && sPrevOpt->mSubMenu.mEmpty) { // ENDMENU command following a SUBMENU command
+            sPrevOpt->mSubMenu.mEmpty = false;
+        } else {
+            sPrevOpt = sPrevOpt->mParent;
+        }
+    }
+}
+
+static void DynOS_Opt_CreateSubMenu(const String &aName, const String &aLabel, const String &aTitle) {
+    DynosOption *_Opt     = DynOS_Opt_NewOption(aName, "", aLabel, aTitle);
+    _Opt->mType           = DOPT_SUBMENU;
+    _Opt->mSubMenu.mChild = NULL;
+    _Opt->mSubMenu.mEmpty = true;
+}
+
+static void DynOS_Opt_CreateToggle(const String &aName, const String &aConfigName, const String &aLabel, int aValue) {
+    DynosOption *_Opt   = DynOS_Opt_NewOption(aName, aConfigName, aLabel, aLabel);
+    _Opt->mType         = DOPT_TOGGLE;
+    _Opt->mToggle.mTog  = New<bool>();
+    *_Opt->mToggle.mTog = (bool) aValue;
+}
+
+static void DynOS_Opt_CreateScroll(const String &aName, const String &aConfigName, const String &aLabel, int aMin, int aMax, int aStep, int aValue) {
+    DynosOption *_Opt     = DynOS_Opt_NewOption(aName, aConfigName, aLabel, aLabel);
+    _Opt->mType           = DOPT_SCROLL;
+    _Opt->mScroll.mMin    = aMin;
+    _Opt->mScroll.mMax    = aMax;
+    _Opt->mScroll.mStep   = aStep;
+    _Opt->mScroll.mValue  = New<int>();
+    *_Opt->mScroll.mValue = aValue;
+}
+
+static void DynOS_Opt_CreateChoice(const String &aName, const String &aConfigName, const String &aLabel, const Array<String>& aChoices, int aValue) {
+    DynosOption *_Opt      = DynOS_Opt_NewOption(aName, aConfigName, aLabel, aLabel);
+    _Opt->mType            = DOPT_CHOICE;
+    _Opt->mChoice.mIndex   = New<int>();
+    *_Opt->mChoice.mIndex  = aValue;
+    for (const auto &_Choice : aChoices) {
+    _Opt->mChoice.mChoices.Add({ _Choice, NULL });
+    }
+}
+
+static void DynOS_Opt_CreateButton(const String &aName, const String &aLabel, const String& aFuncName) {
+    DynosOption *_Opt       = DynOS_Opt_NewOption(aName, "", aLabel, aLabel);
+    _Opt->mType             = DOPT_BUTTON;
+    _Opt->mButton.mFuncName = aFuncName;
+}
+
+static void DynOS_Opt_CreateBind(const String &aName, const String &aConfigName, const String &aLabel, uint aMask, uint aBind0, uint aBind1, uint aBind2) {
+    DynosOption *_Opt     = DynOS_Opt_NewOption(aName, aConfigName, aLabel, aLabel);
+    _Opt->mType           = DOPT_BIND;
+    _Opt->mBind.mMask     = aMask;
+    _Opt->mBind.mBinds    = New<uint>(3);
+    _Opt->mBind.mBinds[0] = aBind0;
+    _Opt->mBind.mBinds[1] = aBind1;
+    _Opt->mBind.mBinds[2] = aBind2;
+    _Opt->mBind.mIndex    = 0;
+}
+
+static void DynOS_Opt_ReadFile(const SysPath &aFolder, const SysPath &aFilename) {
+
+    // Open file
+    SysPath _FullFilename = fstring("%s/%s", aFolder.c_str(), aFilename.c_str());
+    FILE *_File = fopen(_FullFilename.c_str(), "rt");
+    if (_File == NULL) {
+        return;
+    }
+
+    // Read file and create options
+    char _Buffer[4096];
+    while (fgets(_Buffer, 4096, _File) != NULL) {
+        Array<String> _Tokens = Split(_Buffer, " #\t\r\n\b", "#", true);
+
+        // Empty line
+        if (_Tokens.Empty()) {
+            continue;
+        }
+
+        // SUBMENU [Name] [Label]
+        if (_Tokens[0] == "SUBMENU" && _Tokens.Count() >= 4) {
+            DynOS_Opt_CreateSubMenu(_Tokens[1], _Tokens[2], _Tokens[3]);
+            continue;
+        }
+
+        // TOGGLE  [Name] [Label] [ConfigName] [InitialValue]
+        if (_Tokens[0] == "TOGGLE" && _Tokens.Count() >= 5) {
+            DynOS_Opt_CreateToggle(_Tokens[1], _Tokens[3], _Tokens[2], _Tokens[4].ParseInt());
+            continue;
+        }
+
+        // SCROLL  [Name] [Label] [ConfigName] [InitialValue] [Min] [Max] [Step]
+        if (_Tokens[0] == "SCROLL" && _Tokens.Count() >= 8) {
+            DynOS_Opt_CreateScroll(_Tokens[1], _Tokens[3], _Tokens[2], _Tokens[5].ParseInt(), _Tokens[6].ParseInt(), _Tokens[7].ParseInt(), _Tokens[4].ParseInt());
+            continue;
+        }
+
+        // CHOICE  [Name] [Label] [ConfigName] [InitialValue] [ChoiceStrings...]
+        if (_Tokens[0] == "CHOICE" && _Tokens.Count() >= 6) {
+            DynOS_Opt_CreateChoice(_Tokens[1], _Tokens[3], _Tokens[2], Array<String>(_Tokens.begin() + 5, _Tokens.end()), _Tokens[4].ParseInt());
+            continue;
+        }
+
+        // BUTTON  [Name] [Label] [FuncName]
+        if (_Tokens[0] == "BUTTON" && _Tokens.Count() >= 4) {
+            DynOS_Opt_CreateButton(_Tokens[1], _Tokens[2], _Tokens[3]);
+            continue;
+        }
+
+        // BIND    [Name] [Label] [ConfigName] [Mask] [DefaultValues]
+        if (_Tokens[0] == "BIND" && _Tokens.Count() >= 8) {
+            DynOS_Opt_CreateBind(_Tokens[1], _Tokens[3], _Tokens[2], _Tokens[4].ParseInt(), _Tokens[5].ParseInt(), _Tokens[6].ParseInt(), _Tokens[7].ParseInt());
+            continue;
+        }
+
+        // ENDMENU
+        if (_Tokens[0] == "ENDMENU") {
+            DynOS_Opt_EndSubMenu();
+            continue;
+        }
+    }
+    fclose(_File);
+}
+
+static void DynOS_Opt_LoadOptions() {
+    SysPath _DynosFolder = fstring("%s/%s", sys_exe_path(), DYNOS_FOLDER);
+    DIR *_DynosDir = opendir(_DynosFolder.c_str());
+    sPrevOpt = NULL;
+    if (_DynosDir) {
+        struct dirent *_DynosEnt = NULL;
+        while ((_DynosEnt = readdir(_DynosDir)) != NULL) {
+            SysPath _Filename = SysPath(_DynosEnt->d_name);
+            if (_Filename.find(".txt") == _Filename.length() - 4) {
+                DynOS_Opt_ReadFile(_DynosFolder, _Filename);
+            }
+        }
+        closedir(_DynosDir);
+    }
+}
+
+//
+// Loop through DynosOptions
+//
+
+DynosOption *DynOS_Opt_Loop(DynosOption *aOpt, DynosLoopFunc aFunc, void *aData) {
+    while (aOpt) {
+        if (aOpt->mType == DOPT_SUBMENU) {
+            DynosOption *_Opt = DynOS_Opt_Loop(aOpt->mSubMenu.mChild, aFunc, aData);
+            if (_Opt) {
+                return _Opt;
+            }
+        } else {
+            if (aFunc(aOpt, aData)) {
+                return aOpt;
+            }
+        }
+        aOpt = aOpt->mNext;
+    }
+    return NULL;
+}
+
+//
+// Get/Set values
+//
+
+static bool DynOS_Opt_Get(DynosOption *aOpt, void *aData) {
+    return aOpt->mName == (const char *) aData;
+}
+
+int DynOS_Opt_GetValue(const String &aName) {
+    DynosOption *_Opt = DynOS_Opt_Loop(sDynosMenu, DynOS_Opt_Get, (void *) aName.begin());
+    if (_Opt) {
+        switch (_Opt->mType) {
+            case DOPT_TOGGLE:      return *_Opt->mToggle.mTog;
+            case DOPT_CHOICE:      return *_Opt->mChoice.mIndex;
+            case DOPT_CHOICELEVEL: return *_Opt->mChoice.mIndex;
+            case DOPT_CHOICESTAR:  return *_Opt->mChoice.mIndex;
+            case DOPT_SCROLL:      return *_Opt->mScroll.mValue;
+            default:               break;
+        }
+    }
+    return 0;
+}
+
+void DynOS_Opt_SetValue(const String &aName, int aValue) {
+    DynosOption *_Opt = DynOS_Opt_Loop(sDynosMenu, DynOS_Opt_Get, (void *) aName.begin());
+    if (_Opt) {
+        switch (_Opt->mType) {
+            case DOPT_TOGGLE:      *_Opt->mToggle.mTog   = aValue; break;
+            case DOPT_CHOICE:      *_Opt->mChoice.mIndex = aValue; break;
+            case DOPT_CHOICELEVEL: *_Opt->mChoice.mIndex = aValue; break;
+            case DOPT_CHOICESTAR:  *_Opt->mChoice.mIndex = aValue; break;
+            case DOPT_SCROLL:      *_Opt->mScroll.mValue = aValue; break;
+            default:               break;
+        }
+    }
+}
+
+//
+// Processing
+//
+
+#define SOUND_DYNOS_SAVED   (SOUND_MENU_MARIO_CASTLE_WARP2  | (0xFF << 8))
+#define SOUND_DYNOS_SELECT  (SOUND_MENU_CHANGE_SELECT       | (0xF8 << 8))
+#define SOUND_DYNOS_OK      (SOUND_MENU_CHANGE_SELECT       | (0xF8 << 8))
+#define SOUND_DYNOS_CANCEL  (SOUND_MENU_CAMERA_BUZZ         | (0xFC << 8))
+
+enum {
+    INPUT_LEFT,
+    INPUT_RIGHT,
+    INPUT_A,
+    INPUT_Z
+};
+
+enum {
+    RESULT_NONE,
+    RESULT_OK,
+    RESULT_CANCEL
+};
+
+static int DynOS_Opt_ProcessInput(DynosOption *aOpt, int input) {
+    switch (aOpt->mType) {
+        case DOPT_TOGGLE:
+            if (input == INPUT_LEFT) {
+                *aOpt->mToggle.mTog = false;
+                return RESULT_OK;
+            }
+            if (input == INPUT_RIGHT) {
+                *aOpt->mToggle.mTog = true;
+                return RESULT_OK;
+            }
+            if (input == INPUT_A) {
+                *aOpt->mToggle.mTog = !(*aOpt->mToggle.mTog);
+                return RESULT_OK;
+            }
+            break;
+
+        case DOPT_CHOICE:
+            if (input == INPUT_LEFT) {
+                *aOpt->mChoice.mIndex = (*aOpt->mChoice.mIndex + aOpt->mChoice.mChoices.Count() - 1) % (aOpt->mChoice.mChoices.Count());
+                return RESULT_OK;
+            }
+            if (input == INPUT_RIGHT || input == INPUT_A) {
+                *aOpt->mChoice.mIndex = (*aOpt->mChoice.mIndex + 1) % (aOpt->mChoice.mChoices.Count());
+                return RESULT_OK;
+            }
+            break;
+
+        case DOPT_CHOICELEVEL:
+            if (input == INPUT_LEFT) {
+                *aOpt->mChoice.mIndex = (*aOpt->mChoice.mIndex + DynOS_Level_GetCount(true) - 1) % (DynOS_Level_GetCount(true));
+                return RESULT_OK;
+            }
+            if (input == INPUT_RIGHT || input == INPUT_A) {
+                *aOpt->mChoice.mIndex = (*aOpt->mChoice.mIndex + 1) % (DynOS_Level_GetCount(true));
+                return RESULT_OK;
+            }
+            break;
+
+        case DOPT_CHOICESTAR:
+            if (input == INPUT_LEFT) {
+                *aOpt->mChoice.mIndex = (*aOpt->mChoice.mIndex + 5) % (6);
+                return RESULT_OK;
+            }
+            if (input == INPUT_RIGHT || input == INPUT_A) {
+                *aOpt->mChoice.mIndex = (*aOpt->mChoice.mIndex + 1) % (6);
+                return RESULT_OK;
+            }
+            break;
+
+        case DOPT_SCROLL:
+            if (input == INPUT_LEFT) {
+                *aOpt->mScroll.mValue = MAX(aOpt->mScroll.mMin, *aOpt->mScroll.mValue - aOpt->mScroll.mStep * (gPlayer1Controller->buttonDown & A_BUTTON ? 5 : 1));
+                return RESULT_OK;
+            }
+            if (input == INPUT_RIGHT) {
+                *aOpt->mScroll.mValue = MIN(aOpt->mScroll.mMax, *aOpt->mScroll.mValue + aOpt->mScroll.mStep * (gPlayer1Controller->buttonDown & A_BUTTON ? 5 : 1));
+                return RESULT_OK;
+            }
+            break;
+
+        case DOPT_BIND:
+            if (input == INPUT_LEFT) {
+                aOpt->mBind.mIndex = MAX(0, aOpt->mBind.mIndex - 1);
+                return RESULT_OK;
+            }
+            if (input == INPUT_RIGHT) {
+                aOpt->mBind.mIndex = MIN(2, aOpt->mBind.mIndex + 1);
+                return RESULT_OK;
+            }
+            if (input == INPUT_Z) {
+                aOpt->mBind.mBinds[aOpt->mBind.mIndex] = VK_INVALID;
+                return RESULT_OK;
+            }
+            if (input == INPUT_A) {
+                aOpt->mBind.mBinds[aOpt->mBind.mIndex] = VK_INVALID;
+                sBindingState = 1;
+                controller_get_raw_key();
+                return RESULT_OK;
+            }
+            break;
+
+        case DOPT_BUTTON:
+            if (input == INPUT_A) {
+                DynosActionFunction _Action = DynOS_Opt_GetAction(aOpt->mButton.mFuncName);
+                if (_Action != NULL && _Action(aOpt->mName.begin())) {
+                    return RESULT_OK;
+                }
+                return RESULT_CANCEL;
+            }
+            break;
+
+        case DOPT_SUBMENU:
+            if (input == INPUT_A) {
+                if (aOpt->mSubMenu.mChild != NULL) {
+                    sCurrentOpt = aOpt->mSubMenu.mChild;
+                    return RESULT_OK;
+                }
+                return RESULT_CANCEL;
+            }
+            break;
+    }
+    return RESULT_NONE;
+}
+
+static void DynOS_Opt_Open(DynosOption *aMenu) {
+    play_sound(SOUND_DYNOS_SELECT, gDefaultSoundArgs);
+    sCurrentMenu = aMenu;
+    sCurrentOpt = aMenu;
+}
+
+static void DynOS_Opt_Close() {
+    if (sCurrentMenu != NULL) {
+        play_sound(SOUND_DYNOS_SAVED, gDefaultSoundArgs);
+        controller_reconfigure();
+        configfile_save(configfile_name());
+        DynOS_Opt_SaveConfig(sDynosMenu);
+        sCurrentMenu = NULL;
+    }
+}
+
+static void DynOS_Opt_ProcessInputs() {
+    static int sStickTimer = 0;
+    static bool sPrevStick = 0;
+
+    // Stick values
+    float _StickX = gPlayer1Controller->stickX;
+    float _StickY = gPlayer1Controller->stickY;
+    if (absx(_StickX) > 60 || absx(_StickY) > 60) {
+        if (sStickTimer == 0) {
+            sStickTimer = (sPrevStick ? 2 : 9);
+        } else {
+            _StickX = 0;
+            _StickY = 0;
+            sStickTimer--;
+        }
+        sPrevStick = true;
+    } else {
+        sStickTimer = 0;
+        sPrevStick = false;
+    }
+
+    // Key binding
+    if (sBindingState != 0) {
+        uint _Key = (sCurrentOpt->mDynos ? (uint) DynOS_Opt_ControllerGetKeyPressed() : controller_get_raw_key());
+        if (_Key != VK_INVALID) {
+            play_sound(SOUND_DYNOS_SELECT, gDefaultSoundArgs);
+            sCurrentOpt->mBind.mBinds[sCurrentOpt->mBind.mIndex] = _Key;
+            sBindingState = false;
+        }
+        return;
+    }
+
+    if (sCurrentMenu != NULL) {
+
+        // Up
+        if (_StickY > +60) {
+            if (sCurrentOpt->mPrev != NULL) {
+                sCurrentOpt = sCurrentOpt->mPrev;
+            } else {
+                while (sCurrentOpt->mNext) sCurrentOpt = sCurrentOpt->mNext;
+            }
+            play_sound(SOUND_DYNOS_SELECT, gDefaultSoundArgs);
+            return;
+        }
+
+        // Down
+        if (_StickY < -60) {
+            if (sCurrentOpt->mNext != NULL) {
+                sCurrentOpt = sCurrentOpt->mNext;
+            } else {
+                while (sCurrentOpt->mPrev) sCurrentOpt = sCurrentOpt->mPrev;
+            }
+            play_sound(SOUND_DYNOS_SELECT, gDefaultSoundArgs);
+            return;
+        }
+
+        // Left
+        if (_StickX < -60) {
+            switch (DynOS_Opt_ProcessInput(sCurrentOpt, INPUT_LEFT)) {
+                case RESULT_OK:     play_sound(SOUND_DYNOS_OK, gDefaultSoundArgs); break;
+                case RESULT_CANCEL: play_sound(SOUND_DYNOS_CANCEL, gDefaultSoundArgs); break;
+                case RESULT_NONE:   break;
+            }
+            return;
+        }
+
+        // Right
+        if (_StickX > +60) {
+            switch (DynOS_Opt_ProcessInput(sCurrentOpt, INPUT_RIGHT)) {
+                case RESULT_OK:     play_sound(SOUND_DYNOS_OK, gDefaultSoundArgs); break;
+                case RESULT_CANCEL: play_sound(SOUND_DYNOS_CANCEL, gDefaultSoundArgs); break;
+                case RESULT_NONE:   break;
+            }
+            return;
+        }
+
+        // A
+        if (gPlayer1Controller->buttonPressed & A_BUTTON) {
+            switch (DynOS_Opt_ProcessInput(sCurrentOpt, INPUT_A)) {
+                case RESULT_OK:     play_sound(SOUND_DYNOS_OK, gDefaultSoundArgs); break;
+                case RESULT_CANCEL: play_sound(SOUND_DYNOS_CANCEL, gDefaultSoundArgs); break;
+                case RESULT_NONE:   break;
+            }
+            return;
+        }
+
+        // B
+        if (gPlayer1Controller->buttonPressed & B_BUTTON) {
+            if (sCurrentOpt->mParent != NULL) {
+                sCurrentOpt = sCurrentOpt->mParent;
+                play_sound(SOUND_DYNOS_SELECT, gDefaultSoundArgs);
+            } else {
+                DynOS_Opt_Close();
+            }
+            return;
+        }
+
+        // Z
+        if (gPlayer1Controller->buttonPressed & Z_TRIG) {
+            switch (DynOS_Opt_ProcessInput(sCurrentOpt, INPUT_Z)) {
+                case RESULT_OK:     play_sound(SOUND_DYNOS_OK, gDefaultSoundArgs); break;
+                case RESULT_CANCEL: play_sound(SOUND_DYNOS_CANCEL, gDefaultSoundArgs); break;
+                case RESULT_NONE:
+                    if (sCurrentMenu == sDynosMenu) {
+                        DynOS_Opt_Close();
+                    } else {
+                        DynOS_Opt_Open(sDynosMenu);
+                    } break;
+            }
+            return;
+        }
+
+        // R
+        if (gPlayer1Controller->buttonPressed & R_TRIG) {
+            if (sCurrentMenu == sOptionsMenu) {
+                DynOS_Opt_Close();
+            } else {
+                DynOS_Opt_Open(sOptionsMenu);
+            }
+            return;
+        }
+
+        // Start
+        if (gPlayer1Controller->buttonPressed & START_BUTTON) {
+            DynOS_Opt_Close();
+            return;
+        }
+    } else if (gPlayer1Controller->buttonPressed & R_TRIG) {
+        DynOS_Opt_Open(sOptionsMenu);
+    } else if (gPlayer1Controller->buttonPressed & Z_TRIG) {
+        DynOS_Opt_Open(sDynosMenu);
+    }
+}
+
+//
+// Init
+//
+
+static void DynOS_Opt_CreateWarpToLevelSubMenu() {
+    DynOS_Opt_CreateSubMenu("dynos_warp_to_level_submenu", "Warp to Level", "WARP TO LEUEL");
+
+    // Level select
+    {
+    DynosOption *aOpt = DynOS_Opt_NewOption("dynos_warp_level", "", "Level Select", "");
+    aOpt->mType           = DOPT_CHOICELEVEL;
+    aOpt->mChoice.mIndex  = New<int>();
+    *aOpt->mChoice.mIndex = 0;
+    }
+
+    // Star select
+    {
+    DynosOption *aOpt = DynOS_Opt_NewOption("dynos_warp_act", "", "Star Select", "");
+    aOpt->mType           = DOPT_CHOICESTAR;
+    aOpt->mChoice.mIndex  = New<int>();
+    *aOpt->mChoice.mIndex = 0;
+    }
+
+    DynOS_Opt_CreateButton("dynos_warp_to_level", "Warp", "DynOS_Opt_WarpToLevel");
+    DynOS_Opt_EndSubMenu();
+}
+
+static void DynOS_Opt_CreateWarpToCastleSubMenu() {
+    DynOS_Opt_CreateSubMenu("dynos_warp_to_castle_submenu", "Warp to Castle", "WARP TO CASTLE");
+
+    // Level select
+    {
+    DynosOption *aOpt = DynOS_Opt_NewOption("dynos_warp_castle", "", "Level Exit", "");
+    aOpt->mType           = DOPT_CHOICELEVEL;
+    aOpt->mChoice.mIndex  = New<int>();
+    *aOpt->mChoice.mIndex = 0;
+    }
+
+    DynOS_Opt_CreateButton("dynos_warp_to_castle", "Warp", "DynOS_Opt_WarpToCastle");
+    DynOS_Opt_EndSubMenu();
+}
+
+static void DynOS_Opt_CreateModelPacksSubMenu() {
+    Array<String> _Packs = DynOS_Gfx_Init();
+    if (_Packs.Count() == 0) {
+        return;
+    }
+
+    DynOS_Opt_CreateSubMenu("dynos_model_loader_submenu", "Model Packs", "MODEL PACKS");
+    for (int i = 0; i != _Packs.Count(); ++i) {
+        DynOS_Opt_CreateToggle(String("dynos_pack_%d", i), "", _Packs[i], false);
+    }
+    DynOS_Opt_CreateButton("dynos_packs_disable_all", "Disable all packs", "DynOS_Opt_DisableAllPacks");
+    DynOS_Opt_EndSubMenu();
+}
+
+static void (*controller_read)(OSContPad *);
+void DynOS_Opt_Init() {
+
+    // Convert options menu
+    DynOS_Opt_InitVanilla(sOptionsMenu);
+
+    // Create DynOS menu
+    DynOS_Opt_LoadOptions();
+
+    // Warp to level
+    DynOS_Opt_CreateWarpToLevelSubMenu();
+
+    // Warp to castle
+    DynOS_Opt_CreateWarpToCastleSubMenu();
+
+    // Restart level
+    DynOS_Opt_CreateButton("dynos_restart_level", "Restart Level", "DynOS_Opt_RestartLevel");
+
+    // Exit level
+    DynOS_Opt_CreateButton("dynos_exit_level", "Exit Level", "DynOS_Opt_ExitLevel");
+
+    // Return to main menu
+    DynOS_Opt_CreateButton("dynos_return_to_main_menu", "Return to Main Menu", "DynOS_Opt_ReturnToMainMenu");
+
+    // Model loader
+    DynOS_Opt_CreateModelPacksSubMenu();
+
+    // Init config
+    DynOS_Opt_LoadConfig(sDynosMenu);
+
+    // Init DynOS update routine
+    controller_read = controller_keyboard.read;
+    controller_keyboard.read = (void (*)(OSContPad *)) DynOS_UpdateOpt;
+}
+
+//
+// Update
+//
+
+void DynOS_Opt_Update(OSContPad *aPad) {
+    controller_read(aPad);
+    DynOS_Opt_Loop(sDynosMenu, DynOS_Opt_ControllerUpdate, (void *) aPad);
+}
+
+//
+// Hijack
+// This is C code
+//
+
+extern "C" {
+
+ubyte optmenu_open = 0;
+
+void optmenu_toggle(void) {
+    DynOS_Opt_Close();
+    optmenu_open = 0;
+}
+
+void optmenu_draw(void) {
+    DynOS_Opt_DrawMenu(sCurrentOpt, sCurrentMenu, sOptionsMenu, sDynosMenu);
+}
+
+void optmenu_draw_prompt(void) {
+    DynOS_Opt_DrawPrompt(sCurrentMenu, sOptionsMenu, sDynosMenu);
+    DynOS_Opt_ProcessInputs();
+    optmenu_open = (sCurrentMenu != NULL);
+}
+
+void optmenu_check_buttons(void) {
+}
+
+}
+
+//
+// Built-in options
+//
+
+static bool DynOS_Opt_ReturnToMainMenu(UNUSED const char *optName) {
+    return DynOS_ReturnToMainMenu();
+}
+DYNOS_DEFINE_ACTION(DynOS_Opt_ReturnToMainMenu);
+
+static bool DynOS_Opt_WarpToLevel(UNUSED const char *optName) {
+    return DynOS_WarpToLevel(DynOS_Level_GetList(true, true)[DynOS_Opt_GetValue("dynos_warp_level")], DynOS_Opt_GetValue("dynos_warp_act") + 1);
+}
+DYNOS_DEFINE_ACTION(DynOS_Opt_WarpToLevel);
+
+static bool DynOS_Opt_WarpToCastle(UNUSED const char *optName) {
+    return DynOS_WarpToCastle(DynOS_Level_GetList(true, true)[DynOS_Opt_GetValue("dynos_warp_castle")]);
+}
+DYNOS_DEFINE_ACTION(DynOS_Opt_WarpToCastle);
+
+static bool DynOS_Opt_RestartLevel(UNUSED const char *optName) {
+    return DynOS_RestartLevel();
+}
+DYNOS_DEFINE_ACTION(DynOS_Opt_RestartLevel);
+
+static bool DynOS_Opt_ExitLevel(UNUSED const char *optName) {
+    return DynOS_ExitLevel(30);
+}
+DYNOS_DEFINE_ACTION(DynOS_Opt_ExitLevel);
+
+static bool DynOS_Opt_DisableAllPacks(UNUSED const char *optName) {
+    const Array<SysPath> &pDynosPacks = DynOS_Gfx_GetPackList();
+    for (int i = 0; i != pDynosPacks.Count(); ++i) {
+        DynOS_Opt_SetValue(String("dynos_pack_%d", i), false);
+    }
+    return true;
+}
+DYNOS_DEFINE_ACTION(DynOS_Opt_DisableAllPacks);
diff --git a/data/dynos_opt_config.cpp b/data/dynos_opt_config.cpp
new file mode 100644
index 0000000..5a9d060
--- /dev/null
+++ b/data/dynos_opt_config.cpp
@@ -0,0 +1,85 @@
+#include "dynos.cpp.h"
+
+extern DynosOption *DynOS_Opt_Loop(DynosOption *aOpt, DynosLoopFunc aFunc, void *aData);
+
+static bool DynOS_Opt_GetConfig(DynosOption *aOpt, void *aData) {
+    Pair<ubyte, String> _TypeAndName = *((Pair<ubyte, String> *) aData);
+    return (aOpt->mType == _TypeAndName.first && aOpt->mConfigName == _TypeAndName.second);
+}
+
+void DynOS_Opt_LoadConfig(DynosOption *aMenu) {
+    SysPath _Filename = fstring("%s/%s", sys_user_path(), DYNOS_CONFIG_FILENAME);
+    FILE *_File = fopen(_Filename.c_str(), "rb");
+    if (_File == NULL) {
+        return;
+    }
+
+    while (true) {
+        Pair<ubyte, String> _ConfigTypeAndName = { DOPT_NONE, "" };
+        _ConfigTypeAndName.first = ReadBytes<ubyte>(_File);
+        _ConfigTypeAndName.second.Read(_File);
+        if (_ConfigTypeAndName.first == DOPT_NONE) {
+            break;
+        }
+
+        DynosOption *_Opt = DynOS_Opt_Loop(aMenu, DynOS_Opt_GetConfig, (void *) &_ConfigTypeAndName);
+        if (_Opt != NULL) {
+            switch (_Opt->mType) {
+                case DOPT_TOGGLE: *_Opt->mToggle.mTog    = ReadBytes<bool>(_File); break;
+                case DOPT_CHOICE: *_Opt->mChoice.mIndex  = ReadBytes<int> (_File); break;
+                case DOPT_SCROLL: *_Opt->mScroll.mValue  = ReadBytes<int> (_File); break;
+                case DOPT_BIND:    _Opt->mBind.mBinds[0] = ReadBytes<uint>(_File);
+                                   _Opt->mBind.mBinds[1] = ReadBytes<uint>(_File);
+                                   _Opt->mBind.mBinds[2] = ReadBytes<uint>(_File); break;
+            }
+        }
+    }
+    fclose(_File);
+}
+
+static bool DynOS_Opt_SetConfig(DynosOption *aOpt, void *aData) {
+    if (aOpt->mConfigName.Length() != 0 &&
+        aOpt->mConfigName          != "null" &&
+        aOpt->mConfigName          != "NULL") {
+        FILE *_File = (FILE *) aData;
+        switch (aOpt->mType) {
+            case DOPT_TOGGLE:
+                WriteBytes<ubyte>(_File, DOPT_TOGGLE);
+                aOpt->mConfigName.Write(_File);
+                WriteBytes<bool>(_File, *aOpt->mToggle.mTog);
+                break;
+
+            case DOPT_CHOICE:
+                WriteBytes<ubyte>(_File, DOPT_CHOICE);
+                aOpt->mConfigName.Write(_File);
+                WriteBytes<int>(_File, *aOpt->mChoice.mIndex);
+                break;
+
+            case DOPT_SCROLL:
+                WriteBytes<ubyte>(_File, DOPT_SCROLL);
+                aOpt->mConfigName.Write(_File);
+                WriteBytes<int>(_File, *aOpt->mScroll.mValue);
+                break;
+
+            case DOPT_BIND:
+                WriteBytes<ubyte>(_File, DOPT_BIND);
+                aOpt->mConfigName.Write(_File);
+                WriteBytes<uint>(_File, aOpt->mBind.mBinds[0]);
+                WriteBytes<uint>(_File, aOpt->mBind.mBinds[1]);
+                WriteBytes<uint>(_File, aOpt->mBind.mBinds[2]);
+                break;
+        }
+    }
+    return 0;
+}
+
+void DynOS_Opt_SaveConfig(DynosOption *aMenu) {
+    SysPath _Filename = fstring("%s/%s", sys_user_path(), DYNOS_CONFIG_FILENAME);
+    FILE *_File = fopen(_Filename.c_str(), "wb");
+    if (!_File) {
+        return;
+    }
+
+    DynOS_Opt_Loop(aMenu, DynOS_Opt_SetConfig, (void *) _File);
+    fclose(_File);
+}
diff --git a/data/dynos_opt_cont.cpp b/data/dynos_opt_cont.cpp
new file mode 100644
index 0000000..33b950c
--- /dev/null
+++ b/data/dynos_opt_cont.cpp
@@ -0,0 +1,70 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "pc/controller/controller_api.h"
+}
+
+static bool DynOS_Opt_ControllerIsKeyDown(int aCont, int aKey) {
+
+    // Keyboard
+    if (aCont == 0 && aKey >= 0 && aKey < SDL_NUM_SCANCODES) {
+        return SDL_GetKeyboardState(NULL)[aKey];
+    }
+
+    // Game Controller
+    else if (aKey >= 0x1000) {
+
+        // Button
+        int _Button = (aKey - 0x1000);
+        if (_Button < SDL_CONTROLLER_BUTTON_MAX) {
+            return SDL_GameControllerGetButton(SDL_GameControllerOpen(aCont - 1), SDL_GameControllerButton(_Button));
+        }
+
+        // Axis
+        int _Axis = (aKey - 0x1000 - SDL_CONTROLLER_BUTTON_MAX);
+        if (_Axis < SDL_CONTROLLER_AXIS_MAX * 2) {
+            int _AxisValue = SDL_GameControllerGetAxis(SDL_GameControllerOpen(aCont - 1), SDL_GameControllerAxis(_Axis / 2));
+            if (_Axis & 1) return (_AxisValue < (SHRT_MIN / 2));
+            else           return (_AxisValue > (SHRT_MAX / 2));
+        }
+    }
+    // Invalid
+    return false;
+}
+
+#define MAX_CONTS 8
+bool DynOS_Opt_ControllerUpdate(DynosOption *aOpt, void *aData) {
+    if (aOpt->mType == DOPT_BIND) {
+        OSContPad *pad = (OSContPad *) aData;
+        for (int _Cont = 0; _Cont < MAX_CONTS; ++_Cont)
+        for (int _Bind = 0; _Bind < 3; ++_Bind) {
+            pad->button |= aOpt->mBind.mMask * DynOS_Opt_ControllerIsKeyDown(_Cont, aOpt->mBind.mBinds[_Bind]);
+        }
+    }
+    return false;
+}
+
+#define MAX_GKEYS (SDL_CONTROLLER_BUTTON_MAX + SDL_CONTROLLER_AXIS_MAX * 2)
+int sBindingState = 0; // 0 = No bind, 1 = Wait for all keys released, 2 = Return first pressed key
+int DynOS_Opt_ControllerGetKeyPressed() {
+
+    // Keyboard
+    for (int _Key = 0; _Key < SDL_NUM_SCANCODES; ++_Key) {
+        if (DynOS_Opt_ControllerIsKeyDown(0, _Key)) {
+            if (sBindingState == 1) return VK_INVALID;
+            return _Key;
+        }
+    }
+
+    // Game Controller
+    for (int _Cont = 1; _Cont < MAX_CONTS; ++_Cont)
+    for (int _Key = 0; _Key < MAX_GKEYS; ++_Key) {
+        if (DynOS_Opt_ControllerIsKeyDown(_Cont, _Key + 0x1000)) {
+            if (sBindingState == 1) return VK_INVALID;
+            return _Key + 0x1000;
+        }
+    }
+
+    // No key
+    sBindingState = 2;
+    return VK_INVALID;
+}
diff --git a/data/dynos_opt_render.cpp b/data/dynos_opt_render.cpp
new file mode 100644
index 0000000..934281f
--- /dev/null
+++ b/data/dynos_opt_render.cpp
@@ -0,0 +1,281 @@
+#include "dynos.cpp.h"
+extern "C" {
+#include "game/game_init.h"
+#include "game/ingame_menu.h"
+#include "game/segment2.h"
+#include "pc/controller/controller_api.h"
+#include "gfx_dimensions.h"
+}
+
+extern int sBindingState;
+
+#define DYNOS_TEXT_DYNOS_MENU   { "DYNOS MENU",  NULL }
+#define DYNOS_TEXT_A            { "([A]) >",     NULL }
+#define DYNOS_TEXT_OPEN_LEFT    { "[Z] DynOS",   NULL }
+#define DYNOS_TEXT_CLOSE_LEFT   { "[Z] Return",  NULL }
+#define DYNOS_TEXT_OPTIONS_MENU { "OPTIONS",     NULL }
+#define DYNOS_TEXT_DISABLED     { "Disabled",    NULL }
+#define DYNOS_TEXT_ENABLED      { "Enabled",     NULL }
+#define DYNOS_TEXT_NONE         { "NONE",        NULL }
+#define DYNOS_TEXT_DOT_DOT_DOT  { "...",         NULL }
+#define DYNOS_TEXT_OPEN_RIGHT   { "[R] Options", NULL }
+#define DYNOS_TEXT_CLOSE_RIGHT  { "[R] Return",  NULL }
+
+static void RenderString(const ubyte *aStr64, int aX, int aY) {
+    create_dl_translation_matrix(MENU_MTX_PUSH, aX, aY, 0);
+    for (; *aStr64 != DIALOG_CHAR_TERMINATOR; ++aStr64) {
+        if (*aStr64 != DIALOG_CHAR_SPACE) {
+            void **fontLUT = (void **) segmented_to_virtual(main_font_lut);
+            void *packedTexture = segmented_to_virtual(fontLUT[*aStr64]);
+            gDPPipeSync(gDisplayListHead++);
+            gDPSetTextureImage(gDisplayListHead++, G_IM_FMT_IA, G_IM_SIZ_16b, 1, VIRTUAL_TO_PHYSICAL(packedTexture));
+            gSPDisplayList(gDisplayListHead++, dl_ia_text_tex_settings);
+        }
+        create_dl_translation_matrix(MENU_MTX_NOPUSH, DynOS_String_WidthChar64(*aStr64), 0, 0);
+    }
+    gSPPopMatrix(gDisplayListHead++, G_MTX_MODELVIEW);
+}
+
+static void PrintString(const Label& aLabel, int aX, int aY, uint aFrontColorRGBA, uint aBackColorRGBA, bool aAlignLeft) {
+    const ubyte *_Str64 = (aLabel.second ? aLabel.second : DynOS_String_Convert(aLabel.first.begin(), false));
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_begin);
+    if ((aBackColorRGBA & 0xFF) != 0) {
+        gDPSetEnvColor(gDisplayListHead++, ((aBackColorRGBA >> 24) & 0xFF), ((aBackColorRGBA >> 16) & 0xFF), ((aBackColorRGBA >> 8) & 0xFF), ((aBackColorRGBA >> 0) & 0xFF));
+        if (aAlignLeft) {
+            RenderString(_Str64, GFX_DIMENSIONS_FROM_LEFT_EDGE(aX) + 1, aY - 1);
+        } else {
+            RenderString(_Str64, GFX_DIMENSIONS_FROM_RIGHT_EDGE(aX + DynOS_String_Width(_Str64) - 1), aY - 1);
+        }
+    }
+    if ((aFrontColorRGBA & 0xFF) != 0) {
+        gDPSetEnvColor(gDisplayListHead++, ((aFrontColorRGBA >> 24) & 0xFF), ((aFrontColorRGBA >> 16) & 0xFF), ((aFrontColorRGBA >> 8) & 0xFF), ((aFrontColorRGBA >> 0) & 0xFF));
+        if (aAlignLeft) {
+            RenderString(_Str64, GFX_DIMENSIONS_FROM_LEFT_EDGE(aX), aY);
+        } else {
+            RenderString(_Str64, GFX_DIMENSIONS_FROM_RIGHT_EDGE(aX + DynOS_String_Width(_Str64)), aY);
+        }
+    }
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_end);
+    gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+}
+
+static void PrintBox(int aX, int aY, int aWidth, int aHeight, uint aColorRGBA, bool aAlignLeft) {
+    if ((aColorRGBA && 0xFF) != 0) {
+        Mtx *_Matrix = (Mtx *) alloc_display_list(sizeof(Mtx));
+        if (!_Matrix) return;
+        if (aAlignLeft) {
+            create_dl_translation_matrix(MENU_MTX_PUSH, GFX_DIMENSIONS_FROM_LEFT_EDGE(aX), aY + aHeight, 0);
+        } else {
+            create_dl_translation_matrix(MENU_MTX_PUSH, GFX_DIMENSIONS_FROM_RIGHT_EDGE(aX + aWidth), aY + aHeight, 0);
+        }
+        guScale(_Matrix, (float) aWidth / 130.f, (float) aHeight / 80.f, 1.f);
+        gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(_Matrix), G_MTX_MODELVIEW | G_MTX_MUL | G_MTX_NOPUSH);
+        gDPSetEnvColor(gDisplayListHead++, ((aColorRGBA >> 24) & 0xFF), ((aColorRGBA >> 16) & 0xFF), ((aColorRGBA >> 8) & 0xFF), ((aColorRGBA >> 0) & 0xFF));
+        gSPDisplayList(gDisplayListHead++, dl_draw_text_bg_box);
+        gSPPopMatrix(gDisplayListHead++, G_MTX_MODELVIEW);
+        gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    }
+}
+
+#define get_label(opt)  (opt->mLabel)
+#define get_title(opt)  (opt->mTitle)
+#define get_choice(opt) (opt->mChoice.mChoices[*opt->mChoice.mIndex])
+#define get_level(opt)  { "", DynOS_Level_GetName(DynOS_Level_GetList(true, true)[*opt->mChoice.mIndex], true, true) }
+#define get_star(opt)   { "", DynOS_Level_GetActName(DynOS_Level_GetList(true, true)[DynOS_Opt_GetValue("dynos_warp_level")], *opt->mChoice.mIndex + 1, true, true) }
+
+static int GetCurrentOptionCount(DynosOption *aCurrentOpt) {
+    int _Count = 0;
+    while (aCurrentOpt->mPrev) { aCurrentOpt = aCurrentOpt->mPrev; }
+    while (aCurrentOpt) { aCurrentOpt = aCurrentOpt->mNext; _Count++; }
+    return _Count;
+}
+
+static int GetCurrentOptionIndex(DynosOption *aCurrentOpt) {
+    int _Index = 0;
+    while (aCurrentOpt->mPrev) { aCurrentOpt = aCurrentOpt->mPrev; _Index++; }
+    return _Index;
+}
+
+#define PREV(opt) (opt == NULL ? NULL : opt->mPrev)
+#define NEXT(opt) (opt == NULL ? NULL : opt->mNext)
+static DynosOption **GetCurrentOptions(DynosOption *aCurrentOpt) {
+    static DynosOption *sOptionList[13];
+
+    sOptionList[6]  = aCurrentOpt;
+    sOptionList[5]  = PREV(sOptionList[6]);
+    sOptionList[4]  = PREV(sOptionList[5]);
+    sOptionList[3]  = PREV(sOptionList[4]);
+    sOptionList[2]  = PREV(sOptionList[3]);
+    sOptionList[1]  = PREV(sOptionList[2]);
+    sOptionList[0]  = PREV(sOptionList[1]);
+    sOptionList[7]  = NEXT(sOptionList[6]);
+    sOptionList[8]  = NEXT(sOptionList[7]);
+    sOptionList[9]  = NEXT(sOptionList[8]);
+    sOptionList[10] = NEXT(sOptionList[9]);
+    sOptionList[11] = NEXT(sOptionList[10]);
+    sOptionList[12] = NEXT(sOptionList[11]);
+
+    int _StartIndex = 12, _EndIndex = 0;
+    for (int i = 0; i != 13; ++i) {
+        if (sOptionList[i] != NULL) {
+            _StartIndex = MIN(_StartIndex, i);
+            _EndIndex = MAX(_EndIndex, i);
+        }
+    }
+
+    if (_EndIndex - _StartIndex < 7) {
+        return &sOptionList[_StartIndex];
+    }
+    if (_EndIndex <= 9) {
+        return &sOptionList[_EndIndex - 6];
+    }
+    if (_StartIndex >= 3) {
+        return &sOptionList[_StartIndex];
+    }
+    return &sOptionList[3];
+}
+#undef PREV
+#undef NEXT
+
+#define COLOR_WHITE             0xFFFFFFFF
+#define COLOR_BLACK             0x000000FF
+#define COLOR_GRAY              0xA0A0A0FF
+#define COLOR_DARK_GRAY         0x808080FF
+#define COLOR_SELECT            0x80E0FFFF
+#define COLOR_SELECT_BOX        0x00FFFF20
+#define COLOR_ENABLED           0x20E020FF
+#define COLOR_DISABLED          0xFF2020FF
+#define OFFSET_FROM_LEFT_EDGE   (20.f * sqr(GFX_DIMENSIONS_ASPECT_RATIO))
+#define OFFSET_FROM_RIGHT_EDGE  (20.f * sqr(GFX_DIMENSIONS_ASPECT_RATIO))
+#define SCROLL_BAR_SIZE         ((int) (45.f * GFX_DIMENSIONS_ASPECT_RATIO))
+
+static void DynOS_Opt_DrawOption(DynosOption *aOpt, DynosOption *aCurrentOpt, int aY) {
+    if (aOpt == NULL) {
+        return;
+    }
+
+    // Selected box
+    if (aOpt == aCurrentOpt) {
+        ubyte _Alpha = (ubyte) ((coss(gGlobalTimer * 0x800) + 1.f) * 0x20);
+        PrintBox(OFFSET_FROM_LEFT_EDGE - 4, aY - 2, GFX_DIMENSIONS_FROM_RIGHT_EDGE(OFFSET_FROM_RIGHT_EDGE) - GFX_DIMENSIONS_FROM_LEFT_EDGE(OFFSET_FROM_LEFT_EDGE) + 8, 20, COLOR_SELECT_BOX + _Alpha, 1);
+    }
+
+    // Label
+    if (aOpt == aCurrentOpt) {
+        PrintString(get_label(aOpt), OFFSET_FROM_LEFT_EDGE, aY, COLOR_SELECT, COLOR_BLACK, 1);
+    } else {
+        PrintString(get_label(aOpt), OFFSET_FROM_LEFT_EDGE, aY, COLOR_WHITE, COLOR_BLACK, 1);
+    }
+
+    // Values
+    int aWidth;
+    switch (aOpt->mType) {
+        case DOPT_TOGGLE:
+            if (*aOpt->mToggle.mTog) {
+                PrintString(DYNOS_TEXT_ENABLED, OFFSET_FROM_RIGHT_EDGE, aY, COLOR_ENABLED, COLOR_BLACK, 0);
+            } else {
+                PrintString(DYNOS_TEXT_DISABLED, OFFSET_FROM_RIGHT_EDGE, aY, COLOR_DISABLED, COLOR_BLACK, 0);
+            }
+            break;
+
+        case DOPT_CHOICE:
+            PrintString(get_choice(aOpt), OFFSET_FROM_RIGHT_EDGE, aY, aOpt == aCurrentOpt ? COLOR_SELECT : COLOR_WHITE, COLOR_BLACK, 0);
+            break;
+
+        case DOPT_CHOICELEVEL:
+            PrintString(get_level(aOpt), OFFSET_FROM_RIGHT_EDGE, aY, aOpt == aCurrentOpt ? COLOR_SELECT : COLOR_WHITE, COLOR_BLACK, 0);
+            break;
+
+        case DOPT_CHOICESTAR:
+            PrintString(get_star(aOpt), OFFSET_FROM_RIGHT_EDGE, aY, aOpt == aCurrentOpt ? COLOR_SELECT : COLOR_WHITE, COLOR_BLACK, 0);
+            break;
+
+        case DOPT_SCROLL:
+            aWidth = (int) (SCROLL_BAR_SIZE * (float) (*aOpt->mScroll.mValue - aOpt->mScroll.mMin) / (float) (aOpt->mScroll.mMax - aOpt->mScroll.mMin));
+            PrintString({ String("%d", *aOpt->mScroll.mValue), NULL }, OFFSET_FROM_RIGHT_EDGE, aY, aOpt == aCurrentOpt ? COLOR_SELECT : COLOR_WHITE, COLOR_BLACK, 0);
+            PrintBox(OFFSET_FROM_RIGHT_EDGE + 28, aY + 4, SCROLL_BAR_SIZE + 2, 8, COLOR_DARK_GRAY, 0);
+            PrintBox(OFFSET_FROM_RIGHT_EDGE + 29 + SCROLL_BAR_SIZE - aWidth, aY + 5, aWidth, 6, aOpt == aCurrentOpt ? COLOR_SELECT : COLOR_WHITE, 0);
+            break;
+
+        case DOPT_BIND:
+            for (int i = 0; i != 3; ++i) {
+                uint _Bind = aOpt->mBind.mBinds[i];
+                if (aOpt == aCurrentOpt && i == aOpt->mBind.mIndex) {
+                    if (sBindingState != 0) {
+                        PrintString(DYNOS_TEXT_DOT_DOT_DOT, OFFSET_FROM_RIGHT_EDGE + (2 - i) * 36, aY, COLOR_SELECT, COLOR_BLACK, 0);
+                    } else if (_Bind == VK_INVALID) {
+                        PrintString(DYNOS_TEXT_NONE, OFFSET_FROM_RIGHT_EDGE + (2 - i) * 36, aY, COLOR_SELECT, COLOR_BLACK, 0);
+                    } else {
+                        PrintString({ String("%04X", _Bind), NULL }, OFFSET_FROM_RIGHT_EDGE + (2 - i) * 36, aY, COLOR_SELECT, COLOR_BLACK, 0);
+                    }
+                } else {
+                    if (_Bind == VK_INVALID) {
+                        PrintString(DYNOS_TEXT_NONE, OFFSET_FROM_RIGHT_EDGE + (2 - i) * 36, aY, COLOR_GRAY, COLOR_BLACK, 0);
+                    } else {
+                        PrintString({ String("%04X", _Bind), NULL }, OFFSET_FROM_RIGHT_EDGE + (2 - i) * 36, aY, COLOR_WHITE, COLOR_BLACK, 0);
+                    }
+                }
+            }
+            break;
+
+        case DOPT_BUTTON:
+            break;
+
+        case DOPT_SUBMENU:
+            if (aOpt == aCurrentOpt) {
+                PrintString(DYNOS_TEXT_A, OFFSET_FROM_RIGHT_EDGE, aY, COLOR_SELECT, COLOR_BLACK, 0);
+            }
+            break;
+    }
+}
+
+void DynOS_Opt_DrawMenu(DynosOption *aCurrentOption, DynosOption *aCurrentMenu, DynosOption *aOptionsMenu, DynosOption *aDynosMenu) {
+    if (aCurrentMenu == NULL) {
+        return;
+    }
+
+    // Colorful label
+    Label _Title;
+    if (aCurrentOption->mParent) {
+        _Title = get_title(aCurrentOption->mParent);
+    } else if (aCurrentMenu == aDynosMenu) {
+        _Title = DYNOS_TEXT_DYNOS_MENU;
+    } else if (aCurrentMenu == aOptionsMenu) {
+        _Title = DYNOS_TEXT_OPTIONS_MENU;
+    }
+    gSPDisplayList(gDisplayListHead++, dl_rgba16_text_begin);
+    gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    if (!_Title.second) _Title.second = DynOS_String_Convert(_Title.first.begin(), false);
+    print_hud_lut_string(HUD_LUT_GLOBAL, (SCREEN_WIDTH / 2 - DynOS_String_Length(_Title.second) * 6), 40, _Title.second);
+    gSPDisplayList(gDisplayListHead++, dl_rgba16_text_end);
+
+    // Display options
+    DynosOption **_Options = GetCurrentOptions(aCurrentOption);
+    for (int i = 0; i != 7; ++i) {
+        DynOS_Opt_DrawOption(_Options[i], aCurrentOption, 156 - 20 * i);
+    }
+
+    // Scroll bar
+    int _OptCount = GetCurrentOptionCount(aCurrentOption);
+    int _OptIndex = GetCurrentOptionIndex(aCurrentOption);
+    if (_OptCount > 7) {
+        int _Height = (int) (134.f * sqrtf(1.f / (_OptCount - 6)));
+        int _Y = 37 + (134 - _Height) * (1.f - MAX(0.f, MIN(1.f, (float)(_OptIndex - 3) / (float)(_OptCount - 6))));
+        PrintBox(OFFSET_FROM_RIGHT_EDGE - 16, 36, 8, 136, COLOR_DARK_GRAY, 0);
+        PrintBox(OFFSET_FROM_RIGHT_EDGE - 15, _Y, 6, _Height, COLOR_WHITE, 0);
+    }
+}
+
+#define PROMPT_OFFSET (56.25f * GFX_DIMENSIONS_ASPECT_RATIO)
+void DynOS_Opt_DrawPrompt(DynosOption *aCurrentMenu, DynosOption *aOptionsMenu, DynosOption *aDynosMenu) {
+    if (aCurrentMenu == aOptionsMenu) {
+        PrintString(DYNOS_TEXT_OPEN_LEFT,   PROMPT_OFFSET, 212, COLOR_WHITE, COLOR_BLACK, 1);
+        PrintString(DYNOS_TEXT_CLOSE_RIGHT, PROMPT_OFFSET, 212, COLOR_WHITE, COLOR_BLACK, 0);
+    } else if (aCurrentMenu == aDynosMenu) {
+        PrintString(DYNOS_TEXT_CLOSE_LEFT,  PROMPT_OFFSET, 212, COLOR_WHITE, COLOR_BLACK, 1);
+        PrintString(DYNOS_TEXT_OPEN_RIGHT,  PROMPT_OFFSET, 212, COLOR_WHITE, COLOR_BLACK, 0);
+    } else {
+        PrintString(DYNOS_TEXT_OPEN_LEFT,   PROMPT_OFFSET, 212, COLOR_WHITE, COLOR_BLACK, 1);
+        PrintString(DYNOS_TEXT_OPEN_RIGHT,  PROMPT_OFFSET, 212, COLOR_WHITE, COLOR_BLACK, 0);
+    }
+}
diff --git a/data/dynos_opt_vanilla.cpp b/data/dynos_opt_vanilla.cpp
new file mode 100644
index 0000000..b6e0c68
--- /dev/null
+++ b/data/dynos_opt_vanilla.cpp
@@ -0,0 +1,159 @@
+#include "dynos.cpp.h"
+
+static DynosOption *sPrevOpt = NULL;
+static DynosOption *sOptionsMenu = NULL;
+
+//
+// Vanilla actions
+//
+
+typedef void (*VanillaActionFunction)(struct Option *, int);
+typedef struct VanillaAction {
+    String mFuncName;
+    VanillaActionFunction mAction;
+} VanillaAction;
+
+static Array<VanillaAction *> &DynOS_Opt_GetVanillaActionList() {
+    static Array<VanillaAction *> sDynosActions;
+    return sDynosActions;
+}
+
+static VanillaActionFunction DynOS_Opt_GetVanillaAction(const String& aFuncName) {
+    Array<VanillaAction *> &pDynosActions = DynOS_Opt_GetVanillaActionList();
+    for (auto &_DynosAction : pDynosActions) {
+        if (_DynosAction->mFuncName == aFuncName) {
+            return _DynosAction->mAction;
+        }
+    }
+    return NULL;
+}
+
+static void DynOS_Opt_AddVanillaAction(const String& aFuncName, void (*aFuncPtr)(struct Option *, int)) {
+    Array<VanillaAction *> &pDynosActions = DynOS_Opt_GetVanillaActionList();
+    for (auto &_DynosAction : pDynosActions) {
+        if (_DynosAction->mFuncName == aFuncName) {
+            return;
+        }
+    }
+    VanillaAction *_DynosAction = New<VanillaAction>();
+    _DynosAction->mFuncName = aFuncName;
+    _DynosAction->mAction = aFuncPtr;
+    pDynosActions.Add(_DynosAction);
+}
+
+static bool DynOS_Opt_CallVanillaAction(const char *aOptName) {
+    VanillaActionFunction _Func = DynOS_Opt_GetVanillaAction(aOptName);
+    if (_Func) {
+        _Func(NULL, 0);
+        return true;
+    }
+    return false;
+}
+
+//
+// Convert classic options menu into DynOS menu
+//
+
+static DynosOption *DynOS_Opt_ConvertOption(const ubyte *aLabel, const ubyte *aTitle) {
+    static uint sOptIdx = 0;
+    DynosOption *_Opt   = New<DynosOption>();
+    _Opt->mName         = String("vanilla_opt_%08X", sOptIdx++);
+    _Opt->mConfigName   = "";
+    _Opt->mLabel        = { "", aLabel };
+    _Opt->mTitle        = { "", aTitle };
+    _Opt->mDynos        = false;
+    if (sPrevOpt == NULL) { // The very first option
+        _Opt->mPrev     = NULL;
+        _Opt->mNext     = NULL;
+        _Opt->mParent   = NULL;
+        sOptionsMenu    = _Opt;
+    } else {
+    if (sPrevOpt->mType == DOPT_SUBMENU && sPrevOpt->mSubMenu.mEmpty) { // First option of a sub-menu
+        _Opt->mPrev     = NULL;
+        _Opt->mNext     = NULL;
+        _Opt->mParent   = sPrevOpt;
+        sPrevOpt->mSubMenu.mChild = _Opt;
+        sPrevOpt->mSubMenu.mEmpty = false;
+    } else {
+        _Opt->mPrev     = sPrevOpt;
+        _Opt->mNext     = NULL;
+        _Opt->mParent   = sPrevOpt->mParent;
+        sPrevOpt->mNext = _Opt;
+    }
+    }
+    sPrevOpt = _Opt;
+    return _Opt;
+}
+
+static void DynOS_Opt_EndSubMenu() {
+    if (sPrevOpt) {
+        if (sPrevOpt->mType == DOPT_SUBMENU && sPrevOpt->mSubMenu.mEmpty) { // ENDMENU command following a SUBMENU command
+            sPrevOpt->mSubMenu.mEmpty = false;
+        } else {
+            sPrevOpt = sPrevOpt->mParent;
+        }
+    }
+}
+
+static void DynOS_Opt_ConvertSubMenu(const ubyte *aLabel, const ubyte *aTitle) {
+    DynosOption *_Opt     = DynOS_Opt_ConvertOption(aLabel, aTitle);
+    _Opt->mType           = DOPT_SUBMENU;
+    _Opt->mSubMenu.mChild = NULL;
+    _Opt->mSubMenu.mEmpty = true;
+}
+
+static void DynOS_Opt_ConvertToggle(const ubyte *aLabel, bool *pValue) {
+    DynosOption *_Opt  = DynOS_Opt_ConvertOption(aLabel, aLabel);
+    _Opt->mType        = DOPT_TOGGLE;
+    _Opt->mToggle.mTog = (bool *) pValue;
+}
+
+static void DynOS_Opt_ConvertScroll(const ubyte *aLabel, int aMin, int aMax, int aStep, uint *pValue) {
+    DynosOption *_Opt    = DynOS_Opt_ConvertOption(aLabel, aLabel);
+    _Opt->mType          = DOPT_SCROLL;
+    _Opt->mScroll.mMin   = aMin;
+    _Opt->mScroll.mMax   = aMax;
+    _Opt->mScroll.mStep  = aStep;
+    _Opt->mScroll.mValue = (int *) pValue;
+}
+
+static void DynOS_Opt_ConvertChoice(const ubyte *aLabel, const ubyte **aChoices, int aCount, uint *pValue) {
+    DynosOption *_Opt    = DynOS_Opt_ConvertOption(aLabel, aLabel);
+    _Opt->mType          = DOPT_CHOICE;
+    _Opt->mChoice.mIndex = (int *) pValue;
+    for (int i = 0; i != aCount; ++i) {
+    _Opt->mChoice.mChoices.Add({ "", aChoices[i] });
+    }
+}
+
+static void DynOS_Opt_ConvertButton(const ubyte *aLabel, VanillaActionFunction aAction) {
+    DynosOption *_Opt       = DynOS_Opt_ConvertOption(aLabel, aLabel);
+    _Opt->mType             = DOPT_BUTTON;
+    _Opt->mButton.mFuncName = "DynOS_Opt_CallVanillaAction";
+    DynOS_Opt_AddVanillaAction(_Opt->mName, aAction);
+}
+
+static void DynOS_Opt_ConvertBind(const ubyte *aLabel, uint *pBinds) {
+    DynosOption *_Opt  = DynOS_Opt_ConvertOption(aLabel, aLabel);
+    _Opt->mType        = DOPT_BIND;
+    _Opt->mBind.mMask  = 0;
+    _Opt->mBind.mBinds = pBinds;
+    _Opt->mBind.mIndex = 0;
+}
+
+extern "C" {
+extern void dynos_opt_convert_vanilla_main_menu();
+void dynos_opt_end_submenu() { return DynOS_Opt_EndSubMenu(); }
+void dynos_opt_convert_submenu(const ubyte *label, const ubyte *title) { return DynOS_Opt_ConvertSubMenu(label, title); }
+void dynos_opt_convert_toggle(const ubyte *label, bool *bval) { return DynOS_Opt_ConvertToggle(label, bval); }
+void dynos_opt_convert_scroll(const ubyte *label, int min, int max, int step, uint *uval) { return DynOS_Opt_ConvertScroll(label, min, max, step, uval); }
+void dynos_opt_convert_choice(const ubyte *label, const ubyte **choices, int numChoices, uint *uval) { return DynOS_Opt_ConvertChoice(label, choices, numChoices, uval); }
+void dynos_opt_convert_button(const ubyte *label, void *action) { return DynOS_Opt_ConvertButton(label, (VanillaActionFunction) action); }
+void dynos_opt_convert_bind(const ubyte *label, uint *uval) { return DynOS_Opt_ConvertBind(label, uval); }
+}
+void DynOS_Opt_InitVanilla(DynosOption *&aOptionsMenu) {
+    sPrevOpt = NULL;
+    dynos_opt_convert_vanilla_main_menu();
+    DynOS_Opt_AddAction("DynOS_Opt_CallVanillaAction", DynOS_Opt_CallVanillaAction, true);
+    aOptionsMenu = sOptionsMenu;
+}
diff --git a/data/dynos_opt_vanilla_c.c b/data/dynos_opt_vanilla_c.c
new file mode 100644
index 0000000..5578ffa
--- /dev/null
+++ b/data/dynos_opt_vanilla_c.c
@@ -0,0 +1,71 @@
+#include "dynos.c.h"
+
+// Not my problem
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wsizeof-pointer-div"
+#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
+#pragma GCC diagnostic ignored "-Wpointer-sign"
+#pragma GCC diagnostic ignored "-Wsign-compare"
+#define optmenu_toggle optmenu_toggle_unused
+#define optmenu_draw optmenu_draw_unused
+#define optmenu_draw_prompt optmenu_draw_prompt_unused
+#define optmenu_check_buttons optmenu_check_buttons_unused
+#define optmenu_open optmenu_open_unused
+#define DYNOS_INL
+#include "game/options_menu.c"
+#undef DYNOS_INL
+#undef optmenu_toggle
+#undef optmenu_draw
+#undef optmenu_draw_prompt
+#undef optmenu_check_buttons
+#undef optmenu_open
+#pragma GCC diagnostic pop
+// Now, that's my problem
+
+extern void dynos_opt_end_submenu();
+extern void dynos_opt_convert_submenu(const ubyte *label, const ubyte *title);
+extern void dynos_opt_convert_toggle(const ubyte *label, bool *bval);
+extern void dynos_opt_convert_scroll(const ubyte *label, int min, int max, int step, uint *uval);
+extern void dynos_opt_convert_choice(const ubyte *label, const ubyte **choices, int numChoices, uint *uval);
+extern void dynos_opt_convert_button(const ubyte *label, void *action);
+extern void dynos_opt_convert_bind(const ubyte *label, uint *uval);
+
+static void dynos_opt_convert_menu(struct SubMenu *submenu) {
+    for (int i = 0; i != submenu->numOpts; ++i) {
+        struct Option *opt = &submenu->opts[i];
+        switch (opt->type) {
+            case OPT_TOGGLE:
+                dynos_opt_convert_toggle(opt->label, opt->bval);
+                break;
+
+            case OPT_CHOICE:
+                dynos_opt_convert_choice(opt->label, opt->choices, opt->numChoices, opt->uval);
+                break;
+
+            case OPT_SCROLL:
+                dynos_opt_convert_scroll(opt->label, opt->scrMin, opt->scrMax, opt->scrStep, opt->uval);
+                break;
+
+            case OPT_SUBMENU:
+                dynos_opt_convert_submenu(opt->label, opt->nextMenu->label);
+                dynos_opt_convert_menu(opt->nextMenu);
+                dynos_opt_end_submenu();
+                break;
+
+            case OPT_BIND:
+                dynos_opt_convert_bind(opt->label, opt->uval);
+                break;
+
+            case OPT_BUTTON:
+                dynos_opt_convert_button(opt->label, opt->actionFn);
+                break;
+
+            default:
+                break;
+        }
+    }
+}
+
+void dynos_opt_convert_vanilla_main_menu() {
+    dynos_opt_convert_menu(&menuMain);
+}
diff --git a/include/types.h b/include/types.h
index b3dc27e..e17be25 100644
--- a/include/types.h
+++ b/include/types.h
@@ -106,6 +106,7 @@ struct GraphNode
     /*0x08*/ struct GraphNode *next;
     /*0x0C*/ struct GraphNode *parent;
     /*0x10*/ struct GraphNode *children;
+    /*0x14*/ const void *georef;
 };

 // struct AnimInfo?
diff --git a/src/engine/geo_layout.c b/src/engine/geo_layout.c
index d071d1a..16f3d05 100644
--- a/src/engine/geo_layout.c
+++ b/src/engine/geo_layout.c
@@ -791,5 +791,6 @@ struct GraphNode *process_geo_layout(struct AllocOnlyPool *pool, void *segptr) {
         GeoLayoutJumpTable[gGeoLayoutCommand[0x00]]();
     }

+    gCurRootGraphNode->georef = segmented_to_virtual(segptr);
     return gCurRootGraphNode;
 }
diff --git a/src/game/game_init.c b/src/game/game_init.c
index c2df451..710fafb 100644
--- a/src/game/game_init.c
+++ b/src/game/game_init.c
@@ -384,9 +384,6 @@ void adjust_analog_stick(struct Controller *controller) {
 // if a demo sequence exists, this will run the demo
 // input list until it is complete. called every frame.
 void run_demo_inputs(void) {
-    // eliminate the unused bits.
-    gControllers[0].controllerData->button &= VALID_BUTTONS;
-
     /*
         Check if a demo inputs list
         exists and if so, run the
diff --git a/src/game/mario_actions_cutscene.c b/src/game/mario_actions_cutscene.c
index 72e7692..fca4677 100644
--- a/src/game/mario_actions_cutscene.c
+++ b/src/game/mario_actions_cutscene.c
@@ -2630,6 +2630,10 @@ static s32 check_for_instant_quicksand(struct MarioState *m) {

 s32 mario_execute_cutscene_action(struct MarioState *m) {
     s32 cancel;
+    extern int dynos_is_level_exit();
+    if (dynos_is_level_exit()) {
+        return FALSE;
+    }

     if (check_for_instant_quicksand(m)) {
         return TRUE;
diff --git a/src/game/object_helpers.c b/src/game/object_helpers.c
index 22b45b3..9ebba3e 100644
--- a/src/game/object_helpers.c
+++ b/src/game/object_helpers.c
@@ -2741,7 +2741,8 @@ s32 cur_obj_update_dialog_with_cutscene(s32 actionArg, s32 dialogFlags, s32 cuts
 }

 s32 cur_obj_has_model(u16 modelID) {
-    if (o->header.gfx.sharedChild == gLoadedGraphNodes[modelID]) {
+    if (o->header.gfx.sharedChild && gLoadedGraphNodes[modelID] &&
+        o->header.gfx.sharedChild->georef == gLoadedGraphNodes[modelID]->georef) {
         return TRUE;
     } else {
         return FALSE;
diff --git a/src/game/object_list_processor.c b/src/game/object_list_processor.c
index 7113e7c..4f5fd8b 100644
--- a/src/game/object_list_processor.c
+++ b/src/game/object_list_processor.c
@@ -682,5 +682,5 @@ void update_objects(UNUSED s32 unused) {
         gTimeStopState &= ~TIME_STOP_ACTIVE;
     }

-    gPrevFrameObjectCount = gObjectCounter;
+    gPrevFrameObjectCount = 0;
 }
diff --git a/src/game/object_list_processor.h b/src/game/object_list_processor.h
index 205ec3f..d8d29a8 100644
--- a/src/game/object_list_processor.h
+++ b/src/game/object_list_processor.h
@@ -24,11 +24,7 @@
  * The maximum number of objects that can be loaded at once.
  */

-#ifdef NODRAWINGDISTANCE
-#define OBJECT_POOL_CAPACITY 960
-#else
-#define OBJECT_POOL_CAPACITY 240
-#endif
+#define OBJECT_POOL_CAPACITY 2048

 /**
  * Every object is categorized into an object list, which controls the order
diff --git a/src/game/options_menu.c b/src/game/options_menu.c
index 56ebdeb..112a949 100644
--- a/src/game/options_menu.c
+++ b/src/game/options_menu.c
@@ -1,5 +1,5 @@
 #ifdef EXT_OPTIONS_MENU
-
+#ifdef DYNOS_INL
 #include "sm64.h"
 #include "text_strings.h"
 #include "engine/math_util.h"
@@ -629,4 +629,5 @@ void optmenu_check_buttons(void) {
     }
 }

+#endif
 #endif // EXT_OPTIONS_MENU
diff --git a/src/game/rendering_graph_node.c b/src/game/rendering_graph_node.c
index d5bf577..2e8fdf5 100644
--- a/src/game/rendering_graph_node.c
+++ b/src/game/rendering_graph_node.c
@@ -820,7 +820,10 @@ static void geo_process_object(struct Object *node) {

         // FIXME: correct types
         if (node->header.gfx.unk38.curAnim != NULL) {
+            extern void dynos_gfx_update_animation(void *);
+            dynos_gfx_update_animation(node);
             geo_set_animation_globals(&node->header.gfx.unk38, hasAnimation);
+            dynos_gfx_update_animation(node);
         }
         if (obj_is_in_view(&node->header.gfx, gMatStack[gMatStackIndex])) {
             Mtx *mtx = alloc_display_list(sizeof(*mtx));
@@ -907,7 +910,10 @@ void geo_process_held_object(struct GraphNodeHeldObject *node) {
         gCurAnimType = 0;
         gCurGraphNodeHeldObject = (void *) node;
         if (node->objNode->header.gfx.unk38.curAnim != NULL) {
+            extern void dynos_gfx_update_animation(void *);
+            dynos_gfx_update_animation(node->objNode);
             geo_set_animation_globals(&node->objNode->header.gfx.unk38, hasAnimation);
+            dynos_gfx_update_animation(node->objNode);
         }

         geo_process_node_and_siblings(node->objNode->header.gfx.sharedChild);
@@ -1034,6 +1040,8 @@ void geo_process_node_and_siblings(struct GraphNode *firstNode) {
  * to set up the projection and draw display lists.
  */
 void geo_process_root(struct GraphNodeRoot *node, Vp *b, Vp *c, s32 clearColor) {
+    extern void dynos_update_gfx();
+    dynos_update_gfx();
     UNUSED s32 unused;

     if (node->node.flags & GRAPH_RENDER_ACTIVE) {
diff --git a/src/pc/gfx/gfx_pc.c b/src/pc/gfx/gfx_pc.c
index a78f2ff..2437b51 100644
--- a/src/pc/gfx/gfx_pc.c
+++ b/src/pc/gfx/gfx_pc.c
@@ -6,10 +6,8 @@
 #include <stdbool.h>
 #include <assert.h>

-#ifdef EXTERNAL_DATA
 #define STB_IMAGE_IMPLEMENTATION
 #include <stb/stb_image.h>
-#endif

 #ifndef _LANGUAGE_C
 #define _LANGUAGE_C
@@ -50,13 +48,8 @@
 #define MAX_LIGHTS 2
 #define MAX_VERTICES 64

-#ifdef EXTERNAL_DATA
-# define MAX_CACHED_TEXTURES 4096 // for preloading purposes
-# define HASH_SHIFT 0
-#else
-# define MAX_CACHED_TEXTURES 512
-# define HASH_SHIFT 5
-#endif
+#define MAX_CACHED_TEXTURES 4096
+#define HASH_SHIFT 0

 #define HASHMAP_LEN (MAX_CACHED_TEXTURES * 2)
 #define HASH_MASK (HASHMAP_LEN - 1)
@@ -607,6 +600,11 @@ static void import_texture(int tile) {
         return;
     }

+    extern int dynos_gfx_import_texture(void **, void *, int, void *, void **, void *, int *, int);
+    if (dynos_gfx_import_texture((void **) &rendering_state.textures[tile], (void *) rdp.loaded_texture[tile].addr, tile, gfx_rapi, (void **) gfx_texture_cache.hashmap, (void *) gfx_texture_cache.pool, (int *) &gfx_texture_cache.pool_pos, MAX_CACHED_TEXTURES)) {
+        return;
+    }
+
     if (gfx_texture_cache_lookup(tile, &rendering_state.textures[tile], rdp.loaded_texture[tile].addr, fmt, siz)) {
         return;
     }
